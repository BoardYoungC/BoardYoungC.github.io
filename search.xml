<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BroadcastReceiver</title>
      <link href="/2025/04/20/BroadcastReceiver/"/>
      <url>/2025/04/20/BroadcastReceiver/</url>
      
        <content type="html"><![CDATA[<h2 id="🚨-什么是-BroadcastReceiver？"><a href="#🚨-什么是-BroadcastReceiver？" class="headerlink" title="🚨 什么是 BroadcastReceiver？"></a>🚨 什么是 BroadcastReceiver？</h2><p><code>BroadcastReceiver</code> 是 Android 提供的一个机制，用于<strong>在应用之间或系统与应用之间传递消息</strong>。比如：</p><ul><li>当手机接收到短信时；</li><li>电池电量变化；</li><li>网络连接变化；</li><li>你自己在 App 内发出一个自定义事件。</li></ul><p>这些“消息”叫做<strong>广播（Broadcast）</strong>，而负责“接收广播”的组件就是 <strong>BroadcastReceiver</strong>。</p><hr><h2 id="🧠-工作原理："><a href="#🧠-工作原理：" class="headerlink" title="🧠 工作原理："></a>🧠 工作原理：</h2><ol><li>某个组件（系统或 app）发送一个广播（用 <code>sendBroadcast()</code>）；</li><li>Android 系统会根据你注册的广播类型，找到匹配的 <code>BroadcastReceiver</code>；</li><li><code>BroadcastReceiver</code> 会执行你定义的逻辑（通常在 <code>onReceive()</code> 方法里写处理逻辑）；</li></ol><hr><h2 id="📦-BroadcastReceiver-分类"><a href="#📦-BroadcastReceiver-分类" class="headerlink" title="📦 BroadcastReceiver 分类"></a>📦 BroadcastReceiver 分类</h2><h3 id="1-静态注册"><a href="#1-静态注册" class="headerlink" title="1. 静态注册"></a>1. <strong>静态注册</strong></h3><ul><li>在 <code>AndroidManifest.xml</code> 中注册</li><li>会在 App 没启动的情况下也能接收到广播（某些系统广播）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.MyReceiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure><h3 id="2-动态注册"><a href="#2-动态注册" class="headerlink" title="2. 动态注册"></a>2. <strong>动态注册</strong></h3><ul><li>在 Java&#x2F;Kotlin 代码中注册</li><li>一般在 Activity 或 Service 的生命周期内注册和注销</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReceiver receiver = new MyReceiver();</span><br><span class="line">IntentFilter filter = new IntentFilter(&quot;com.example.MY_BROADCAST&quot;);</span><br><span class="line">registerReceiver(receiver, filter);  // 注册</span><br><span class="line">unregisterReceiver(receiver);        // 注销（避免内存泄漏）</span><br></pre></td></tr></table></figure><hr><h2 id="🧪-示例：自定义广播发送与接收"><a href="#🧪-示例：自定义广播发送与接收" class="headerlink" title="🧪 示例：自定义广播发送与接收"></a>🧪 示例：自定义广播发送与接收</h2><h3 id="1️⃣-创建一个自定义广播接收器："><a href="#1️⃣-创建一个自定义广播接收器：" class="headerlink" title="1️⃣ 创建一个自定义广播接收器："></a>1️⃣ 创建一个自定义广播接收器：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        // 当广播接收到时，这里会执行</span><br><span class="line">        String data = intent.getStringExtra(&quot;msg&quot;);</span><br><span class="line">        Toast.makeText(context, &quot;收到广播: &quot; + data, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2️⃣-动态注册（例如在-MainActivity-中）："><a href="#2️⃣-动态注册（例如在-MainActivity-中）：" class="headerlink" title="2️⃣ 动态注册（例如在 MainActivity 中）："></a>2️⃣ 动态注册（例如在 MainActivity 中）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyReceiver myReceiver = new MyReceiver();</span><br><span class="line">IntentFilter filter = new IntentFilter(&quot;com.example.MY_BROADCAST&quot;);</span><br><span class="line">registerReceiver(myReceiver, filter);</span><br></pre></td></tr></table></figure><h3 id="3️⃣-发送广播："><a href="#3️⃣-发送广播：" class="headerlink" title="3️⃣ 发送广播："></a>3️⃣ 发送广播：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(&quot;com.example.MY_BROADCAST&quot;);</span><br><span class="line">intent.putExtra(&quot;msg&quot;, &quot;你好，世界！&quot;);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure><hr><h2 id="🔐-权限和安全"><a href="#🔐-权限和安全" class="headerlink" title="🔐 权限和安全"></a>🔐 权限和安全</h2><ul><li><p>有些系统广播需要权限，例如监听开机广播：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xml</span><br><span class="line"></span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>Android 8.0（API 26）之后，对静态注册广播做了限制，一些隐式广播不能再静态注册，只能动态注册。</p></li></ul><hr><h2 id="✅-使用小贴士"><a href="#✅-使用小贴士" class="headerlink" title="✅ 使用小贴士"></a>✅ 使用小贴士</h2><table><thead><tr><th>内容</th><th>建议</th></tr></thead><tbody><tr><td>生命周期管理</td><td>动态注册时，记得在 <code>onDestroy()</code> 中注销广播</td></tr><tr><td>安全性</td><td>自定义广播建议使用 <code>LocalBroadcastManager</code>（已废弃，推荐使用 LiveData&#x2F;EventBus 替代）</td></tr><tr><td>不要做耗时操作</td><td><code>onReceive()</code> 中不能做耗时操作，默认运行在主线程</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> android主要组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android主要组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin中的内联函数</title>
      <link href="/2025/04/20/Kotlin%20%E4%B8%AD%E7%9A%84%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>/2025/04/20/Kotlin%20%E4%B8%AD%E7%9A%84%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="🌟-什么是内联函数？"><a href="#🌟-什么是内联函数？" class="headerlink" title="🌟 什么是内联函数？"></a>🌟 什么是内联函数？</h3><p>简单说：</p><blockquote><p><strong>内联函数就是在编译时将函数的调用代码“展开”为函数体本身，从而避免函数调用的开销。</strong></p></blockquote><p>通常高阶函数（比如 <code>map</code>, <code>filter</code>, <code>let</code>, <code>run</code> 等）都会带来额外的开销，因为它们需要创建函数对象、维护调用栈。而使用 <code>inline</code> 关键字修饰的函数在编译时会将其代码“拷贝”到调用处，避免这些额外开销。</p><hr><h3 id="🧪-基本语法"><a href="#🧪-基本语法" class="headerlink" title="🧪 基本语法"></a>🧪 基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun doSomething(action: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;Start&quot;)</span><br><span class="line">    action()</span><br><span class="line">    println(&quot;End&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething &#123;</span><br><span class="line">    println(&quot;Hello inline&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚡ 编译后，大致等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;Start&quot;)</span><br><span class="line">println(&quot;Hello inline&quot;)</span><br><span class="line">println(&quot;End&quot;)</span><br></pre></td></tr></table></figure><p>函数体直接“插入”到调用处。</p><hr><h3 id="✅-优势"><a href="#✅-优势" class="headerlink" title="✅ 优势"></a>✅ 优势</h3><ol><li><strong>性能提升</strong>：避免函数调用、lambda 对象创建的开销。</li><li><strong>允许非局部返回</strong>（下面详细说）</li><li><strong>适合频繁调用的小型函数或高阶函数</strong></li></ol><hr><h3 id="⚠️-注意：非局部返回（non-local-return）"><a href="#⚠️-注意：非局部返回（non-local-return）" class="headerlink" title="⚠️ 注意：非局部返回（non-local return）"></a>⚠️ 注意：<strong>非局部返回（non-local return）</strong></h3><p>Lambda 中用 <code>return</code>，默认是从<strong>外围函数</strong>返回的，这在内联函数中是允许的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">inline fun doSomething(block: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;Before&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;After&quot;)  // 不会执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun test() &#123;</span><br><span class="line">    doSomething &#123;</span><br><span class="line">        println(&quot;Inside&quot;)</span><br><span class="line">        return  // 非局部 return，直接从 test() 返回</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;This will not be printed&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你把 <code>doSomething</code> 的 <code>inline</code> 去掉，这段代码是<strong>无法通过编译</strong>的。</p><hr><h3 id="🔒-使用-noinline-禁止内联某个-lambda"><a href="#🔒-使用-noinline-禁止内联某个-lambda" class="headerlink" title="🔒 使用 noinline 禁止内联某个 lambda"></a>🔒 使用 <code>noinline</code> 禁止内联某个 lambda</h3><p>有时候你不希望某些 lambda 被内联，可以加 <code>noinline</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline fun process(a: () -&gt; Unit, noinline b: () -&gt; Unit) &#123;</span><br><span class="line">    a()     // 内联</span><br><span class="line">    b()     // 不内联</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用于 <strong>将 lambda 作为值传递或多次使用</strong> 的情况。</p><hr><h3 id="💥-crossinline：阻止-lambda-使用-return"><a href="#💥-crossinline：阻止-lambda-使用-return" class="headerlink" title="💥 crossinline：阻止 lambda 使用 return"></a>💥 <code>crossinline</code>：阻止 lambda 使用 return</h3><p>有时候你<strong>必须内联</strong>，但又<strong>不允许 lambda 使用非局部 return</strong>（比如 lambda 传给另一个线程或匿名类），你可以加 <code>crossinline</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun startJob(crossinline job: () -&gt; Unit) &#123;</span><br><span class="line">    Thread &#123;</span><br><span class="line">        job()  // 如果 job 用 return 会报错</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🚀-小总结"><a href="#🚀-小总结" class="headerlink" title="🚀 小总结"></a>🚀 小总结</h3><table><thead><tr><th>关键字</th><th>作用</th></tr></thead><tbody><tr><td><code>inline</code></td><td>编译时将函数体展开，提升性能，允许非局部 return</td></tr><tr><td><code>noinline</code></td><td>禁止某个 lambda 被内联（用于多次调用或当作对象传递）</td></tr><tr><td><code>crossinline</code></td><td>阻止某个 lambda 使用 <code>return</code>（防止非局部 return）</td></tr></tbody></table><hr><h3 id="✅-典型应用场景"><a href="#✅-典型应用场景" class="headerlink" title="✅ 典型应用场景"></a>✅ 典型应用场景</h3><ul><li><code>apply</code> &#x2F; <code>run</code> &#x2F; <code>let</code> 等标准库函数内部都是 <code>inline</code> 的</li><li>DSL 构建器，比如 <code>anko</code>, <code>Jetpack Compose</code>, <code>Ktor</code> 等大量用 <code>inline</code> 优化性能和语法结构</li><li>性能敏感的高阶函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin的高阶函数详解</title>
      <link href="/2025/04/20/Kotlin%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/20/Kotlin%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Kotlin的高阶函数详解</p><p>Kotlin 的高阶函数（Higher-Order Functions，简称 HOF）是函数式编程的一个重要特性，能够显著增强语言的表达力。高阶函数是指那些可以接受其他函数作为参数，或者返回函数的函数。</p><h3 id="1-高阶函数的定义"><a href="#1-高阶函数的定义" class="headerlink" title="1. 高阶函数的定义"></a>1. 高阶函数的定义</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>高阶函数指的是：</p><ul><li>接受函数作为参数</li><li>或者返回函数</li></ul><h4 id="示例：接受函数作为参数"><a href="#示例：接受函数作为参数" class="headerlink" title="示例：接受函数作为参数"></a>示例：接受函数作为参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; List&lt;T&gt;.customFilter(predicate: (T) -&gt; Boolean): List&lt;T&gt; &#123;</span><br><span class="line">    val result = mutableListOf&lt;T&gt;()</span><br><span class="line">    for (item in this) &#123;</span><br><span class="line">        if (predicate(item)) &#123;</span><br><span class="line">            result.add(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val numbers = listOf(1, 2, 3, 4, 5, 6)</span><br><span class="line">val evenNumbers = numbers.customFilter &#123; it % 2 == 0 &#125;</span><br><span class="line">println(evenNumbers)  // 输出: [2, 4, 6]</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>customFilter</code> 是一个高阶函数，它接受一个函数 <code>predicate</code> 作为参数，并根据该函数筛选列表中的元素。</p><h4 id="示例：返回函数"><a href="#示例：返回函数" class="headerlink" title="示例：返回函数"></a>示例：返回函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun multiplyBy(factor: Int): (Int) -&gt; Int &#123;</span><br><span class="line">    return &#123; number -&gt; number * factor &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val multiplyBy2 = multiplyBy(2)</span><br><span class="line">println(multiplyBy2(4))  // 输出: 8</span><br></pre></td></tr></table></figure><p>这里，<code>multiplyBy</code> 函数返回一个新的函数，它接受一个整数并将其乘以 <code>factor</code>。</p><h3 id="2-常见的高阶函数"><a href="#2-常见的高阶函数" class="headerlink" title="2. 常见的高阶函数"></a>2. 常见的高阶函数</h3><p>Kotlin 标准库包含了许多高阶函数，下面是一些常见的高阶函数。</p><h4 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a><code>map</code> 函数</h4><p><code>map</code> 是一个高阶函数，它接受一个变换函数，并返回一个新集合，其中包含应用该变换函数后的每个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val squared = numbers.map &#123; it * it &#125;</span><br><span class="line">println(squared)  // 输出: [1, 4, 9, 16]</span><br></pre></td></tr></table></figure><h4 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a><code>filter</code> 函数</h4><p><code>filter</code> 函数接受一个筛选条件，并返回一个新集合，只包含符合条件的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4, 5, 6)</span><br><span class="line">val evenNumbers = numbers.filter &#123; it % 2 == 0 &#125;</span><br><span class="line">println(evenNumbers)  // 输出: [2, 4, 6]</span><br></pre></td></tr></table></figure><h4 id="fold-函数"><a href="#fold-函数" class="headerlink" title="fold 函数"></a><code>fold</code> 函数</h4><p><code>fold</code> 是一个折叠函数，它将集合中的每个元素通过一个指定的操作组合起来，返回一个单一的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val sum = numbers.fold(0) &#123; accumulator, element -&gt; accumulator + element &#125;</span><br><span class="line">println(sum)  // 输出: 10</span><br></pre></td></tr></table></figure><p>这里，<code>fold</code> 从初始值 <code>0</code> 开始，依次将每个元素加到累加器上。</p><h4 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce 函数"></a><code>reduce</code> 函数</h4><p><code>reduce</code> 与 <code>fold</code> 类似，区别在于它没有初始值，直接使用集合的第一个元素作为初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val product = numbers.reduce &#123; accumulator, element -&gt; accumulator * element &#125;</span><br><span class="line">println(product)  // 输出: 24</span><br></pre></td></tr></table></figure><h4 id="forEach-函数"><a href="#forEach-函数" class="headerlink" title="forEach 函数"></a><code>forEach</code> 函数</h4><p><code>forEach</code> 是一个遍历集合的高阶函数，它接受一个操作函数，在集合的每个元素上执行该操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3)</span><br><span class="line">numbers.forEach &#123; println(it) &#125;</span><br><span class="line">// 输出:</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><h3 id="3-Lambda-表达式和高阶函数"><a href="#3-Lambda-表达式和高阶函数" class="headerlink" title="3. Lambda 表达式和高阶函数"></a>3. Lambda 表达式和高阶函数</h3><p>Kotlin 中，高阶函数通常与 Lambda 表达式一起使用，Lambda 表达式是一个匿名函数，它可以简洁地表示函数参数。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val sum = &#123; a: Int, b: Int -&gt; a + b &#125;</span><br><span class="line">println(sum(3, 4))  // 输出: 7</span><br></pre></td></tr></table></figure><h3 id="4-函数作为返回值"><a href="#4-函数作为返回值" class="headerlink" title="4. 函数作为返回值"></a>4. 函数作为返回值</h3><p>在 Kotlin 中，函数也可以作为返回值，且可以直接返回一个 Lambda 表达式。</p><h4 id="示例：返回一个高阶函数"><a href="#示例：返回一个高阶函数" class="headerlink" title="示例：返回一个高阶函数"></a>示例：返回一个高阶函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun operation(type: String): (Int, Int) -&gt; Int &#123;</span><br><span class="line">    return when (type) &#123;</span><br><span class="line">        &quot;sum&quot; -&gt; &#123; a, b -&gt; a + b &#125;</span><br><span class="line">        &quot;multiply&quot; -&gt; &#123; a, b -&gt; a * b &#125;</span><br><span class="line">        else -&gt; &#123; a, b -&gt; 0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val sumOperation = operation(&quot;sum&quot;)</span><br><span class="line">println(sumOperation(3, 4))  // 输出: 7</span><br><span class="line"></span><br><span class="line">val multiplyOperation = operation(&quot;multiply&quot;)</span><br><span class="line">println(multiplyOperation(3, 4))  // 输出: 12</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>operation</code> 函数根据不同的 <code>type</code> 返回不同的操作函数。</p><h3 id="5-高阶函数与集合操作结合"><a href="#5-高阶函数与集合操作结合" class="headerlink" title="5. 高阶函数与集合操作结合"></a>5. 高阶函数与集合操作结合</h3><p>Kotlin 高阶函数常常与集合操作结合使用，使得集合的处理更加简洁和高效。比如链式调用 <code>map</code>、<code>filter</code>、<code>reduce</code> 等操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4, 5)</span><br><span class="line">val result = numbers.filter &#123; it % 2 == 0 &#125;</span><br><span class="line">                     .map &#123; it * it &#125;</span><br><span class="line">                     .reduce &#123; acc, i -&gt; acc + i &#125;</span><br><span class="line">println(result)  // 输出: 20</span><br></pre></td></tr></table></figure><h3 id="6-高阶函数和匿名函数的结合"><a href="#6-高阶函数和匿名函数的结合" class="headerlink" title="6. 高阶函数和匿名函数的结合"></a>6. 高阶函数和匿名函数的结合</h3><p>Kotlin 还支持匿名函数，它们和 Lambda 表达式的使用方法类似，但可以显式声明参数类型和返回类型。</p><h4 id="示例：匿名函数"><a href="#示例：匿名函数" class="headerlink" title="示例：匿名函数"></a>示例：匿名函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val sum: (Int, Int) -&gt; Int = fun(a: Int, b: Int): Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(sum(2, 3))  // 输出: 5</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>高阶函数是 Kotlin 中非常强大的功能，它让函数式编程成为可能，能够简化代码并提高可读性。Kotlin 提供了一些内建的高阶函数，如 <code>map</code>、<code>filter</code>、<code>fold</code> 等，允许你对集合和数据进行更灵活的操作。</p><ul><li><strong>接受函数作为参数</strong>：<code>map</code>, <code>filter</code>, <code>fold</code>, 等。</li><li><strong>返回函数</strong>：可以返回一个 Lambda 函数或匿名函数。</li><li><strong>结合 Lambda 表达式使用</strong>：使得代码更加简洁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延迟初始化与封装类</title>
      <link href="/2025/04/06/%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%B0%81%E8%A3%85%E7%B1%BB/"/>
      <url>/2025/04/06/%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%B0%81%E8%A3%85%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="🔹-1-延迟初始化-lateinit"><a href="#🔹-1-延迟初始化-lateinit" class="headerlink" title="🔹 1. 延迟初始化 (lateinit)"></a>🔹 1. 延迟初始化 (<code>lateinit</code>)</h2><h3 id="✅-用途："><a href="#✅-用途：" class="headerlink" title="✅ 用途："></a>✅ 用途：</h3><p>当你不想在定义变量时立刻初始化它，但又确定在使用前一定会初始化（比如依赖注入、测试、Android View 绑定等）。</p><h3 id="✅-语法："><a href="#✅-语法：" class="headerlink" title="✅ 语法："></a>✅ 语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lateinit var name: String</span><br></pre></td></tr></table></figure><h3 id="✅-注意事项："><a href="#✅-注意事项：" class="headerlink" title="✅ 注意事项："></a>✅ 注意事项：</h3><ul><li>只能用于 **<code>var</code>**，不能用于 <code>val</code>。</li><li>只能用于 <strong>非空类型的引用类型</strong>（不能是原始类型如 <code>Int</code>、<code>Double</code>）。</li><li>使用前如果没初始化，会抛出 **<code>UninitializedPropertyAccessException</code>**。</li></ul><h3 id="✅-示例："><a href="#✅-示例：" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    lateinit var nickname: String</span><br><span class="line"></span><br><span class="line">    fun initNickname() &#123;</span><br><span class="line">        nickname = &quot;KotlinFan&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun printNickname() &#123;</span><br><span class="line">        if (::nickname.isInitialized) &#123;</span><br><span class="line">            println(nickname)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println(&quot;nickname 尚未初始化&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-2-密封类（sealed-class）"><a href="#🔹-2-密封类（sealed-class）" class="headerlink" title="🔹 2. 密封类（sealed class）"></a>🔹 2. 密封类（<code>sealed class</code>）</h2><h3 id="✅-用途：-1"><a href="#✅-用途：-1" class="headerlink" title="✅ 用途："></a>✅ 用途：</h3><p>用于表示<strong>受限的类继承结构</strong>，所有子类都必须声明在同一个文件中。常用于表示状态、结果、事件等。</p><p>类似于 Java 的 <code>enum</code>，但可以携带数据。常配合 <code>when</code> 表达式使用，可以 <strong>无需 else</strong> 分支。</p><h3 id="✅-示例：-1"><a href="#✅-示例：-1" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sealed class Result</span><br><span class="line"></span><br><span class="line">data class Success(val data: String) : Result()</span><br><span class="line">data class Error(val message: String) : Result()</span><br><span class="line">object Loading : Result()</span><br><span class="line"></span><br><span class="line">fun handleResult(result: Result) &#123;</span><br><span class="line">    when (result) &#123;</span><br><span class="line">        is Success -&gt; println(&quot;成功: $&#123;result.data&#125;&quot;)</span><br><span class="line">        is Error -&gt; println(&quot;失败: $&#123;result.message&#125;&quot;)</span><br><span class="line">        Loading -&gt; println(&quot;加载中...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔸-总结对比"><a href="#🔸-总结对比" class="headerlink" title="🔸 总结对比"></a>🔸 总结对比</h2><table><thead><tr><th>特性</th><th><code>lateinit</code></th><th><code>sealed class</code></th></tr></thead><tbody><tr><td>用途</td><td>延迟初始化引用变量</td><td>表示受限的继承结构，常用于状态建模</td></tr><tr><td>限制</td><td>不能用于 <code>val</code> 或基本类型</td><td>所有子类必须在同一文件中定义</td></tr><tr><td>常用场景</td><td>Android View、依赖注入等</td><td>网络请求结果、UI状态、表达式分支等</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin的扩展函数和运算符重载</title>
      <link href="/2025/04/06/Kotlin%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2025/04/06/Kotlin%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 的扩展函数（Extension Functions）和运算符重载（Operator Overloading）是两个强大又常用的特性，用于让代码更简洁、表达力更强。</p><hr><h2 id="✅-扩展函数（Extension-Functions）"><a href="#✅-扩展函数（Extension-Functions）" class="headerlink" title="✅ 扩展函数（Extension Functions）"></a>✅ 扩展函数（Extension Functions）</h2><p><strong>定义</strong>：在不修改原类源码的情况下，为类添加新的函数。</p><h3 id="🌟-语法"><a href="#🌟-语法" class="headerlink" title="🌟 语法"></a>🌟 语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun ClassName.functionName(params): ReturnType &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🧪-示例"><a href="#🧪-示例" class="headerlink" title="🧪 示例"></a>🧪 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun String.lastChar(): Char &#123;</span><br><span class="line">    return this[this.length - 1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val s = &quot;Hello&quot;</span><br><span class="line">    println(s.lastChar())  // 输出：&#x27;o&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="📌-注意"><a href="#📌-注意" class="headerlink" title="📌 注意"></a>📌 注意</h3><ul><li><code>this</code> 代表接收者对象（上例中是 <code>String</code>）</li><li>扩展函数<strong>不会真正修改原类</strong>，只是通过静态方式实现“扩展”</li><li>若类有成员函数与扩展函数同名，<strong>成员函数优先</strong></li></ul><hr><h2 id="➕-运算符重载（Operator-Overloading）"><a href="#➕-运算符重载（Operator-Overloading）" class="headerlink" title="➕ 运算符重载（Operator Overloading）"></a>➕ 运算符重载（Operator Overloading）</h2><p><strong>定义</strong>：通过定义带有 <code>operator</code> 关键字的函数，自定义类的运算符行为（如 <code>+</code>, <code>-</code>, <code>[]</code>, <code>==</code> 等）。</p><h3 id="🌟-支持的运算符（部分）"><a href="#🌟-支持的运算符（部分）" class="headerlink" title="🌟 支持的运算符（部分）"></a>🌟 支持的运算符（部分）</h3><table><thead><tr><th>运算符</th><th>对应函数名</th></tr></thead><tbody><tr><td><code>+</code></td><td><code>plus</code></td></tr><tr><td><code>-</code></td><td><code>minus</code></td></tr><tr><td><code>*</code></td><td><code>times</code></td></tr><tr><td><code>/</code></td><td><code>div</code></td></tr><tr><td><code>%</code></td><td><code>rem</code></td></tr><tr><td><code>==</code></td><td><code>equals</code></td></tr><tr><td><code>[]</code></td><td><code>get</code>, <code>set</code></td></tr><tr><td><code>..</code></td><td><code>rangeTo</code></td></tr><tr><td><code>in</code></td><td><code>contains</code></td></tr></tbody></table><h3 id="🧪-示例-1"><a href="#🧪-示例-1" class="headerlink" title="🧪 示例"></a>🧪 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data class Point(val x: Int, val y: Int) &#123;</span><br><span class="line">    operator fun plus(other: Point): Point &#123;</span><br><span class="line">        return Point(x + other.x, y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val p1 = Point(1, 2)</span><br><span class="line">    val p2 = Point(3, 4)</span><br><span class="line">    println(p1 + p2) // 输出：Point(x=4, y=6)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⚠️-注意"><a href="#⚠️-注意" class="headerlink" title="⚠️ 注意"></a>⚠️ 注意</h3><ul><li>需加 <code>operator</code> 关键字</li><li>Kotlin 会根据运算符自动映射到相应的函数</li></ul><hr><h2 id="✨-拓展-运算符重载的组合示例"><a href="#✨-拓展-运算符重载的组合示例" class="headerlink" title="✨ 拓展+运算符重载的组合示例"></a>✨ 拓展+运算符重载的组合示例</h2><p>你甚至可以为已有类<strong>扩展运算符函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">operator fun String.times(n: Int): String &#123;</span><br><span class="line">    return this.repeat(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;Hi! &quot; * 3) // 输出：Hi! Hi! Hi! </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin lambda编程</title>
      <link href="/2025/03/28/kotlin%20lambda/"/>
      <url>/2025/03/28/kotlin%20lambda/</url>
      
        <content type="html"><![CDATA[<h1 id="kotlin-lambda编程"><a href="#kotlin-lambda编程" class="headerlink" title="kotlin lambda编程"></a>kotlin lambda编程</h1><p>Kotlin 的 Lambda（匿名函数）是函数式编程的核心特性之一，允许你以简洁的方式编写代码，尤其适用于集合操作、回调、DSL（领域特定语言）等场景。</p><h2 id="1-Lambda-表达式基础"><a href="#1-Lambda-表达式基础" class="headerlink" title="1. Lambda 表达式基础"></a>1. Lambda 表达式基础</h2><p>Lambda 表达式是一个匿名函数，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val sum: (Int, Int) -&gt; Int = &#123; a, b -&gt; a + b &#125;</span><br><span class="line">println(sum(2, 3)) // 输出 5</span><br></pre></td></tr></table></figure><p><strong>语法说明</strong>：</p><ul><li><code>&#123; 参数1, 参数2 -&gt; 函数体 &#125;</code></li><li><code>val sum: (Int, Int) -&gt; Int</code> 明确声明了函数类型，表示它接收两个 <code>Int</code> 并返回 <code>Int</code>。</li></ul><h2 id="2-使用-it-关键字"><a href="#2-使用-it-关键字" class="headerlink" title="2. 使用 it 关键字"></a>2. 使用 <code>it</code> 关键字</h2><p>当 Lambda 只有一个参数时，可以用 <code>it</code> 代替参数名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val square: (Int) -&gt; Int = &#123; it * it &#125;</span><br><span class="line">println(square(4)) // 输出 16</span><br></pre></td></tr></table></figure><h2 id="3-Lambda-作为函数参数"><a href="#3-Lambda-作为函数参数" class="headerlink" title="3. Lambda 作为函数参数"></a>3. Lambda 作为函数参数</h2><p>Lambda 可以作为参数传递给函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun operateOnNumbers(a: Int, b: Int, operation: (Int, Int) -&gt; Int): Int &#123;</span><br><span class="line">    return operation(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val result = operateOnNumbers(4, 5) &#123; x, y -&gt; x * y &#125;</span><br><span class="line">println(result) // 输出 20</span><br></pre></td></tr></table></figure><h2 id="4-高阶函数-结合-Lambda"><a href="#4-高阶函数-结合-Lambda" class="headerlink" title="4. 高阶函数 结合 Lambda"></a>4. <code>高阶函数</code> 结合 Lambda</h2><p>Kotlin 支持高阶函数（即参数或返回值是函数的函数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun higherOrderFunction(operation: () -&gt; Unit) &#123;</span><br><span class="line">    operation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">higherOrderFunction &#123; println(&quot;Hello, Lambda!&quot;) &#125;</span><br></pre></td></tr></table></figure><h2 id="5-在集合操作中的应用"><a href="#5-在集合操作中的应用" class="headerlink" title="5. 在集合操作中的应用"></a>5. 在集合操作中的应用</h2><p>Lambda 在 Kotlin 的集合 API 中应用广泛，如 <code>map</code>、<code>filter</code>、<code>reduce</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4, 5)</span><br><span class="line">val squaredNumbers = numbers.map &#123; it * it &#125;</span><br><span class="line">println(squaredNumbers) // 输出 [1, 4, 9, 16, 25]</span><br><span class="line"></span><br><span class="line">val evenNumbers = numbers.filter &#123; it % 2 == 0 &#125;</span><br><span class="line">println(evenNumbers) // 输出 [2, 4]</span><br></pre></td></tr></table></figure><h2 id="6-let、apply、run、with、also"><a href="#6-let、apply、run、with、also" class="headerlink" title="6. let、apply、run、with、also"></a>6. <code>let</code>、<code>apply</code>、<code>run</code>、<code>with</code>、<code>also</code></h2><p>Kotlin 提供了一系列作用域函数，结合 Lambda 使用非常强大：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val name: String? = &quot;Kotlin&quot;</span><br><span class="line">name?.let &#123; println(it.uppercase()) &#125; // 非空时执行</span><br><span class="line"></span><br><span class="line">val person = Person(&quot;John&quot;).apply &#123; age = 30 &#125; // apply 适用于修改对象属性</span><br><span class="line">println(person)</span><br></pre></td></tr></table></figure><h2 id="7-闭包（Closure）"><a href="#7-闭包（Closure）" class="headerlink" title="7. 闭包（Closure）"></a>7. 闭包（Closure）</h2><p>Lambda 表达式可以访问外部变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun counter(): () -&gt; Int &#123;</span><br><span class="line">    var count = 0</span><br><span class="line">    return &#123; count++ &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val next = counter()</span><br><span class="line">println(next()) // 0</span><br><span class="line">println(next()) // 1</span><br><span class="line">println(next()) // 2</span><br></pre></td></tr></table></figure><h2 id="8-带-return-的-Lambda"><a href="#8-带-return-的-Lambda" class="headerlink" title="8. 带 return 的 Lambda"></a>8. 带 <code>return</code> 的 Lambda</h2><p>Lambda 默认返回最后一行的值，如果需要提前返回，可以使用 <code>return@label</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listOf(1, 2, 3, 4, 5).forEach &#123; </span><br><span class="line">    if (it == 3) return@forEach </span><br><span class="line">    println(it) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空指针检查</title>
      <link href="/2025/03/28/%E7%A9%BA%E6%8C%87%E9%92%88%E6%A3%80%E6%9F%A5/"/>
      <url>/2025/03/28/%E7%A9%BA%E6%8C%87%E9%92%88%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 通过 <strong>空安全（Null Safety）</strong> 机制减少了空指针异常（NullPointerException，NPE）。以下是 Kotlin 中处理空指针的常见方式：</p><hr><h3 id="1-可空类型"><a href="#1-可空类型" class="headerlink" title="1. 可空类型 (?)"></a>1. <strong>可空类型 (<code>?</code>)</strong></h3><p>Kotlin 默认所有变量都不能为空。如果需要允许 <code>null</code>，必须显式声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = &quot;Kotlin&quot;</span><br><span class="line">name = null  // 允许赋值 null</span><br></pre></td></tr></table></figure><hr><h3 id="2-安全调用"><a href="#2-安全调用" class="headerlink" title="2. 安全调用 (?.)"></a>2. <strong>安全调用 (<code>?.</code>)</strong></h3><p>当变量可能为 <code>null</code> 时，可以使用 <strong>安全调用</strong> 来避免 NPE：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val length: Int? = name?.length  // name 为 null 时，length 也为 null</span><br></pre></td></tr></table></figure><hr><h3 id="3-Elvis-运算符"><a href="#3-Elvis-运算符" class="headerlink" title="3. Elvis 运算符 (?:)"></a>3. <strong>Elvis 运算符 (<code>?:</code>)</strong></h3><p>提供默认值，避免 <code>null</code> 影响程序逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val length: Int = name?.length ?: 0  // name 为 null 时，length 取 0</span><br></pre></td></tr></table></figure><hr><h3 id="4-非空断言"><a href="#4-非空断言" class="headerlink" title="4. 非空断言 (!!)"></a>4. <strong>非空断言 (<code>!!</code>)</strong></h3><p>强制告诉编译器变量不为空，否则抛出 <code>NullPointerException</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val length: Int = name!!.length  // 如果 name 为空，则抛出 NPE</span><br></pre></td></tr></table></figure><p>⚠ <strong>慎用 <code>!!</code>，仅在明确不为空时使用！</strong></p><hr><h3 id="5-let-作用域函数"><a href="#5-let-作用域函数" class="headerlink" title="5. let 作用域函数"></a>5. <strong><code>let</code> 作用域函数</strong></h3><p><code>let</code> 结合安全调用 (<code>?.</code>)，可用于在非空时执行某些操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name?.let &#123;</span><br><span class="line">    println(&quot;Length: $&#123;it.length&#125;&quot;)  // 仅当 name 不为空时执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-lateinit-和-by-lazy"><a href="#6-lateinit-和-by-lazy" class="headerlink" title="6. lateinit 和 by lazy"></a>6. <strong><code>lateinit</code> 和 <code>by lazy</code></strong></h3><ul><li><p><code>lateinit</code> 适用于非 <code>null</code> 类型的延迟初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lateinit var text: String</span><br><span class="line">// text.length // 若未初始化，访问会抛出 UninitializedPropertyAccessException</span><br></pre></td></tr></table></figure></li><li><p><code>lazy</code> 适用于 <code>val</code> 类型的惰性初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val message: String by lazy &#123; &quot;Hello, Kotlin!&quot; &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-requireNotNull-和-checkNotNull"><a href="#7-requireNotNull-和-checkNotNull" class="headerlink" title="7. requireNotNull 和 checkNotNull"></a>7. <strong><code>requireNotNull</code> 和 <code>checkNotNull</code></strong></h3><p>手动检查 <code>null</code> 并抛出异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val nonNullName: String = requireNotNull(name) &#123; &quot;name 不能为空&quot; &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-数据类默认值"><a href="#8-数据类默认值" class="headerlink" title="8. 数据类默认值"></a>8. <strong>数据类默认值</strong></h3><p>如果某个字段可能为空，最好提供默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">data class User(val name: String = &quot;Unknown&quot;)</span><br></pre></td></tr></table></figure><hr><h3 id="9-平台类型-Java-互操作"><a href="#9-平台类型-Java-互操作" class="headerlink" title="9. 平台类型 (Java 互操作)"></a>9. <strong>平台类型 (<code>Java</code> 互操作)</strong></h3><p>从 Java 代码获取的变量可能为空，Kotlin 不能自动推断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val text: String? = javaMethodReturningNullable()  // Java 方法返回值可能为 null</span><br></pre></td></tr></table></figure><hr><h3 id="10-使用-Nullable-和-NotNull-注解"><a href="#10-使用-Nullable-和-NotNull-注解" class="headerlink" title="10. 使用 @Nullable 和 @NotNull 注解"></a>10. <strong>使用 <code>@Nullable</code> 和 <code>@NotNull</code> 注解</strong></h3><p>在 Kotlin 互操作 Java 时，可以使用这些注解来增强类型安全：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">public String getNullableString() &#123; return null; &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>方式</th><th>作用</th></tr></thead><tbody><tr><td><code>?</code></td><td>允许 <code>null</code></td></tr><tr><td><code>?.</code></td><td>安全调用</td></tr><tr><td><code>?:</code></td><td>默认值</td></tr><tr><td><code>!!</code></td><td>非空断言（可能抛 NPE）</td></tr><tr><td><code>let</code></td><td>仅在非空时执行</td></tr><tr><td><code>lateinit</code> &#x2F; <code>lazy</code></td><td>延迟初始化</td></tr><tr><td><code>requireNotNull</code></td><td>手动 <code>null</code> 检查</td></tr><tr><td><code>@Nullable</code></td><td>Java 互操作</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intent</title>
      <link href="/2025/03/28/%E6%98%BE%E5%BC%8FIntent%E4%B8%8E%E9%9A%90%E5%BC%8FIntent/"/>
      <url>/2025/03/28/%E6%98%BE%E5%BC%8FIntent%E4%B8%8E%E9%9A%90%E5%BC%8FIntent/</url>
      
        <content type="html"><![CDATA[<p>显式Intent与隐式Intent</p><h6 id="ChatGPT-说："><a href="#ChatGPT-说：" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>在 Android 中，<strong>Intent（意图）</strong> 是组件（Activity、Service、BroadcastReceiver）之间进行通信的机制。Intent 主要分为两种类型：</p><h3 id="1-显式-Intent（Explicit-Intent）"><a href="#1-显式-Intent（Explicit-Intent）" class="headerlink" title="1. 显式 Intent（Explicit Intent）"></a><strong>1. 显式 Intent（Explicit Intent）</strong></h3><p>显式 Intent 直接指定目标组件（Activity、Service）的 <strong>类名</strong>，用于在 <strong>应用内部</strong> 启动组件。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(this, SecondActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li><strong>适用于应用内部</strong> 组件间的交互，比如从 <code>MainActivity</code> 跳转到 <code>SecondActivity</code>。</li><li><strong>指定目标类名</strong>，不会让系统去匹配 <code>intent-filter</code>。</li><li><strong>性能更高</strong>，因为不需要系统查找匹配的组件。</li></ul><hr><h3 id="2-隐式-Intent（Implicit-Intent）"><a href="#2-隐式-Intent（Implicit-Intent）" class="headerlink" title="2. 隐式 Intent（Implicit Intent）"></a><strong>2. 隐式 Intent（Implicit Intent）</strong></h3><p>隐式 Intent <strong>不指定</strong> 目标组件的类名，而是使用 <strong>动作（Action）、类别（Category）、数据（Data）</strong> 让系统找到符合条件的组件。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><p>打开网页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(Uri.parse(&quot;https://www.example.com&quot;));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>拨打电话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(Intent.ACTION_DIAL);</span><br><span class="line">intent.setData(Uri.parse(&quot;tel:123456789&quot;));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li><p><strong>适用于调用其他应用的功能</strong>，例如打开浏览器、拨号、分享文本等。</p></li><li><p>需要在 <code>AndroidManifest.xml</code> 中声明 <code>intent-filter</code>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.ThirdActivity&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">        &lt;data android:scheme=&quot;https&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>系统会自动匹配</strong> 适合的应用来处理这个 Intent。</p></li></ul><hr><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a><strong>对比总结</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>显式 Intent</strong></th><th><strong>隐式 Intent</strong></th></tr></thead><tbody><tr><td><strong>目标组件</strong></td><td><strong>明确指定</strong> 类名，如 <code>SecondActivity.class</code></td><td><strong>不指定</strong> 类名，使用 <code>Action + Data</code> 让系统匹配</td></tr><tr><td><strong>适用场景</strong></td><td>应用内部跳转，如 <code>ActivityA → ActivityB</code></td><td>调用系统&#x2F;其他应用功能，如打开网页、拨打电话</td></tr><tr><td><strong>匹配方式</strong></td><td><strong>直接找到组件</strong> 并启动</td><td><strong>系统匹配 <code>intent-filter</code></strong> 找到合适的组件</td></tr><tr><td><strong>性能</strong></td><td><strong>更快</strong>，因为不需要匹配</td><td><strong>稍慢</strong>，需要查询可能的匹配组件</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> android主要组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android主要组件 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
