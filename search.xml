<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>回流和重绘</title>
      <link href="/2025/08/23/css/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/"/>
      <url>/2025/08/23/css/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/</url>
      
        <content type="html"><![CDATA[<h2 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h2><p>在 HTML 中，每个元素都可以理解成⼀个盒⼦，在浏览器解析过程中，会涉及到回流与重绘：</p><p>• </p><p>回流：布局引擎会根据各种样式<strong>计算每个盒⼦在⻚⾯上的⼤⼩与位置</strong></p><p>• </p><p>重绘：当<strong>计算好</strong>盒模型的位置、⼤⼩及其他属性后，浏览器<strong>根据每个盒⼦特性进⾏绘制</strong></p><p>在⻚⾯<strong>初始渲染</strong>阶段，<strong>回流不可避免的触发</strong>，可以理解成⻚⾯⼀开始是空⽩的元素，后⾯添加了新的</p><p>元素使⻚⾯布局发⽣改变</p><p>当我们<strong>对 DOM 的修改引发了 DOM ⼏何尺⼨的变化</strong>（⽐如<strong>修改元素的宽、⾼或隐藏元素等</strong>）时，浏</p><p>览器需要<strong>重新计算元素的⼏何属性</strong>，然后<strong>再将计算的结果绘制</strong>出来</p><p>当我们对 DOM 的修改导致了<strong>样式的变化</strong>（ color 或 background-color ），却并未影响其⼏何</p><p>属性时，浏览器不需重新计算元素的⼏何属性、直接为该元素绘制新的样式，这⾥就<strong>仅仅触发了重绘</strong></p><p><strong>回流触发时机</strong></p><p>回流这⼀阶段主要是计算节点的位置和⼏何信息，那么当⻚⾯布局和⼏何信息发⽣变化的时候，就需</p><p>要回流，如下⾯情况：</p><p>• </p><p>添加或删除可⻅的DOM元素</p><p>• </p><p>元素的位置发⽣变化</p><p>• </p><p>元素的尺⼨发⽣变化（包括外边距、内边框、边框⼤⼩、⾼度和宽度等）</p><p>• </p><p>内容发⽣变化，⽐如⽂本变化或图⽚被另⼀个不同尺⼨的图⽚所替代</p><p>• </p><p>⻚⾯⼀开始渲染的时候（这避免不了）</p><p>• </p><p>浏览器的窗⼝尺⼨变化（因为回流是根据视⼝的⼤⼩来计算元素的位置和⼤⼩的）</p><p>还有⼀些容易被忽略的操作：获取⼀些特定属性的值</p><p>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、</p><p>scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</p><p>这些属性有⼀个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进⾏回流</p><p>除此还包括 getComputedStyle ⽅法，原理是⼀样的</p><p><strong>重绘触发时机</strong></p><p>触发回流⼀定会触发重绘</p><p>可以把⻚⾯理解为⼀个⿊板，⿊板上有⼀朵画好的⼩花。现在我们要把这朵从左边移到了右边，那我</p><p>们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜⾊（重绘）</p><p>除此之外还有⼀些其他引起重绘⾏为：</p><p>• </p><p>颜⾊的修改</p><p>• </p><p>⽂本⽅向的修改</p><p>• </p><p>阴影的修改</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>em/px/rem/vh/vw区别</title>
      <link href="/2025/08/15/css/em,px,rem,vhvw%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/08/15/css/em,px,rem,vhvw%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="em-px-rem-vh-vw区别"><a href="#em-px-rem-vh-vw区别" class="headerlink" title="em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别"></a>em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别</h2><p>传统的项⽬开发中，我们只会⽤到 px 、 % 、 em 这⼏个单位，它可以适⽤于⼤部分的项⽬开发，且</p><p>拥有⽐较良好的兼容性</p><p>从 CSS3 开始，浏览器对计量单位的⽀持⼜提升到了另外⼀个境界，新增了 rem 、 vh 、 vw 、</p><p>vm 等⼀些新的计量单位</p><p>利⽤这些新的单位开发出⽐较良好的响应式⻚⾯，适应多种不同分辨率的终端，包括移动设备等</p><p> 单位</p><p>在 css 单位中，可以分为⻓度单位、绝对单位，如下表所指⽰</p><p>这⾥我们主要讲述px、em、rem、vh、vw</p><p> <strong>px</strong>，表⽰像素，所谓像素就是呈现在我们显⽰器上的⼀个个⼩点，每个像素点都是⼤⼩等同的，所以</p><p>像素为计量单位被分在了绝对⻓度单位中</p><p>有些⼈会把 px 认为是相对⻓度，原因在于在移动端中存在设备像素⽐， <strong>px 实际显⽰的⼤⼩是不确</strong></p><p><strong>定的</strong></p><p>这⾥之所以认为 px 为绝对单位，在于 px 的⼤⼩和元素的其他属性⽆关</p><p>16.2.2. em</p><p><strong>em是相对⻓度单位</strong>。相对于当前对象内⽂本的字体尺⼨。如当前对⾏内⽂本的字体尺⼨未被⼈为设</p><p>置，则相对于浏览器的默认字体尺⼨（ <strong>1em &#x3D; 16px</strong> ）</p><p>为了简化 font-size 的换算，我们需要在 css 中的 body 选择器中声明 <strong>font-size &#x3D;</strong></p><p><strong>62.5% ，这就使 em 值变为 16px*62.5% &#x3D; 10px</strong></p><p>这样 12px &#x3D; 1.2em , 10px &#x3D; 1em , 也就是说只需要将你的原来的 px 数值除以 10，然后换上</p><p>em 作为单位就⾏了</p><p>特点：</p><p>• </p><p>em 的值并不是固定的</p><p>• </p><p>em 会继承⽗级元素的字体⼤⼩</p><p>• </p><p>em 是相对⻓度单位。<strong>相对于当前对象内⽂本的字体尺⼨</strong>。如当前对⾏内⽂本的字体尺⼨未被⼈为</p><p>设置，则相对于浏览器的默认字体尺⼨</p><p>• </p><p>任意浏览器的默认字体⾼都是 16px</p><p><strong>rem</strong>，<strong>相对单位，相对的只是HTML根元素 font-size 的值</strong></p><p>同理，如果想要简化 font-size 的转化，我们可以在根元素 html 中加⼊ font-size: 62.5%</p><p>1 html {font-size: 62.5%; } <em>&#x2F;</em>* <em>公式**16px*62.5%&#x3D;10px *&#x2F;</em></p><p>这样⻚⾯中1rem&#x3D;10px、1.2rem&#x3D;12px、1.4rem&#x3D;14px、1.6rem&#x3D;16px;使得视觉、使⽤、书写都得到</p><p>了极⼤的帮助</p><p>特点：</p><p>• </p><p>rem单位可谓集相对⼤⼩和绝对⼤⼩的优点于⼀⾝</p><p>• </p><p><strong>和em不同的是rem总是相对于根元素，⽽不像em⼀样使⽤级联的⽅式来计算尺⼨</strong></p><p> vh、vw</p><p>vw ，就是根据窗⼝的宽度，分成100等份，100vw就表⽰满宽，50vw就表⽰⼀半宽。（vw 始终是针</p><p>对窗⼝的宽），同理， vh 则为窗⼝的⾼度</p><p>这⾥的窗⼝分成⼏种情况：</p><p>• </p><p>在桌⾯端，指的是浏览器的可视区域</p><p>• </p><p>移动端指的就是布局视⼝</p><p>像 vw 、 vh ，⽐较容易混淆的⼀个单位是 % ，不过百分⽐宽泛的讲是相对于⽗元素：</p><p>• </p><p>对于普通定位元素就是我们理解的⽗元素</p><p>• </p><p>对于position: absolute;的元素是相对于已定位的⽗元素</p><p>• </p><p>对于position: fixed;的元素是相对于 ViewPort（可视窗⼝）</p><p>16.3. 总结</p><p>px：绝对单位，⻚⾯按精确像素展⽰</p><p>em：相对单位，<strong>基准点为⽗节点字体的⼤⼩</strong>，如果⾃⾝定义了 font-size 按⾃⾝来计算，整个⻚</p><p>⾯内 1em 不是⼀个固定的值</p><p>rem：相对单位，可理解为 root em , 相<strong>对根节点 html 的字体⼤⼩来计算</strong></p><p><strong>vh、vw：主要⽤于⻚⾯视⼝⼤⼩布局，在⻚⾯布局上更加⽅便简单</strong></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备像素、css像素、设备独⽴像素、dpr、ppi 之间的区别</title>
      <link href="/2025/08/13/css/%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E3%80%81css%E5%83%8F%E7%B4%A0%E3%80%81%E8%AE%BE%E5%A4%87%E7%8B%AC%E2%BD%B4%E5%83%8F%E7%B4%A0%E3%80%81dpr%E3%80%81ppi%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/08/13/css/%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E3%80%81css%E5%83%8F%E7%B4%A0%E3%80%81%E8%AE%BE%E5%A4%87%E7%8B%AC%E2%BD%B4%E5%83%8F%E7%B4%A0%E3%80%81dpr%E3%80%81ppi%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="设备像素、css像素、设备独⽴像素、dpr、ppi-之间的区别"><a href="#设备像素、css像素、设备独⽴像素、dpr、ppi-之间的区别" class="headerlink" title="设备像素、css像素、设备独⽴像素、dpr、ppi 之间的区别"></a>设备像素、css像素、设备独⽴像素、dpr、ppi 之间的区别</h2><p>在 css 中我们通常使⽤px作为单位，在PC浏览器中 css 的1个像素都是对应着电脑屏幕的1个物理像</p><p>素</p><p>这会造成⼀种错觉，我们会认为 css 中的像素就是设备的物理像素但实际情况却并⾮如此， css 中的像素只是⼀个抽象的单位，在不同的设备或不同的环境中， css</p><p>中的1px所代表的设备物理像素是不同的</p><p>当我们做移动端开发时，同为1px的设置，在不同分辨率的移动设备上显⽰效果却有很⼤差异</p><p>这背后就涉及了css像素、设备像素、设备独⽴像素、dpr、ppi的概念</p><p>介绍</p><p> <strong>CSS像素</strong></p><p>CSS像素（css pixel, px）: 适⽤于web编程，在 CSS 中以 px 为后缀，是⼀个⻓度单位</p><p>在 CSS 规范中，⻓度单位可以分为两类，绝对单位以及相对单位</p><p>px是⼀个相对单位，相对的是设备像素（device pixel）</p><p>⼀般情况，⻚⾯缩放⽐为1，1个CSS像素等于1个设备独⽴像素</p><p>CSS 像素⼜具有两个⽅⾯的相对性：</p><p>• </p><p>在同⼀个设备上，每1个 CSS 像素所代表的设备像素是可以变化的（⽐如调整屏幕的分辨率）</p><p>• </p><p>在不同的设备之间，每1个 CSS 像素所代表的设备像素是可以变化的（⽐如两个不同型号的⼿机）</p><p>在⻚⾯进⾏缩放操作也会 引起 css 中 px 的变化，假设⻚⾯放⼤⼀倍，原来的 1px 的东西变成 2px，</p><p>在实际宽度不变的情况下1px 变得跟原来的 2px 的⻓度（⻓宽）⼀样了（元素会占据更多的设备像</p><p>素）</p><p>假设原来需要 320px 才能填满的宽度现在只需要 160px</p><p>px会受到下⾯的因素的影响⽽变化：</p><p>• </p><p>每英⼨像素（PPI）</p><p>• </p><p>设备像素⽐（DPR）</p><p> <strong>设备像素</strong></p><p>设备像素（device pixels），⼜称为物理像素</p><p>指设备能控制显⽰的最⼩物理单位，不⼀定是⼀个⼩正⽅形区块，也没有标准的宽⾼，只是⽤于显⽰</p><p>丰富⾊彩的⼀个“点”⽽已</p><p>可以参考公园⾥的景观变⾊彩灯，⼀个彩灯(物理像素)由红、蓝、绿⼩灯组成，三盏⼩灯不同的亮度混</p><p>合出各种⾊彩图⽚ 加载失败</p><p>从屏幕在⼯⼚⽣产出的那天起，它上⾯设备像素点就固定不变了，单位为 pt</p><p> <strong>设备独⽴像素</strong></p><p>设备独⽴像素（Device Independent Pixel）：与设备⽆关的逻辑像素，代表可以通过程序控制使⽤的</p><p>虚拟像素，是⼀个总体概念，包括了CSS像素</p><p>在 javaScript 中可以通过 window.screen.width&#x2F; window.screen.height 查看</p><p>⽐如我们会说“电脑屏幕在 2560x1600分辨率下不适合玩游戏，我们把它调为 1440x900”，这⾥</p><p>的“分辨率”（⾮严谨说法）指的就是设备独⽴像素</p><p>⼀个设备独⽴像素⾥可能包含1个或者多个物理像素点，包含的越多则屏幕看起来越清晰</p><p>⾄于为什么出现设备独⽴像素这种虚拟像素单位概念，下⾯举个例⼦：</p><p>iPhone 3GS 和 iPhone 4&#x2F;4s 的尺⼨都是 3.5 ⼨，但 iPhone 3GS 的分辨率是 320x480，iPhone 4&#x2F;4s</p><p>的分辨率是 640x960</p><p>这意味着，iPhone 3GS 有 320 个物理像素，iPhone 4&#x2F;4s 有 640 个物理像素</p><p>如果我们按照真实的物理像素进⾏布局，⽐如说我们按照 320 物理像素进⾏布局，到了 640 物理像素</p><p>的⼿机上就会有⼀半的空⽩，为了避免这种问题，就产⽣了虚拟像素单位</p><p>我们统⼀ iPhone 3GS 和 iPhone 4&#x2F;4s 都是 320 个虚拟像素，只是在 iPhone 3GS 上，最终 1 个虚拟像</p><p>素换算成 1 个物理像素，在 iphone 4s 中，1 个虚拟像素最终换算成 2 个物理像素</p><p>⾄于 1 个虚拟像素被换算成⼏个物理像素，这个数值我们称之为设备像素⽐，也就是下⾯介绍的 dpr</p><p><strong>dpr</strong></p><p>dpr（device pixel ratio），设备像素⽐，代表设备独⽴像素到设备像素的转换关系，在</p><p>JavaScript 中可以通过 window.devicePixelRatio 获取</p><p>计算公式如下：图⽚ 加载失败</p><p>当设备像素⽐为1:1时，使⽤1（1×1）个设备像素显⽰1个CSS像素</p><p>当设备像素⽐为2:1时，使⽤4（2×2）个设备像素显⽰1个CSS像素</p><p>当设备像素⽐为3:1时，使⽤9（3×3）个设备像素显⽰1个CSS像素</p><p>如下图所⽰：</p><p>图⽚ 加载失败</p><p>当 dpr 为3，那么 1px 的 CSS 像素宽度对应 3px 的物理像素的宽度，1px的 CSS 像素⾼度对应</p><p>3px 的物理像素⾼度</p><p><strong>ppi</strong></p><p>ppi （pixel per inch），每英⼨像素，表⽰每英⼨所包含的像素点数⽬，更确切的说法应该是像素密</p><p>度。数值越⾼，说明屏幕能以更⾼密度显⽰图像</p><p>计算公式如下：</p><p>图⽚ 加载失败</p><p> <strong>总结</strong></p><p><strong>⽆缩放情况下，1个CSS像素等于1个设备独⽴像素</strong></p><p>设备像素由屏幕⽣产之后就不发⽣改变，⽽设备独⽴像素是⼀个虚拟单位会发⽣改变PC端中，1个设备独⽴像素 &#x3D; 1个设备像素 （在100%，未缩放的情况下）</p><p><strong>在移动端中，标准屏幕（160ppi）下 1个设备独⽴像素 &#x3D; 1个设备像素</strong></p><p><strong>设备像素⽐（dpr） &#x3D; 设备像素 &#x2F; 设备独⽴像素</strong></p><p><strong>每英⼨像素（ppi），值越⼤，图像越清晰</strong></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现两栏布局 右侧⾃适应 三栏布局中间⾃适应</title>
      <link href="/2025/08/08/css/%E5%AE%9E%E7%8E%B0%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%20%E5%8F%B3%E4%BE%A7%E2%BE%83%E9%80%82%E5%BA%94%20%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E4%B8%AD%E9%97%B4%E2%BE%83%E9%80%82%E5%BA%94/"/>
      <url>/2025/08/08/css/%E5%AE%9E%E7%8E%B0%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%20%E5%8F%B3%E4%BE%A7%E2%BE%83%E9%80%82%E5%BA%94%20%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E4%B8%AD%E9%97%B4%E2%BE%83%E9%80%82%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h2 id="实现两栏布局-右侧⾃适应-三栏布局中间⾃适应"><a href="#实现两栏布局-右侧⾃适应-三栏布局中间⾃适应" class="headerlink" title="实现两栏布局 右侧⾃适应 三栏布局中间⾃适应"></a>实现两栏布局 右侧⾃适应 三栏布局中间⾃适应</h2><h3 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h3><p>两栏布局实现效果就是将<strong>⻚⾯分割成左右宽度不等的两列，宽度较⼩的列设置为固定宽度，剩余宽度</strong></p><p><strong>由另⼀列撑满</strong>，</p><p>⽐如 Ant Design ⽂档，蓝⾊区域为主要内容布局容器，侧边栏为次要内容布局容器</p><p>这⾥称宽度较⼩的列⽗元素为次要布局容器，宽度较⼤的列⽗元素为主要布局容器</p><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251207200831390.png" alt="image-20251207200831325"></p><p><strong>flex弹性布局</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">&lt;div class=&quot;left&quot;&gt;左边&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;right&quot;&gt;右边&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><p>三栏布局按照左中右的顺序进⾏排列，通常中间列最宽，左右两列次之</p><p>⼤家最常⻅的就是 github</p><p><strong>. 使⽤flex实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.wrap &#123;</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line">.left,</span><br><span class="line">.right,</span><br><span class="line">.middle &#123;</span><br><span class="line">height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">width: 200px;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">background: coral;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">width: 120px;</span><br><span class="line">background: lightblue;</span><br><span class="line">&#125;</span><br><span class="line">.middle &#123;</span><br><span class="line">background: #555;</span><br><span class="line">width: 100%;</span><br><span class="line">margin: 0 20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">&lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;middle&quot;&gt;中间&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局和grid布局</title>
      <link href="/2025/08/07/css/flex%E5%B8%83%E5%B1%80%E5%92%8Cgrid%E5%B8%83%E5%B1%80/"/>
      <url>/2025/08/07/css/flex%E5%B8%83%E5%B1%80%E5%92%8Cgrid%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="flex布局和grid布局"><a href="#flex布局和grid布局" class="headerlink" title="flex布局和grid布局"></a>flex布局和grid布局</h2><h3 id="Flex-布局（弹性布局）"><a href="#Flex-布局（弹性布局）" class="headerlink" title="Flex 布局（弹性布局）"></a>Flex 布局（弹性布局）</h3><p>Flex 是<strong>一维布局模型</strong>（仅针对「行」或「列」单一维度），核心解决「行内 &#x2F; 列内元素的空间分配、对齐」问题，适合线性布局（如两栏 &#x2F; 多栏、导航栏、居中对齐等）。</p><ul><li><p>核心特点</p><p>：</p><ol><li>以「主轴（默认水平）+ 交叉轴」为核心，元素沿主轴排列；</li><li>侧重「剩余空间分配」（如 <code>flex:1</code> 自动占满剩余宽度）；</li><li>适配性强，适合响应式线性布局（如两栏、均分列表）。</li></ol></li><li><p><strong>典型场景</strong>：导航栏、两栏 &#x2F; 多栏自适应、元素垂直居中、流式布局。</p></li></ul><h3 id="Grid-布局（网格布局）"><a href="#Grid-布局（网格布局）" class="headerlink" title="Grid 布局（网格布局）"></a>Grid 布局（网格布局）</h3><p>Grid 是<strong>二维布局模型</strong>（同时控制「行 + 列」），核心解决「多行列的网格分区」问题，适合复杂的二维布局（如卡片网格、表单布局、页面整体框架）。</p><ul><li><p>核心特点</p><p>：</p><ol><li>把容器划分为「行 + 列」的网格，元素可占据任意单元格（跨行列）；</li><li>支持精确控制行列尺寸（固定 &#x2F; 比例 &#x2F; 自动），如 <code>grid-template-columns: 100px 1fr 2fr</code>；</li><li>布局更精准，适合复杂二维分区。</li></ol></li><li><p><strong>典型场景</strong>：页面整体框架（头部 &#x2F; 侧边 &#x2F; 主体 &#x2F; 底部）、商品卡片网格、表单多列布局。</p></li></ul><h3 id="核心区别"><a href="#核心区别" class="headerlink" title="核心区别"></a>核心区别</h3><table><thead><tr><th>维度</th><th>Flex 布局</th><th>Grid 布局</th></tr></thead><tbody><tr><td>布局维度</td><td>一维（行 &#x2F; 列二选一）</td><td>二维（行 + 列同时控制）</td></tr><tr><td>设计思路</td><td>「内容驱动」，适配内容</td><td>「容器驱动」，先划网格再填内容</td></tr><tr><td>适用场景</td><td>线性布局（如两栏、导航）</td><td>复杂二维布局（如网格、页面框架）</td></tr></tbody></table><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><ul><li>做「一行 &#x2F; 一列」的线性布局（如两栏自适应）→ 用 Flex，简洁高效；</li><li>做「多行多列」的网格布局（如 3 行 2 列卡片）→ 用 Grid，精准可控。</li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中隐藏⻚⾯元素</title>
      <link href="/2025/08/05/css/css%E4%B8%AD%E9%9A%90%E8%97%8F%E2%BB%9A%E2%BE%AF%E5%85%83%E7%B4%A0/"/>
      <url>/2025/08/05/css/css%E4%B8%AD%E9%9A%90%E8%97%8F%E2%BB%9A%E2%BE%AF%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="css中隐藏⻚⾯元素"><a href="#css中隐藏⻚⾯元素" class="headerlink" title="css中隐藏⻚⾯元素"></a>css中隐藏⻚⾯元素</h2><p>通过 css 实现隐藏元素⽅法有如下：</p><p>• </p><p>display:none</p><p>将元素设置为 display:none 后，元素在⻚⾯上将彻底消失</p><p>元素本⾝占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘</p><p>消失后，⾃⾝绑定的事件不会触发，也不会有过渡效果</p><p>特点：<strong>元素不可⻅</strong>，<strong>不占据空间</strong>，<strong>⽆法响应点击事件</strong></p><p>• </p><p>visibility:hidden</p><p>从⻚⾯上仅仅是隐藏该元素，<strong>DOM结果均会存在，只是当时在⼀个不可⻅的状态</strong>，<strong>不会触发重排</strong>，但</p><p>是会触发重绘</p><p>特点：元素不可⻅，<strong>占据⻚⾯空间</strong>，<strong>⽆法响应点击事件</strong></p><p>• </p><p>opacity:0</p><p>opacity 属性表⽰元素的透明度，将元素的透明度设置为0</p><p>• </p><p>设置height、width模型属性为0</p><p>将元素的 margin ， border ， padding ， height 和 width 等影响元素盒模型的属性设置成</p><p>0，<strong>如果元素内有⼦元素或内容，还应该设置其 overflow:hidden 来隐藏其⼦元素</strong></p><p>特点：元素不可⻅，<strong>不占据⻚⾯空间</strong>，<strong>⽆法响应点击事件</strong></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元素⽔平垂直居中的⽅法</title>
      <link href="/2025/08/05/css/%E5%85%83%E7%B4%A0%E2%BD%94%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
      <url>/2025/08/05/css/%E5%85%83%E7%B4%A0%E2%BD%94%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="元素⽔平垂直居中的⽅法"><a href="#元素⽔平垂直居中的⽅法" class="headerlink" title="元素⽔平垂直居中的⽅法"></a>元素⽔平垂直居中的⽅法</h2><p>实现元素⽔平垂直居中的⽅式：</p><p>• </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.father&#123;</span><br><span class="line">width:500px;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4 height:300px;</span><br><span class="line">5 border:1px solid #0a3b98;</span><br><span class="line">6 position: relative;</span><br><span class="line">7 &#125;</span><br><span class="line">8 .son&#123;</span><br><span class="line">9 width:100px;</span><br><span class="line">10 height:40px;</span><br><span class="line">11 background: #f0a238;</span><br><span class="line">12 position: absolute;</span><br><span class="line">13 top:0;</span><br><span class="line">14 left:0;</span><br><span class="line">15 right:0;</span><br><span class="line">16 bottom:0;</span><br><span class="line">17 margin:auto;</span><br><span class="line">18 &#125;</span><br><span class="line">19 &lt;/style&gt;</span><br><span class="line">20 &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">21 &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;</span><br><span class="line">22 &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>利⽤定位+margin:auto</p><p><strong>⽗级设置为相对定位，⼦级绝对定位</strong> ，并且<strong>四个定位属性top,left,right,bottom的值都设置了0</strong>，那么这时候如果⼦级没有设</p><p>置宽⾼，则会被拉开到和⽗级⼀样宽⾼</p><p>这⾥⼦元素设置了宽⾼，所以宽⾼会按照我们的设置来显⽰，但是实际上⼦级的虚拟占位已经撑满了</p><p>整个⽗级，这时候<strong>再给它⼀个 margin：auto</strong> 它就可以上下左右都居中了</p><p>• </p><p>table布局</p><p>设置<strong>⽗元素为 display:table-cell</strong> ，<strong>⼦元素设置 display: inline-block</strong> 。利⽤</p><p><strong>vertical 和 text-align</strong> 可以让所有的<strong>⾏内块级元素⽔平垂直居中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;style&gt;</span><br><span class="line">2 .father &#123;</span><br><span class="line">3 display: table-cell;</span><br><span class="line">4 width: 200px;</span><br><span class="line">5 height: 200px;</span><br><span class="line">6 background: skyblue;</span><br><span class="line">7 vertical-align: middle;</span><br><span class="line">8 text-align: center;</span><br><span class="line">9 &#125;</span><br><span class="line">10 .son &#123;</span><br><span class="line">11 display: inline-block;</span><br><span class="line">12 width: 100px;</span><br><span class="line">13 height: 100px;</span><br><span class="line">14 background: red;</span><br><span class="line">15 &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">&lt;div class=&quot;son&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>• </p><p>flex布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.father &#123;</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 200px;</span><br><span class="line">background: skyblue;</span><br><span class="line">&#125;</span><br><span class="line">.son &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">background: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">&lt;div class=&quot;son&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这⾥可以简单看看 flex 布局的关键属性作⽤：</p><p><strong>display: flex</strong>时，表⽰该容器内部的元素将按照flex进⾏布局</p><p><strong>align-items: center</strong>表⽰这些元素将相对于本容器⽔平居中</p><p><strong>justify-content: center</strong>也是同样的道理垂直居中</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盒⼦模型</title>
      <link href="/2025/08/02/css/%E7%9B%92%E2%BC%A6%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/08/02/css/%E7%9B%92%E2%BC%A6%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="盒⼦模型"><a href="#盒⼦模型" class="headerlink" title="盒⼦模型"></a>盒⼦模型</h2><p>当对⼀个⽂档进⾏布局（layout）的时候，浏览器的渲染引擎会根据标准之⼀的 CSS 基础框盒模型</p><p>（CSS basic box model），将所有元素表⽰为⼀个个矩形的盒⼦（box）</p><p>⼀个盒⼦由四个部分组成： content 、 padding 、 border 、 margin</p><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251207184335421.png" alt="image-20251207184335339"></p><p>从上图可以看到：</p><p>• </p><p>盒⼦总宽度 &#x3D; width + padding + border + margin;</p><p>• </p><p>盒⼦总⾼度 &#x3D; height + padding + border + margin</p><p>也就是， width&#x2F;height 只是内容⾼度，不包含 padding 和 border 值</p><p>所以上⾯问题中，设置 width 为200px，但由于存在 padding ，但实际上盒⼦的宽度有240px</p><p><strong>IE 怪异盒⼦模型</strong></p><p>• </p><p>盒⼦总宽度 &#x3D; width + margin;</p><p>• </p><p>盒⼦总⾼度 &#x3D; height + margin;</p><p>也就是， width&#x2F;height 包含了 padding 和 border 值</p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>在⻚⾯布局的时候，经常出现以下情况：</p><p>这个元素⾼度怎么没了？</p><p>这两栏布局怎么没法⾃适应？</p><p>这两个元素的间距怎么有点奇怪的样⼦？</p><p>原因是<strong>元素之间相互的影响</strong>，导致了意料之外的情况，这⾥就涉及到 BFC 概念</p><p><strong>BFC （Block Formatting Context）</strong>，即块级格式化上下⽂，它是⻚⾯中的⼀块渲染区域，并且有⼀</p><p>套属于⾃⼰的渲染规则：</p><p>• </p><p>内部的盒⼦会在<strong>垂直⽅向上⼀个接⼀个的放置</strong></p><p>• </p><p>对于同⼀个BFC的俩个相邻的盒⼦的<strong>margin会发⽣重叠</strong>，与⽅向⽆关。</p><p>• </p><p>每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此</p><p>• </p><p>BFC的区域不会与float的元素区域重叠</p><p>• </p><p>计算BFC的⾼度时，浮动⼦元素也参与计算</p><p>• </p><p>BFC就是<strong>⻚⾯上的⼀个隔离的独⽴容器</strong>，容器⾥⾯的⼦元素不会影响到外⾯的元素，反之亦然</p><p>BFC ⽬的是形成⼀个相对于外界完全独⽴的空间，让内部的⼦元素不会影响到外部的元素</p><p>利⽤ BFC 的特性，我们将 BFC 应⽤在以下场景：</p><p><strong>防⽌margin重叠（塌陷）</strong></p><p>可以在 p 外⾯包裹⼀层容器，并<strong>触发这个容器⽣成⼀个 BFC</strong> ，那么<strong>两个 p 就不属于同⼀个 BFC</strong> ，</p><p>则不会出现 margin 重叠</p><p><strong>清除内部浮动</strong></p><p><strong>⾃适应多栏布局</strong></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理（Dynamic Proxy）</title>
      <link href="/2025/07/10/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88Dynamic%20Proxy%EF%BC%89/"/>
      <url>/2025/07/10/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88Dynamic%20Proxy%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-动态代理（Dynamic-Proxy）"><a href="#Java-动态代理（Dynamic-Proxy）" class="headerlink" title="Java 动态代理（Dynamic Proxy）"></a>Java 动态代理（Dynamic Proxy）</h1><h2 id="一、什么是动态代理"><a href="#一、什么是动态代理" class="headerlink" title="一、什么是动态代理"></a>一、什么是动态代理</h2><p>Java 动态代理是一种在运行时创建代理类并处理方法调用的机制，它不需要事先写好代理类，而是通过反射 API 动态生成代理对象。</p><p>它常用于以下场景：</p><ul><li>日志记录</li><li>权限控制</li><li>性能监控</li><li>Spring AOP 实现原理</li></ul><hr><h2 id="二、JDK-动态代理原理"><a href="#二、JDK-动态代理原理" class="headerlink" title="二、JDK 动态代理原理"></a>二、JDK 动态代理原理</h2><p>JDK 动态代理主要依赖两个核心类&#x2F;接口：</p><ul><li><code>java.lang.reflect.Proxy</code></li><li><code>java.lang.reflect.InvocationHandler</code></li></ul><p>JDK 动态代理要求被代理的类 <strong>必须实现接口</strong>。</p><hr><h2 id="三、使用步骤"><a href="#三、使用步骤" class="headerlink" title="三、使用步骤"></a>三、使用步骤</h2><h3 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1. 定义接口"></a>1. 定义接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑public interface UserService &#123;</span><br><span class="line">    void login(String username);</span><br><span class="line">    void logout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-实现该接口的类（目标类）"><a href="#2-实现该接口的类（目标类）" class="headerlink" title="2. 实现该接口的类（目标类）"></a>2. 实现该接口的类（目标类）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void login(String username) &#123;</span><br><span class="line">        System.out.println(username + &quot; 登录了系统&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void logout() &#123;</span><br><span class="line">        System.out.println(&quot;用户退出系统&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-实现-InvocationHandler-接口"><a href="#3-实现-InvocationHandler-接口" class="headerlink" title="3. 实现 InvocationHandler 接口"></a>3. 实现 InvocationHandler 接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class LogHandler implements InvocationHandler &#123;</span><br><span class="line">    private final Object target;</span><br><span class="line"></span><br><span class="line">    public LogHandler(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;[日志] 调用方法：&quot; + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args); // 反射调用目标方法</span><br><span class="line">        System.out.println(&quot;[日志] 方法调用结束：&quot; + method.getName());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-生成代理对象并调用方法"><a href="#4-生成代理对象并调用方法" class="headerlink" title="4. 生成代理对象并调用方法"></a>4. 生成代理对象并调用方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService target = new UserServiceImpl();</span><br><span class="line">        InvocationHandler handler = new LogHandler(target);</span><br><span class="line"></span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(), // 必须是接口类型</span><br><span class="line">            handler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        proxy.login(&quot;张三&quot;);</span><br><span class="line">        proxy.logout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、运行结果"><a href="#四、运行结果" class="headerlink" title="四、运行结果"></a>四、运行结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">css复制编辑[日志] 调用方法：login</span><br><span class="line">张三 登录了系统</span><br><span class="line">[日志] 方法调用结束：login</span><br><span class="line">[日志] 调用方法：logout</span><br><span class="line">用户退出系统</span><br><span class="line">[日志] 方法调用结束：logout</span><br></pre></td></tr></table></figure><hr><h2 id="五、JDK-动态代理的限制"><a href="#五、JDK-动态代理的限制" class="headerlink" title="五、JDK 动态代理的限制"></a>五、JDK 动态代理的限制</h2><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>灵活，无需编写代理类</td><td>只能代理接口，不能代理类</td></tr><tr><td>支持运行时增强行为</td><td>运行时使用反射，性能略下降</td></tr><tr><td>应用于 AOP、RPC、事务等场景</td><td></td></tr></tbody></table><hr><h2 id="六、CGLIB-动态代理（补充）"><a href="#六、CGLIB-动态代理（补充）" class="headerlink" title="六、CGLIB 动态代理（补充）"></a>六、CGLIB 动态代理（补充）</h2><p>如果目标类没有接口，可以使用 CGLIB，它基于继承生成代理类。Spring 在默认配置下也使用它来代理非接口类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑Enhancer enhancer = new Enhancer();</span><br><span class="line">enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;[CGLIB日志] 调用方法：&quot; + method.getName());</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(&quot;[CGLIB日志] 方法调用结束：&quot; + method.getName());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">UserServiceImpl proxy = (UserServiceImpl) enhancer.create();</span><br><span class="line">proxy.login(&quot;李四&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>CGLIB 需要额外依赖库（如 <code>cglib-nodep</code>）</p></blockquote><hr><h2 id="七、动态代理的应用场景总结"><a href="#七、动态代理的应用场景总结" class="headerlink" title="七、动态代理的应用场景总结"></a>七、动态代理的应用场景总结</h2><ul><li>AOP（面向切面编程）</li><li>日志拦截器</li><li>安全控制</li><li>缓存管理</li><li>RPC 调用封装</li><li>数据库事务处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射机制（Reflection）</title>
      <link href="/2025/07/09/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%88Reflection%EF%BC%89/"/>
      <url>/2025/07/09/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%88Reflection%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-反射机制（Reflection）"><a href="#Java-反射机制（Reflection）" class="headerlink" title="Java 反射机制（Reflection）"></a>Java 反射机制（Reflection）</h1><h2 id="一、什么是反射"><a href="#一、什么是反射" class="headerlink" title="一、什么是反射"></a>一、什么是反射</h2><p><strong>反射（Reflection）</strong> 是 Java 提供的一种机制，它允许程序在运行时动态获取类的信息（方法、属性、构造方法等）以及操作对象本身。</p><p>通过反射可以：</p><ul><li>在运行时获取类的完整结构</li><li>动态创建对象</li><li>动态调用方法、访问字段</li><li>实现解耦、插件式开发、框架封装等</li></ul><p>反射是实现诸如 <strong>Spring、MyBatis、Junit、Tomcat、IDEA 插件系统</strong> 的核心技术之一。</p><hr><h2 id="二、反射的核心类"><a href="#二、反射的核心类" class="headerlink" title="二、反射的核心类"></a>二、反射的核心类</h2><p>反射主要在 <code>java.lang.reflect</code> 和 <code>java.lang.Class</code> 包中，主要类包括：</p><table><thead><tr><th>类&#x2F;接口</th><th>功能说明</th></tr></thead><tbody><tr><td><code>Class&lt;?&gt;</code></td><td>表示类或接口的字节码对象</td></tr><tr><td><code>Field</code></td><td>表示类中的成员变量</td></tr><tr><td><code>Method</code></td><td>表示类中的方法</td></tr><tr><td><code>Constructor</code></td><td>表示类的构造方法</td></tr><tr><td><code>Modifier</code></td><td>表示修饰符工具类</td></tr></tbody></table><hr><h2 id="三、反射的基本操作"><a href="#三、反射的基本操作" class="headerlink" title="三、反射的基本操作"></a>三、反射的基本操作</h2><h3 id="1-获取类的-Class-对象（3种方式）"><a href="#1-获取类的-Class-对象（3种方式）" class="headerlink" title="1. 获取类的 Class 对象（3种方式）"></a>1. 获取类的 Class 对象（3种方式）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑// 方式一：通过类名.class</span><br><span class="line">Class&lt;?&gt; clazz1 = String.class;</span><br><span class="line"></span><br><span class="line">// 方式二：通过对象的 getClass()</span><br><span class="line">String s = &quot;hello&quot;;</span><br><span class="line">Class&lt;?&gt; clazz2 = s.getClass();</span><br><span class="line"></span><br><span class="line">// 方式三：通过 Class.forName()</span><br><span class="line">Class&lt;?&gt; clazz3 = Class.forName(&quot;java.lang.String&quot;);</span><br></pre></td></tr></table></figure><h3 id="2-创建对象"><a href="#2-创建对象" class="headerlink" title="2. 创建对象"></a>2. 创建对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line"></span><br><span class="line">// 调用无参构造方法</span><br><span class="line">Object obj = clazz.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure><h3 id="3-获取并调用构造方法"><a href="#3-获取并调用构造方法" class="headerlink" title="3. 获取并调用构造方法"></a>3. 获取并调用构造方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class);</span><br><span class="line">Object strObj = constructor.newInstance(&quot;Hello&quot;);</span><br><span class="line">System.out.println(strObj); // 输出 Hello</span><br></pre></td></tr></table></figure><h3 id="4-获取方法并调用"><a href="#4-获取方法并调用" class="headerlink" title="4. 获取方法并调用"></a>4. 获取方法并调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑Method method = clazz.getMethod(&quot;length&quot;);</span><br><span class="line">int length = (int) method.invoke(&quot;Reflection&quot;);</span><br><span class="line">System.out.println(length); // 输出 10</span><br></pre></td></tr></table></figure><h3 id="5-获取成员变量并访问"><a href="#5-获取成员变量并访问" class="headerlink" title="5. 获取成员变量并访问"></a>5. 获取成员变量并访问</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑public class Person &#123;</span><br><span class="line">    private String name = &quot;张三&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; clazz = Person.class;</span><br><span class="line">Object person = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">Field field = clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">field.setAccessible(true); // 打破 private 限制</span><br><span class="line">Object value = field.get(person);</span><br><span class="line">System.out.println(value); // 输出 张三</span><br></pre></td></tr></table></figure><hr><h2 id="四、完整示例"><a href="#四、完整示例" class="headerlink" title="四、完整示例"></a>四、完整示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">        this.name = &quot;默认姓名&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(String msg) &#123;</span><br><span class="line">        System.out.println(name + &quot; 说：&quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">java复制编辑public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(&quot;Person&quot;);</span><br><span class="line"></span><br><span class="line">        Object obj = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        Field nameField = clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        nameField.setAccessible(true);</span><br><span class="line">        nameField.set(obj, &quot;李四&quot;);</span><br><span class="line"></span><br><span class="line">        Method method = clazz.getMethod(&quot;sayHello&quot;, String.class);</span><br><span class="line">        method.invoke(obj, &quot;你好，反射&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制编辑</span><br><span class="line">李四 说：你好，反射</span><br></pre></td></tr></table></figure><hr><h2 id="五、反射的优缺点"><a href="#五、反射的优缺点" class="headerlink" title="五、反射的优缺点"></a>五、反射的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>灵活：允许在运行时操作对象</li><li>解耦：可用于工厂模式、框架自动装配</li><li>强大：能访问私有成员、动态调用</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>性能较低：反射调用本质是方法分发 + 安全检查</li><li>安全性弱：能访问和修改 private 属性可能导致安全问题</li><li>可读性差：代码不直观，难以调试</li></ul><hr><h2 id="六、反射在实际开发中的应用"><a href="#六、反射在实际开发中的应用" class="headerlink" title="六、反射在实际开发中的应用"></a>六、反射在实际开发中的应用</h2><table><thead><tr><th>应用场景</th><th>示例</th></tr></thead><tbody><tr><td>框架自动注入</td><td>Spring IOC、DI</td></tr><tr><td>AOP 方法增强</td><td>Spring AOP</td></tr><tr><td>JDBC 封装</td><td>MyBatis 动态 SQL 映射</td></tr><tr><td>配置文件驱动类加载</td><td>SPI 插件机制</td></tr><tr><td>单元测试调用私有方法</td><td>JUnit、Mockito</td></tr><tr><td>序列化&#x2F;反序列化</td><td>Jackson、FastJSON</td></tr></tbody></table><hr><h2 id="七、Class-对象详解"><a href="#七、Class-对象详解" class="headerlink" title="七、Class 对象详解"></a>七、Class 对象详解</h2><p>每个 <code>.class</code> 文件在 JVM 中会被加载为唯一的 <code>Class</code> 实例对象，常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"></span><br><span class="line">System.out.println(clazz.getName());         // 全类名</span><br><span class="line">System.out.println(clazz.getSimpleName());   // 简类名</span><br><span class="line">System.out.println(clazz.getPackage());      // 包信息</span><br><span class="line">System.out.println(clazz.getSuperclass());   // 父类</span><br><span class="line">System.out.println(clazz.getInterfaces());   // 接口</span><br></pre></td></tr></table></figure><hr><h2 id="八、注意事项"><a href="#八、注意事项" class="headerlink" title="八、注意事项"></a>八、注意事项</h2><ul><li>反射可访问私有成员，但必须显式设置 <code>setAccessible(true)</code></li><li>建议避免在性能敏感场景频繁使用反射</li><li><code>Class.forName()</code> 会触发类的初始化（执行静态代码块）</li><li>Java 9+ 中对反射访问做了封装限制（需打开模块）</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 线程池（Thread Pool）</title>
      <link href="/2025/07/08/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88Thread%20Pool%EF%BC%89/"/>
      <url>/2025/07/08/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88Thread%20Pool%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-线程池（Thread-Pool）"><a href="#Java-线程池（Thread-Pool）" class="headerlink" title="Java 线程池（Thread Pool）"></a>Java 线程池（Thread Pool）</h1><h2 id="一、什么是线程池"><a href="#一、什么是线程池" class="headerlink" title="一、什么是线程池"></a>一、什么是线程池</h2><p><strong>线程池</strong> 是一种线程管理机制，用于提前创建并复用固定数量的线程，以避免频繁地创建&#x2F;销毁线程带来的资源开销。</p><p>主要优势包括：</p><ul><li>降低资源消耗（复用线程）</li><li>提高响应速度（任务提交后可立即执行）</li><li>方便管理线程（线程数可控，支持超时、拒绝策略等）</li></ul><hr><h2 id="二、线程池的核心类：Executor-和-ThreadPoolExecutor"><a href="#二、线程池的核心类：Executor-和-ThreadPoolExecutor" class="headerlink" title="二、线程池的核心类：Executor 和 ThreadPoolExecutor"></a>二、线程池的核心类：<code>Executor</code> 和 <code>ThreadPoolExecutor</code></h2><p>Java 中的线程池定义在 <code>java.util.concurrent</code> 包下，主要接口和类包括：</p><table><thead><tr><th>接口&#x2F;类名</th><th>说明</th></tr></thead><tbody><tr><td><code>Executor</code></td><td>线程池顶层接口，定义任务执行方法</td></tr><tr><td><code>ExecutorService</code></td><td>扩展接口，支持任务返回值、关闭池</td></tr><tr><td><code>ThreadPoolExecutor</code></td><td>线程池的核心实现类</td></tr><tr><td><code>Executors</code></td><td>工厂类，用于创建常见线程池</td></tr><tr><td><code>Future</code></td><td>代表异步任务结果</td></tr></tbody></table><hr><h2 id="三、使用线程池的三种方式"><a href="#三、使用线程池的三种方式" class="headerlink" title="三、使用线程池的三种方式"></a>三、使用线程池的三种方式</h2><h3 id="1-使用-Executors-工厂类（不推荐用于生产）"><a href="#1-使用-Executors-工厂类（不推荐用于生产）" class="headerlink" title="1. 使用 Executors 工厂类（不推荐用于生产）"></a>1. 使用 <code>Executors</code> 工厂类（不推荐用于生产）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑ExecutorService pool = Executors.newFixedThreadPool(5);</span><br><span class="line"></span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; 执行任务&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure><p><code>Executors</code> 提供的几种线程池：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>newFixedThreadPool(n)</code></td><td>固定大小线程池</td></tr><tr><td><code>newCachedThreadPool()</code></td><td>可自动扩容线程池（适合短任务）</td></tr><tr><td><code>newSingleThreadExecutor()</code></td><td>单线程池</td></tr><tr><td><code>newScheduledThreadPool(n)</code></td><td>定时&#x2F;周期性任务线程池</td></tr></tbody></table><blockquote><p>说明：<code>Executors</code> 默认使用 <strong>无界队列</strong>（如 LinkedBlockingQueue），在任务过多时容易导致内存溢出。<strong>推荐手动使用 ThreadPoolExecutor</strong>。</p></blockquote><hr><h3 id="2-手动创建-ThreadPoolExecutor（推荐）"><a href="#2-手动创建-ThreadPoolExecutor（推荐）" class="headerlink" title="2. 手动创建 ThreadPoolExecutor（推荐）"></a>2. 手动创建 <code>ThreadPoolExecutor</code>（推荐）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑ExecutorService pool = new ThreadPoolExecutor(</span><br><span class="line">    2,                      // corePoolSize 核心线程数</span><br><span class="line">    5,                      // maximumPoolSize 最大线程数</span><br><span class="line">    60L,                    // keepAliveTime 空闲线程最大存活时间</span><br><span class="line">    TimeUnit.SECONDS,       // 时间单位</span><br><span class="line">    new ArrayBlockingQueue&lt;&gt;(10), // 等待队列（有界）</span><br><span class="line">    Executors.defaultThreadFactory(), // 线程工厂</span><br><span class="line">    new ThreadPoolExecutor.AbortPolicy() // 拒绝策略</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h2 id="四、线程池任务执行流程"><a href="#四、线程池任务执行流程" class="headerlink" title="四、线程池任务执行流程"></a>四、线程池任务执行流程</h2><ol><li>任务提交给线程池</li><li>如果线程数 &lt; corePoolSize，创建新线程执行任务</li><li>如果线程数 ≥ corePoolSize，任务放入队列等待</li><li>如果队列已满且线程数 &lt; maximumPoolSize，创建新线程执行任务</li><li>如果队列已满且线程数达到最大，触发<strong>拒绝策略</strong></li></ol><hr><h2 id="五、拒绝策略（RejectedExecutionHandler）"><a href="#五、拒绝策略（RejectedExecutionHandler）" class="headerlink" title="五、拒绝策略（RejectedExecutionHandler）"></a>五、拒绝策略（RejectedExecutionHandler）</h2><p>当线程池和队列都满了时，线程池会调用 <strong>拒绝策略</strong>：</p><table><thead><tr><th>策略类</th><th>描述</th></tr></thead><tbody><tr><td><code>AbortPolicy</code>（默认）</td><td>抛出 <code>RejectedExecutionException</code></td></tr><tr><td><code>CallerRunsPolicy</code></td><td>由提交任务的线程（主线程）执行该任务</td></tr><tr><td><code>DiscardPolicy</code></td><td>直接丢弃任务</td></tr><tr><td><code>DiscardOldestPolicy</code></td><td>丢弃队列中最早的任务，尝试执行当前任务</td></tr></tbody></table><hr><h2 id="六、线程池常用方法"><a href="#六、线程池常用方法" class="headerlink" title="六、线程池常用方法"></a>六、线程池常用方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑Future&lt;String&gt; future = pool.submit(() -&gt; &#123;</span><br><span class="line">    return &quot;任务执行结果&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(future.get()); // 获取返回值（阻塞）</span><br><span class="line">java复制编辑pool.shutdown();           // 平滑关闭线程池</span><br><span class="line">pool.shutdownNow();        // 立即关闭线程池（中断正在执行的线程）</span><br></pre></td></tr></table></figure><hr><h2 id="七、线程池参数调优建议"><a href="#七、线程池参数调优建议" class="headerlink" title="七、线程池参数调优建议"></a>七、线程池参数调优建议</h2><table><thead><tr><th>参数</th><th>调优建议</th></tr></thead><tbody><tr><td>corePoolSize</td><td>根据 CPU 核数和任务类型（I&#x2F;O密集 or 计算密集）</td></tr><tr><td>maximumPoolSize</td><td>通常是 core 数的 1.5 ~ 2 倍</td></tr><tr><td>队列类型</td><td>推荐使用有界队列（如 ArrayBlockingQueue）</td></tr><tr><td>拒绝策略</td><td>根据业务场景选择（如降级、记录日志）</td></tr><tr><td>keepAliveTime</td><td>非核心线程空闲存活时间</td></tr></tbody></table><hr><h2 id="八、实际开发中的应用场景"><a href="#八、实际开发中的应用场景" class="headerlink" title="八、实际开发中的应用场景"></a>八、实际开发中的应用场景</h2><ul><li>Web 服务器处理请求（如 Tomcat 使用线程池处理 Servlet 请求）</li><li>数据库连接池底层使用线程池管理连接</li><li>消息处理系统（异步处理消息队列中的任务）</li><li>定时任务调度（使用 <code>ScheduledExecutorService</code>）</li></ul><hr><h2 id="九、示例：批量执行任务并收集返回值"><a href="#九、示例：批量执行任务并收集返回值" class="headerlink" title="九、示例：批量执行任务并收集返回值"></a>九、示例：批量执行任务并收集返回值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑ExecutorService pool = Executors.newFixedThreadPool(3);</span><br><span class="line"></span><br><span class="line">List&lt;Future&lt;Integer&gt;&gt; futures = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    int num = i;</span><br><span class="line">    futures.add(pool.submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        return num * num;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (Future&lt;Integer&gt; f : futures) &#123;</span><br><span class="line">    System.out.println(&quot;结果：&quot; + f.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure><hr><h2 id="十、补充：线程池监控与可视化"><a href="#十、补充：线程池监控与可视化" class="headerlink" title="十、补充：线程池监控与可视化"></a>十、补充：线程池监控与可视化</h2><p>可以通过以下方式监控线程池运行状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑ThreadPoolExecutor pool = (ThreadPoolExecutor) Executors.newFixedThreadPool(3);</span><br><span class="line"></span><br><span class="line">System.out.println(pool.getPoolSize());         // 当前线程池大小</span><br><span class="line">System.out.println(pool.getActiveCount());      // 活跃线程数</span><br><span class="line">System.out.println(pool.getQueue().size());     // 队列长度</span><br><span class="line">System.out.println(pool.getCompletedTaskCount());// 完成任务数</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O流与I/O框架</title>
      <link href="/2025/07/07/IO%E6%B5%81%E4%B8%8EIO%E6%A1%86%E6%9E%B6/"/>
      <url>/2025/07/07/IO%E6%B5%81%E4%B8%8EIO%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="I-O流与I-O框架全面总结"><a href="#I-O流与I-O框架全面总结" class="headerlink" title="I&#x2F;O流与I&#x2F;O框架全面总结"></a>I&#x2F;O流与I&#x2F;O框架全面总结</h1><h2 id="一、Java-I-O流基础"><a href="#一、Java-I-O流基础" class="headerlink" title="一、Java I&#x2F;O流基础"></a>一、Java I&#x2F;O流基础</h2><h3 id="1-I-O流分类"><a href="#1-I-O流分类" class="headerlink" title="1. I&#x2F;O流分类"></a>1. I&#x2F;O流分类</h3><h4 id="按数据流向"><a href="#按数据流向" class="headerlink" title="按数据流向"></a>按数据流向</h4><ul><li><strong>输入流</strong>：从数据源读取数据（InputStream&#x2F;Reader）</li><li><strong>输出流</strong>：向目标写入数据（OutputStream&#x2F;Writer）</li></ul><h4 id="按数据类型"><a href="#按数据类型" class="headerlink" title="按数据类型"></a>按数据类型</h4><ul><li><strong>字节流</strong>：以字节为单位（8位），处理二进制数据<ul><li>InputStream&#x2F;OutputStream</li></ul></li><li><strong>字符流</strong>：以字符为单位（16位），处理文本数据<ul><li>Reader&#x2F;Writer</li></ul></li></ul><h4 id="按功能"><a href="#按功能" class="headerlink" title="按功能"></a>按功能</h4><ul><li><strong>节点流</strong>：直接操作数据源&#x2F;目标的流</li><li><strong>处理流</strong>：对现有流进行包装，提供增强功能</li></ul><h3 id="2-核心类体系"><a href="#2-核心类体系" class="headerlink" title="2. 核心类体系"></a>2. 核心类体系</h3><h4 id="字节流体系"><a href="#字节流体系" class="headerlink" title="字节流体系"></a>字节流体系</h4><p>text</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">InputStream (抽象类)</span><br><span class="line">├─ FileInputStream (文件输入)</span><br><span class="line">├─ ByteArrayInputStream (内存数组输入)</span><br><span class="line">├─ FilterInputStream (装饰器父类)</span><br><span class="line">│  ├─ BufferedInputStream (缓冲流)</span><br><span class="line">│  ├─ DataInputStream (基本数据类型读取)</span><br><span class="line">└─ ObjectInputStream (对象反序列化)</span><br><span class="line"></span><br><span class="line">OutputStream (抽象类)</span><br><span class="line">├─ FileOutputStream (文件输出)</span><br><span class="line">├─ ByteArrayOutputStream (内存数组输出)</span><br><span class="line">├─ FilterOutputStream (装饰器父类)</span><br><span class="line">│  ├─ BufferedOutputStream (缓冲流)</span><br><span class="line">│  ├─ DataOutputStream (基本数据类型写入)</span><br><span class="line">└─ ObjectOutputStream (对象序列化)</span><br></pre></td></tr></table></figure><h4 id="字符流体系"><a href="#字符流体系" class="headerlink" title="字符流体系"></a>字符流体系</h4><p>text</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Reader (抽象类)</span><br><span class="line">├─ InputStreamReader (字节到字符桥接)</span><br><span class="line">│  └─ FileReader (文件字符输入)</span><br><span class="line">├─ BufferedReader (缓冲字符输入)</span><br><span class="line">├─ CharArrayReader (字符数组输入)</span><br><span class="line">└─ StringReader (字符串输入)</span><br><span class="line"></span><br><span class="line">Writer (抽象类)</span><br><span class="line">├─ OutputStreamWriter (字符到字节桥接)</span><br><span class="line">│  └─ FileWriter (文件字符输出)</span><br><span class="line">├─ BufferedWriter (缓冲字符输出)</span><br><span class="line">├─ CharArrayWriter (字符数组输出)</span><br><span class="line">└─ StringWriter (字符串输出)</span><br></pre></td></tr></table></figure><h2 id="二、常用I-O流详解"><a href="#二、常用I-O流详解" class="headerlink" title="二、常用I&#x2F;O流详解"></a>二、常用I&#x2F;O流详解</h2><h3 id="1-文件操作流"><a href="#1-文件操作流" class="headerlink" title="1. 文件操作流"></a>1. 文件操作流</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 字节流文件复制</span><br><span class="line">try (FileInputStream fis = new FileInputStream(&quot;source.txt&quot;);</span><br><span class="line">     FileOutputStream fos = new FileOutputStream(&quot;target.txt&quot;)) &#123;</span><br><span class="line">    byte[] buffer = new byte[1024];</span><br><span class="line">    int len;</span><br><span class="line">    while ((len = fis.read(buffer)) != -1) &#123;</span><br><span class="line">        fos.write(buffer, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 字符流文件读取</span><br><span class="line">try (BufferedReader br = new BufferedReader(new FileReader(&quot;file.txt&quot;))) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    while ((line = br.readLine()) != null) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-缓冲流（提升性能）"><a href="#2-缓冲流（提升性能）" class="headerlink" title="2. 缓冲流（提升性能）"></a>2. 缓冲流（提升性能）</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用缓冲流提升复制效率</span><br><span class="line">try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;source.jpg&quot;));</span><br><span class="line">     BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;target.jpg&quot;))) &#123;</span><br><span class="line">    byte[] buffer = new byte[8192];  // 8KB缓冲区</span><br><span class="line">    int len;</span><br><span class="line">    while ((len = bis.read(buffer)) != -1) &#123;</span><br><span class="line">        bos.write(buffer, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-对象序列化流"><a href="#3-对象序列化流" class="headerlink" title="3. 对象序列化流"></a>3. 对象序列化流</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 对象序列化</span><br><span class="line">class Person implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private transient int age;  // transient修饰的字段不会被序列化</span><br><span class="line">    </span><br><span class="line">    // 构造方法、getter/setter...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 序列化对象到文件</span><br><span class="line">try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.dat&quot;))) &#123;</span><br><span class="line">    oos.writeObject(new Person(&quot;张三&quot;, 25));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 反序列化</span><br><span class="line">try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;person.dat&quot;))) &#123;</span><br><span class="line">    Person p = (Person) ois.readObject();</span><br><span class="line">    System.out.println(p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、NIO（New-I-O）"><a href="#三、NIO（New-I-O）" class="headerlink" title="三、NIO（New I&#x2F;O）"></a>三、NIO（New I&#x2F;O）</h2><h3 id="1-NIO核心组件"><a href="#1-NIO核心组件" class="headerlink" title="1. NIO核心组件"></a>1. NIO核心组件</h3><ul><li><strong>Channel</strong>：双向数据传输通道<ul><li>FileChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul></li><li><strong>Buffer</strong>：数据容器<ul><li>ByteBuffer</li><li>CharBuffer</li><li>IntBuffer</li></ul></li><li><strong>Selector</strong>：多路复用器</li></ul><h3 id="2-NIO示例"><a href="#2-NIO示例" class="headerlink" title="2. NIO示例"></a>2. NIO示例</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 使用FileChannel复制文件</span><br><span class="line">try (FileChannel src = FileChannel.open(Paths.get(&quot;source.txt&quot;), StandardOpenOption.READ);</span><br><span class="line">     FileChannel dest = FileChannel.open(Paths.get(&quot;target.txt&quot;), </span><br><span class="line">          StandardOpenOption.WRITE, StandardOpenOption.CREATE)) &#123;</span><br><span class="line">    src.transferTo(0, src.size(), dest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用Buffer读写</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">try (FileChannel channel = FileChannel.open(Paths.get(&quot;data.txt&quot;), StandardOpenOption.READ)) &#123;</span><br><span class="line">    while (channel.read(buffer) &gt; 0) &#123;</span><br><span class="line">        buffer.flip();  // 切换为读模式</span><br><span class="line">        while (buffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.print((char) buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.clear();  // 清空缓冲区，准备再次写入</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、常用I-O框架"><a href="#四、常用I-O框架" class="headerlink" title="四、常用I&#x2F;O框架"></a>四、常用I&#x2F;O框架</h2><h3 id="1-Apache-Commons-IO"><a href="#1-Apache-Commons-IO" class="headerlink" title="1. Apache Commons IO"></a>1. Apache Commons IO</h3><p><strong>核心功能</strong>：</p><ul><li>FileUtils：文件操作工具类</li><li>IOUtils：流操作工具类</li><li>FilenameUtils：文件名处理工具</li></ul><p><strong>示例代码</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 复制文件</span><br><span class="line">File srcFile = new File(&quot;source.txt&quot;);</span><br><span class="line">File destFile = new File(&quot;target.txt&quot;);</span><br><span class="line">FileUtils.copyFile(srcFile, destFile);</span><br><span class="line"></span><br><span class="line">// 读取文件内容为字符串</span><br><span class="line">String content = FileUtils.readFileToString(new File(&quot;data.txt&quot;), &quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">// 逐行读取</span><br><span class="line">List&lt;String&gt; lines = FileUtils.readLines(new File(&quot;log.txt&quot;), &quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure><h3 id="2-Google-Guava"><a href="#2-Google-Guava" class="headerlink" title="2. Google Guava"></a>2. Google Guava</h3><p><strong>核心功能</strong>：</p><ul><li>Files：文件操作工具</li><li>CharStreams&#x2F;ByteStreams：流工具</li><li>Resources：资源读取工具</li></ul><p><strong>示例代码</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 读取文件所有行</span><br><span class="line">List&lt;String&gt; lines = Files.readLines(new File(&quot;data.txt&quot;), Charsets.UTF_8);</span><br><span class="line"></span><br><span class="line">// 复制文件</span><br><span class="line">File src = new File(&quot;source.jpg&quot;);</span><br><span class="line">File dest = new File(&quot;target.jpg&quot;);</span><br><span class="line">Files.copy(src, dest);</span><br><span class="line"></span><br><span class="line">// 读取资源文件</span><br><span class="line">URL url = Resources.getResource(&quot;config.properties&quot;);</span><br><span class="line">String text = Resources.toString(url, Charsets.UTF_8);</span><br></pre></td></tr></table></figure><h3 id="3-Java-7-Files工具类"><a href="#3-Java-7-Files工具类" class="headerlink" title="3. Java 7+ Files工具类"></a>3. Java 7+ Files工具类</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 读取所有行</span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(Paths.get(&quot;data.txt&quot;));</span><br><span class="line"></span><br><span class="line">// 写入文件</span><br><span class="line">Files.write(Paths.get(&quot;output.txt&quot;), &quot;Hello World&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">// 复制文件</span><br><span class="line">Files.copy(Paths.get(&quot;source.txt&quot;), Paths.get(&quot;target.txt&quot;));</span><br><span class="line"></span><br><span class="line">// 遍历目录</span><br><span class="line">Files.walk(Paths.get(&quot;/path/to/dir&quot;))</span><br><span class="line">     .filter(Files::isRegularFile)</span><br><span class="line">     .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="五、性能优化建议"><a href="#五、性能优化建议" class="headerlink" title="五、性能优化建议"></a>五、性能优化建议</h2><ol><li><strong>使用缓冲流</strong>：减少物理I&#x2F;O操作次数</li><li><strong>合理设置缓冲区大小</strong>：通常8KB-32KB为宜</li><li><strong>及时关闭资源</strong>：使用try-with-resources</li><li><strong>NIO处理大文件</strong>：对于大文件操作，NIO性能更优</li><li><strong>选择合适流类型</strong>：文本数据用字符流，二进制数据用字节流</li><li><strong>批量操作</strong>：尽量批量读写而非单字节&#x2F;字符操作</li></ol><h2 id="六、常见应用场景"><a href="#六、常见应用场景" class="headerlink" title="六、常见应用场景"></a>六、常见应用场景</h2><ol><li><strong>文件操作</strong>：读写、复制、移动、删除</li><li><strong>网络通信</strong>：Socket数据传输</li><li><strong>数据持久化</strong>：对象序列化&#x2F;反序列化</li><li><strong>日志处理</strong>：日志文件读写</li><li><strong>配置文件</strong>：properties&#x2F;xml&#x2F;json等配置读取</li><li><strong>资源加载</strong>：类路径资源读取</li></ol><p>掌握这些I&#x2F;O流和框架的知识点，可以显著提升程序性能和开发效率</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常和泛型</title>
      <link href="/2025/07/06/%E5%BC%82%E5%B8%B8%E5%92%8C%E6%B3%9B%E5%9E%8B/"/>
      <url>/2025/07/06/%E5%BC%82%E5%B8%B8%E5%92%8C%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="异常和泛型知识点总结"><a href="#异常和泛型知识点总结" class="headerlink" title="异常和泛型知识点总结"></a>异常和泛型知识点总结</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h3><ul><li>异常是程序运行时发生的不正常情况，会中断正常的指令流</li><li>Java中所有异常都继承自<code>Throwable</code>类，分为<code>Error</code>和<code>Exception</code>两大类</li></ul><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><ol><li><strong>Error</strong>：严重错误，程序无法处理（如内存溢出）</li><li><strong>Exception</strong>：<ul><li>检查异常（Checked Exception）：必须处理（如IOException）</li><li>非检查异常（Unchecked Exception&#x2F;RuntimeException）：可选择性处理（如NullPointerException）</li></ul></li></ol><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><ol><li><p><strong>try-catch-finally</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 可能抛出异常的代码</span><br><span class="line">&#125; catch (ExceptionType1 e) &#123;</span><br><span class="line">    // 处理特定异常</span><br><span class="line">&#125; catch (ExceptionType2 e) &#123;</span><br><span class="line">    // 处理另一种异常</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 无论是否发生异常都会执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>throws</strong>：声明方法可能抛出的异常</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void method() throws IOException &#123;</span><br><span class="line">    // 方法代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>throw</strong>：主动抛出异常</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new Exception(&quot;错误信息&quot;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul><li>继承Exception或RuntimeException创建自定义异常类</li><li>通常提供构造方法传递错误信息</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型概念"><a href="#泛型概念" class="headerlink" title="泛型概念"></a>泛型概念</h3><ul><li>参数化类型，将类型作为参数</li><li>提高代码复用性和类型安全性</li></ul><h3 id="泛型使用"><a href="#泛型使用" class="headerlink" title="泛型使用"></a>泛型使用</h3><ol><li><p><strong>泛型类</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">    private T t;</span><br><span class="line">    public void set(T t) &#123; this.t = t; &#125;</span><br><span class="line">    public T get() &#123; return t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>泛型方法</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; void printArray(T[] array) &#123;</span><br><span class="line">    for (T element : array) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>泛型接口</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><ol><li><strong>无界通配符</strong>：<code>&lt;?&gt;</code> 表示未知类型</li><li><strong>上界通配符</strong>：<code>&lt;? extends T&gt;</code> 表示T或T的子类</li><li><strong>下界通配符</strong>：<code>&lt;? super T&gt;</code> 表示T或T的父类</li></ol><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><ul><li>Java泛型在编译时进行类型检查，运行时擦除类型信息</li><li>编译器在必要时插入类型转换代码</li></ul><h3 id="泛型限制"><a href="#泛型限制" class="headerlink" title="泛型限制"></a>泛型限制</h3><ul><li>不能使用基本类型作为类型参数</li><li>不能创建泛型数组</li><li>不能实例化类型参数</li><li>不能使用instanceof检查泛型类型</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名内部类与Lambda表达式</title>
      <link href="/2025/07/05/Stream%E6%B5%81/"/>
      <url>/2025/07/05/Stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Stream流知识点总结"><a href="#Stream流知识点总结" class="headerlink" title="Stream流知识点总结"></a>Stream流知识点总结</h1><p>Steam流是Java 8引入的一个强大的API，用于处理集合数据的函数式编程方式。以下是关于Steam流的主要知识点总结：</p><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><ul><li><strong>Stream</strong>：不是数据结构，而是对数据源(集合、数组等)的高级抽象，用于高效处理大量数据</li><li><strong>特点</strong>：<ul><li>不存储数据(只是数据源的视图)</li><li>不修改源数据(操作会产生新Stream)</li><li>惰性执行(终端操作时才执行)</li><li>可消费性(Stream只能被消费一次)</li></ul></li></ul><h2 id="2-创建Stream的方式"><a href="#2-创建Stream的方式" class="headerlink" title="2. 创建Stream的方式"></a>2. 创建Stream的方式</h2><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 从集合创建</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">// 从数组创建</span><br><span class="line">String[] array = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(array);</span><br><span class="line"></span><br><span class="line">// 使用Stream.of()</span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line"></span><br><span class="line">// 创建无限流</span><br><span class="line">Stream&lt;Integer&gt; infiniteStream = Stream.iterate(0, n -&gt; n + 2); // 无限流</span><br><span class="line">Stream&lt;Double&gt; randomStream = Stream.generate(Math::random); // 无限随机数流</span><br></pre></td></tr></table></figure><h2 id="3-中间操作-Intermediate-Operations"><a href="#3-中间操作-Intermediate-Operations" class="headerlink" title="3. 中间操作(Intermediate Operations)"></a>3. 中间操作(Intermediate Operations)</h2><ul><li>**filter(Predicate)**：过滤元素</li><li>**map(Function)**：转换元素</li><li>**flatMap(Function)**：扁平化流(将流中的每个值转换为另一个流)</li><li>**distinct()**：去重</li><li>**sorted()**：排序</li><li>**limit(long)**：限制元素数量</li><li>**skip(long)**：跳过前N个元素</li><li>**peek(Consumer)**：查看流中元素(主要用于调试)</li></ul><h2 id="4-终端操作-Terminal-Operations"><a href="#4-终端操作-Terminal-Operations" class="headerlink" title="4. 终端操作(Terminal Operations)"></a>4. 终端操作(Terminal Operations)</h2><ul><li>**forEach(Consumer)**：遍历每个元素</li><li>**count()**：计数</li><li>**collect(Collector)**：将流转换为集合或其他形式</li><li>**reduce(BinaryOperator)**：归约操作</li><li>**min(Comparator)&#x2F;max(Comparator)**：查找最小&#x2F;最大值</li><li>**anyMatch(Predicate)&#x2F;allMatch(Predicate)&#x2F;noneMatch(Predicate)**：匹配检查</li><li>**findFirst()&#x2F;findAny()**：查找元素</li></ul><h2 id="5-收集器-Collectors"><a href="#5-收集器-Collectors" class="headerlink" title="5. 收集器(Collectors)"></a>5. 收集器(Collectors)</h2><p>常用Collectors方法：</p><ul><li>**toList()&#x2F;toSet()&#x2F;toCollection()**：转换为集合</li><li>**joining()**：连接字符串</li><li>**summingInt()&#x2F;averagingInt()**：求和&#x2F;平均值</li><li>**groupingBy()**：分组</li><li>**partitioningBy()**：分区</li><li>**counting()**：计数</li></ul><h2 id="6-并行流-Parallel-Stream"><a href="#6-并行流-Parallel-Stream" class="headerlink" title="6. 并行流(Parallel Stream)"></a>6. 并行流(Parallel Stream)</h2><ul><li>使用<code>parallelStream()</code>或<code>stream().parallel()</code>创建并行流</li><li>适用于大数据量且无状态的操作</li><li>注意线程安全问题</li></ul><h2 id="7-使用示例"><a href="#7-使用示例" class="headerlink" title="7. 使用示例"></a>7. 使用示例</h2><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 示例1: 过滤和映射</span><br><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;);</span><br><span class="line">List&lt;String&gt; result = names.stream()</span><br><span class="line">    .filter(name -&gt; name.length() &gt; 3)</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">// 示例2: 分组</span><br><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; groupByNameLength = names.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(String::length));</span><br><span class="line"></span><br><span class="line">// 示例3: 归约</span><br><span class="line">Optional&lt;Integer&gt; totalLength = names.stream()</span><br><span class="line">    .map(String::length)</span><br><span class="line">    .reduce(Integer::sum);</span><br></pre></td></tr></table></figure><h2 id="8-注意事项"><a href="#8-注意事项" class="headerlink" title="8. 注意事项"></a>8. 注意事项</h2><ol><li>Stream操作是延迟执行的，只有终端操作才会触发实际计算</li><li>Stream只能被消费一次，再次使用会抛出IllegalStateException</li><li>避免在流操作中修改源数据</li><li>对于简单操作，传统循环可能比Stream更高效</li></ol><p>Stream API极大地简化了集合操作，使代码更简洁、易读，特别适合复杂的数据处理场景。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架概述</title>
      <link href="/2025/07/04/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/"/>
      <url>/2025/07/04/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="集合框架概述"><a href="#集合框架概述" class="headerlink" title="集合框架概述"></a>集合框架概述</h2><p>Java集合框架(Java Collections Framework)是一组用来存储和操作数据的类和接口，位于java.util包中。它提供了高效的数据结构和算法，简化了程序员的工作。</p><h2 id="集合框架主要接口"><a href="#集合框架主要接口" class="headerlink" title="集合框架主要接口"></a>集合框架主要接口</h2><h3 id="1-Collection接口-根接口"><a href="#1-Collection接口-根接口" class="headerlink" title="1. Collection接口 (根接口)"></a>1. Collection接口 (根接口)</h3><ul><li><strong>List</strong>：有序集合，元素可重复</li><li><strong>Set</strong>：无序集合，元素不可重复</li><li><strong>Queue</strong>：队列，先进先出(FIFO)</li></ul><h3 id="2-Map接口-独立于Collection"><a href="#2-Map接口-独立于Collection" class="headerlink" title="2. Map接口 (独立于Collection)"></a>2. Map接口 (独立于Collection)</h3><ul><li>键值对存储结构</li></ul><h2 id="主要实现类"><a href="#主要实现类" class="headerlink" title="主要实现类"></a>主要实现类</h2><h3 id="List接口实现类"><a href="#List接口实现类" class="headerlink" title="List接口实现类"></a>List接口实现类</h3><ol><li><strong>ArrayList</strong><ul><li>基于动态数组实现</li><li>随机访问快(O(1))，插入删除慢(O(n))</li><li>线程不安全</li></ul></li><li><strong>LinkedList</strong><ul><li>基于双向链表实现</li><li>插入删除快(O(1))，随机访问慢(O(n))</li><li>实现了Deque接口，可用作队列或栈</li></ul></li><li><strong>Vector</strong><ul><li>类似ArrayList，但线程安全</li><li>性能较差，已被ArrayList取代</li></ul></li><li><strong>Stack</strong> (继承自Vector)<ul><li>后进先出(LIFO)的栈结构</li></ul></li></ol><h3 id="Set接口实现类"><a href="#Set接口实现类" class="headerlink" title="Set接口实现类"></a>Set接口实现类</h3><ol><li><strong>HashSet</strong><ul><li>基于HashMap实现</li><li>无序，允许null元素</li><li>添加、删除、查找时间复杂度O(1)</li></ul></li><li><strong>LinkedHashSet</strong><ul><li>继承HashSet，维护插入顺序</li><li>性能略低于HashSet</li></ul></li><li><strong>TreeSet</strong><ul><li>基于TreeMap实现(红黑树)</li><li>元素按自然顺序或Comparator排序</li><li>添加、删除、查找时间复杂度O(log n)</li></ul></li></ol><h3 id="Queue接口实现类"><a href="#Queue接口实现类" class="headerlink" title="Queue接口实现类"></a>Queue接口实现类</h3><ol><li><strong>PriorityQueue</strong><ul><li>基于优先级堆实现</li><li>元素按自然顺序或Comparator排序</li></ul></li><li><strong>ArrayDeque</strong><ul><li>基于可调整大小的数组实现</li><li>可用作栈或队列</li></ul></li></ol><h3 id="Map接口实现类"><a href="#Map接口实现类" class="headerlink" title="Map接口实现类"></a>Map接口实现类</h3><ol><li><strong>HashMap</strong><ul><li>基于哈希表实现(数组+链表+红黑树)</li><li>允许null键和null值</li><li>无序，线程不安全</li></ul></li><li><strong>LinkedHashMap</strong><ul><li>继承HashMap，维护插入顺序或访问顺序</li><li>性能略低于HashMap</li></ul></li><li><strong>TreeMap</strong><ul><li>基于红黑树实现</li><li>键按自然顺序或Comparator排序</li></ul></li><li><strong>Hashtable</strong><ul><li>类似HashMap，但线程安全</li><li>不允许null键和null值</li><li>已被ConcurrentHashMap取代</li></ul></li><li><strong>ConcurrentHashMap</strong><ul><li>线程安全的HashMap</li><li>采用分段锁技术，性能优于Hashtable</li></ul></li></ol><h2 id="集合工具类Collections"><a href="#集合工具类Collections" class="headerlink" title="集合工具类Collections"></a>集合工具类Collections</h2><p>提供了一系列静态方法用于操作集合：</p><ul><li><code>sort()</code>：排序</li><li><code>shuffle()</code>：随机打乱</li><li><code>reverse()</code>：反转</li><li><code>synchronizedXxx()</code>：返回线程安全的集合</li><li><code>unmodifiableXxx()</code>：返回不可修改的集合</li></ul><h2 id="集合遍历方式"><a href="#集合遍历方式" class="headerlink" title="集合遍历方式"></a>集合遍历方式</h2><ol><li><p><strong>for循环</strong> (适用于List)</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0; i&lt;list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>增强for循环</strong></p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>迭代器Iterator</strong></p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">while(it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ListIterator</strong> (仅List可用，可双向遍历)</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;String&gt; lit = list.listIterator();</span><br><span class="line">while(lit.hasNext()) &#123;</span><br><span class="line">    System.out.println(lit.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>forEach()方法</strong> (Java8+)</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(item -&gt; System.out.println(item));</span><br></pre></td></tr></table></figure></li></ol><h2 id="集合选择原则"><a href="#集合选择原则" class="headerlink" title="集合选择原则"></a>集合选择原则</h2><ol><li>需要唯一性 → Set</li><li>需要有序 → List</li><li>需要键值对 → Map</li><li>需要快速访问 → ArrayList&#x2F;HashMap</li><li>需要频繁插入删除 → LinkedList</li><li>需要排序 → TreeSet&#x2F;TreeMap</li><li>需要线程安全 → ConcurrentHashMap&#x2F;Collections.synchronizedXxx()</li></ol><h2 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8+新特性"></a>Java8+新特性</h2><ol><li><p><strong>Stream API</strong>：函数式操作集合</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(s -&gt; s.startsWith(&quot;A&quot;)).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p><strong>默认方法</strong>：如List的sort()方法</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Comparator.naturalOrder());</span><br></pre></td></tr></table></figure></li><li><p><strong>不可变集合</strong>：Java9引入的工厂方法</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; immutableList = List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br></pre></td></tr></table></figure></li></ol><p>掌握集合框架对于Java开发至关重要，合理选择集合类型可以显著提高程序性能和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名内部类与Lambda表达式</title>
      <link href="/2025/07/03/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/07/03/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="匿名内部类与Lambda表达式知识点总结"><a href="#匿名内部类与Lambda表达式知识点总结" class="headerlink" title="匿名内部类与Lambda表达式知识点总结"></a>匿名内部类与Lambda表达式知识点总结</h1><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>匿名内部类是没有名字的内部类</li><li>用于快速创建某个类或接口的子类&#x2F;实现类的实例</li><li>适合只使用一次的类实现</li></ul><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new 父类构造器(参数列表) | 实现接口() &#123;</span><br><span class="line">    // 匿名内部类的类体部分</span><br><span class="line">    方法重写/实现</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>必须继承一个父类或实现一个接口</li><li>只能创建一个实例</li><li>没有构造方法（但可以有实例初始化块）</li><li>可以访问外部类的成员，包括私有成员</li><li>如果访问局部变量，该变量必须是final或事实上final的</li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>事件监听器</li><li>线程实现</li><li>需要快速实现某个接口或抽象类</li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>Java 8引入的函数式编程特性</li><li>用于简化函数式接口的实现</li><li>本质是一个匿名函数</li></ul><h3 id="语法结构-1"><a href="#语法结构-1" class="headerlink" title="语法结构"></a>语法结构</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>只能用于函数式接口（只有一个抽象方法的接口）</li><li>类型可以自动推断</li><li>可以访问外部final或事实上final的局部变量</li><li>简洁明了，减少样板代码</li></ol><h3 id="常见函数式接口"><a href="#常见函数式接口" class="headerlink" title="常见函数式接口"></a>常见函数式接口</h3><ul><li><code>Runnable</code> -&gt; <code>() -&gt; &#123;...&#125;</code></li><li><code>Consumer&lt;T&gt;</code> -&gt; <code>(T t) -&gt; &#123;...&#125;</code></li><li><code>Supplier&lt;T&gt;</code> -&gt; <code>() -&gt; &#123;...&#125;</code></li><li><code>Function&lt;T,R&gt;</code> -&gt; <code>(T t) -&gt; &#123;... return R;&#125;</code></li><li><code>Predicate&lt;T&gt;</code> -&gt; <code>(T t) -&gt; &#123;... return boolean;&#125;</code></li></ul><h2 id="匿名内部类-vs-Lambda表达式"><a href="#匿名内部类-vs-Lambda表达式" class="headerlink" title="匿名内部类 vs Lambda表达式"></a>匿名内部类 vs Lambda表达式</h2><table><thead><tr><th align="left">特性</th><th align="left">匿名内部类</th><th align="left">Lambda表达式</th></tr></thead><tbody><tr><td align="left">语法复杂度</td><td align="left">较复杂</td><td align="left">简洁</td></tr><tr><td align="left">使用场景</td><td align="left">任何类&#x2F;接口</td><td align="left">仅函数式接口</td></tr><tr><td align="left">this关键字</td><td align="left">指向匿名内部类本身</td><td align="left">指向外部类</td></tr><tr><td align="left">编译后</td><td align="left">生成单独的.class文件</td><td align="left">不生成.class文件，使用invokedynamic</td></tr><tr><td align="left">访问外部变量</td><td align="left">必须final或事实上final</td><td align="left">必须final或事实上final</td></tr><tr><td align="left">多重方法</td><td align="left">可以</td><td align="left">不可以</td></tr></tbody></table><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="匿名内部类示例"><a href="#匿名内部类示例" class="headerlink" title="匿名内部类示例"></a>匿名内部类示例</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 实现接口</span><br><span class="line">Runnable r = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;匿名内部类实现&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 继承抽象类</span><br><span class="line">Thread t = new Thread() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;继承Thread类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式示例"><a href="#Lambda表达式示例" class="headerlink" title="Lambda表达式示例"></a>Lambda表达式示例</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 无参数</span><br><span class="line">Runnable r = () -&gt; System.out.println(&quot;Lambda实现&quot;);</span><br><span class="line"></span><br><span class="line">// 有参数</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">list.forEach(item -&gt; System.out.println(item));</span><br><span class="line"></span><br><span class="line">// 多行代码</span><br><span class="line">list.forEach(item -&gt; &#123;</span><br><span class="line">    String upper = item.toUpperCase();</span><br><span class="line">    System.out.println(upper);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>Lambda表达式只能替代函数式接口的匿名内部类</li><li>当需要重写多个方法时，仍需使用匿名内部类</li><li>Lambda表达式中的变量必须是final或事实上final</li><li>在需要访问实例变量或方法时，匿名内部类可能更合适</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架概述</title>
      <link href="/2025/07/02/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2025/07/02/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、抽象类（Abstract-Class）"><a href="#一、抽象类（Abstract-Class）" class="headerlink" title="一、抽象类（Abstract Class）"></a>一、抽象类（Abstract Class）</h2><h3 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title="1. 基本特性"></a>1. 基本特性</h3><ul><li>使用<code>abstract</code>关键字声明</li><li>可以包含抽象方法和具体方法</li><li>不能直接实例化（不能new）</li><li>可以包含成员变量、构造方法、普通方法</li></ul><h3 id="2-语法结构"><a href="#2-语法结构" class="headerlink" title="2. 语法结构"></a>2. 语法结构</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line">    // 成员变量</span><br><span class="line">    protected String name;</span><br><span class="line">    </span><br><span class="line">    // 构造方法</span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 抽象方法（无实现）</span><br><span class="line">    public abstract void makeSound();</span><br><span class="line">    </span><br><span class="line">    // 具体方法</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(name + &quot;正在吃东西&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用要点"><a href="#3-使用要点" class="headerlink" title="3. 使用要点"></a>3. 使用要点</h3><ul><li><strong>抽象方法</strong>：没有方法体，必须用<code>abstract</code>修饰</li><li><strong>子类要求</strong>：非抽象子类必须实现所有抽象方法</li><li><strong>构造方法</strong>：虽然不能实例化，但可以有构造方法供子类调用</li><li><strong>访问控制</strong>：抽象方法不能用private修饰（因为需要子类实现）</li></ul><h3 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h3><ul><li>多个相关类共享代码和关系</li><li>需要定义子类的共同行为规范</li><li>需要包含非public的成员和方法</li><li>需要定义非static、非final的成员变量</li></ul><h2 id="二、接口（Interface）"><a href="#二、接口（Interface）" class="headerlink" title="二、接口（Interface）"></a>二、接口（Interface）</h2><h3 id="1-基本特性-1"><a href="#1-基本特性-1" class="headerlink" title="1. 基本特性"></a>1. 基本特性</h3><ul><li>Java 7及以前：纯抽象（只有抽象方法）</li><li>Java 8开始：支持默认方法（default）和静态方法</li><li>Java 9开始：支持私有方法</li><li>不能包含实例字段（只能是static final常量）</li><li>不能有构造方法</li></ul><h3 id="2-语法演进"><a href="#2-语法演进" class="headerlink" title="2. 语法演进"></a>2. 语法演进</h3><h4 id="Java-7及以前"><a href="#Java-7及以前" class="headerlink" title="Java 7及以前"></a>Java 7及以前</h4><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Flyable &#123;</span><br><span class="line">    // 常量（默认public static final）</span><br><span class="line">    int MAX_HEIGHT = 10000;</span><br><span class="line">    </span><br><span class="line">    // 抽象方法（默认public abstract）</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8+"></a>Java 8+</h4><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface SmartDevice &#123;</span><br><span class="line">    // 抽象方法</span><br><span class="line">    void turnOn();</span><br><span class="line">    </span><br><span class="line">    // 默认方法</span><br><span class="line">    default void updateFirmware() &#123;</span><br><span class="line">        System.out.println(&quot;执行默认固件更新&quot;);</span><br><span class="line">        privateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 静态方法</span><br><span class="line">    static void showVersion() &#123;</span><br><span class="line">        System.out.println(&quot;智能设备接口v2.0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Java 9私有方法</span><br><span class="line">    private void privateMethod() &#123;</span><br><span class="line">        System.out.println(&quot;私有方法执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用要点-1"><a href="#3-使用要点-1" class="headerlink" title="3. 使用要点"></a>3. 使用要点</h3><ul><li><strong>实现要求</strong>：类实现接口必须实现所有抽象方法（默认方法可选）</li><li><strong>多继承</strong>：一个类可以实现多个接口</li><li><strong>接口继承</strong>：接口可以继承多个其他接口</li><li><strong>默认冲突</strong>：当多个接口有相同默认方法时，实现类必须重写</li></ul><h3 id="4-适用场景-1"><a href="#4-适用场景-1" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h3><ul><li>定义不相关类的共同行为</li><li>需要多重继承的场景</li><li>作为API的定义规范</li><li>需要定义回调函数（如EventListener）</li></ul><h2 id="三、抽象类与接口对比"><a href="#三、抽象类与接口对比" class="headerlink" title="三、抽象类与接口对比"></a>三、抽象类与接口对比</h2><table><thead><tr><th align="left">特性</th><th align="left">抽象类</th><th align="left">接口</th></tr></thead><tbody><tr><td align="left"><strong>关键字</strong></td><td align="left">abstract class</td><td align="left">interface</td></tr><tr><td align="left"><strong>方法类型</strong></td><td align="left">抽象方法+具体方法</td><td align="left">Java 8前只有抽象方法，之后有默认方法和静态方法</td></tr><tr><td align="left"><strong>变量</strong></td><td align="left">可以有各种成员变量</td><td align="left">只能是public static final常量</td></tr><tr><td align="left"><strong>构造方法</strong></td><td align="left">有</td><td align="left">没有</td></tr><tr><td align="left"><strong>继承&#x2F;实现</strong></td><td align="left">单继承（extends）</td><td align="left">多实现（implements）</td></tr><tr><td align="left"><strong>设计目的</strong></td><td align="left">代码复用和层次化设计</td><td align="left">定义行为规范和能力</td></tr><tr><td align="left"><strong>访问控制</strong></td><td align="left">可以是任意访问修饰符</td><td align="left">默认public（不能是protected&#x2F;private）</td></tr><tr><td align="left"><strong>多态支持</strong></td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left"><strong>JDK版本影响</strong></td><td align="left">不受影响</td><td align="left">功能随版本增强</td></tr></tbody></table><h2 id="四、选择原则"><a href="#四、选择原则" class="headerlink" title="四、选择原则"></a>四、选择原则</h2><ol><li><p><strong>使用抽象类当</strong>：</p><ul><li>多个相关类需要共享代码</li><li>需要定义非public的成员</li><li>需要定义非static、非final的字段</li><li>需要定义构造方法逻辑</li></ul></li><li><p><strong>使用接口当</strong>：</p><ul><li>不相关的类需要实现相同的行为</li><li>需要多重继承</li><li>只关注行为规范而非实现</li><li>作为API定义供他人实现</li></ul></li><li><p><strong>组合使用</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 抽象类提供基础实现</span><br><span class="line">abstract class Bird extends Animal implements Flyable &#123;</span><br><span class="line">    // 既继承Animal的特性，又实现Flyable的能力</span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;用翅膀飞行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="五、最新发展（Java-8-17）"><a href="#五、最新发展（Java-8-17）" class="headerlink" title="五、最新发展（Java 8-17）"></a>五、最新发展（Java 8-17）</h2><ol><li><strong>接口的增强</strong>：<ul><li>默认方法（解决接口演化问题）</li><li>静态方法（工具方法）</li><li>私有方法（Java 9，代码复用）</li></ul></li><li><strong>接口与抽象类的界限模糊</strong>：<ul><li>接口现在也可以有方法实现</li><li>但接口仍然不能有实例状态（成员变量）</li></ul></li><li><strong>record类与sealed类</strong>：<ul><li>Java 14引入record（数据载体）</li><li>Java 15引入sealed类（受限继承）</li><li>这些新特性与抽象类&#x2F;接口形成互补</li></ul></li></ol><h2 id="六、设计模式中的应用"><a href="#六、设计模式中的应用" class="headerlink" title="六、设计模式中的应用"></a>六、设计模式中的应用</h2><ol><li><p><strong>模板方法模式</strong>（抽象类典型应用）：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract class Game &#123;</span><br><span class="line">    abstract void initialize();</span><br><span class="line">    abstract void startPlay();</span><br><span class="line">    </span><br><span class="line">    // 模板方法</span><br><span class="line">    public final void play() &#123;</span><br><span class="line">        initialize();</span><br><span class="line">        startPlay();</span><br><span class="line">        endPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>策略模式</strong>（接口典型应用）：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface PaymentStrategy &#123;</span><br><span class="line">    void pay(int amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CreditCardPayment implements PaymentStrategy &#123;</span><br><span class="line">    public void pay(int amount) &#123; /*...*/ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>适配器模式</strong>（结合使用）：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Target &#123;</span><br><span class="line">    void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Adapter implements Target &#123;</span><br><span class="line">    public void request() &#123; /* 默认实现 */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>掌握抽象类和接口的区别与适用场景，是Java面向对象设计的重要基础。随着Java版本的更新，两者的功能都在不断增强，但核心设计理念保持不变：抽象类侧重于”是什么”，接口侧重于”能做什么”。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承与多态核心知识点总结</title>
      <link href="/2025/07/02/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E6%80%BB%E7%BB%93/"/>
      <url>/2025/07/02/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="继承与多态核心知识点总结"><a href="#继承与多态核心知识点总结" class="headerlink" title="继承与多态核心知识点总结"></a>继承与多态核心知识点总结</h1><h2 id="1-继承-Inheritance"><a href="#1-继承-Inheritance" class="headerlink" title="1. 继承 (Inheritance)"></a>1. 继承 (Inheritance)</h2><p><strong>概念</strong>：</p><ul><li>允许一个类(子类)继承另一个类(父类)的特征和行为</li><li>子类可以获得父类的属性和方法，并可以添加新的属性和方法</li></ul><p><strong>语法</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">    // 子类特有的属性和方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ol><li>Java是单继承，一个类只能直接继承一个父类</li><li>子类继承父类非private的成员(属性和方法)</li><li>子类可以重写(override)父类的方法</li><li>构造方法不能被继承</li></ol><p><strong>关键字</strong>：</p><ul><li><code>extends</code>：表示继承关系</li><li><code>super</code>：引用父类的成员<ul><li><code>super()</code>：调用父类构造方法</li><li><code>super.方法名()</code>：调用父类方法</li></ul></li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(name + &quot;正在吃东西&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    String breed;</span><br><span class="line">    </span><br><span class="line">    public Dog(String name, String breed) &#123;</span><br><span class="line">        super(name); // 调用父类构造方法</span><br><span class="line">        this.breed = breed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        super.eat(); // 调用父类方法</span><br><span class="line">        System.out.println(name + &quot;正在吃狗粮&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void bark() &#123;</span><br><span class="line">        System.out.println(name + &quot;汪汪叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-多态-Polymorphism"><a href="#2-多态-Polymorphism" class="headerlink" title="2. 多态 (Polymorphism)"></a>2. 多态 (Polymorphism)</h2><p><strong>概念</strong>：</p><ul><li>同一操作作用于不同对象，可以有不同的解释，产生不同的执行结果</li><li>主要包括编译时多态(方法重载)和运行时多态(方法重写)</li></ul><p><strong>实现条件</strong>：</p><ol><li>继承关系</li><li>方法重写</li><li>父类引用指向子类对象</li></ol><p><strong>表现形式</strong>：</p><ol><li>方法重载(Overload) - 编译时多态<ul><li>同一个类中，方法名相同，参数列表不同</li></ul></li><li>方法重写(Override) - 运行时多态<ul><li>子类中定义与父类相同签名的方法</li></ul></li></ol><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 方法重载示例</span><br><span class="line">class Calculator &#123;</span><br><span class="line">    public int add(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public double add(double a, double b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法重写(多态)示例</span><br><span class="line">class Animal &#123;</span><br><span class="line">    public void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;动物发出声音&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;喵喵叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;汪汪叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal myAnimal = new Animal();  // Animal对象</span><br><span class="line">        Animal myCat = new Cat();       // Cat对象</span><br><span class="line">        Animal myDog = new Dog();        // Dog对象</span><br><span class="line">        </span><br><span class="line">        myAnimal.makeSound();  // 输出: 动物发出声音</span><br><span class="line">        myCat.makeSound();    // 输出: 喵喵叫</span><br><span class="line">        myDog.makeSound();     // 输出: 汪汪叫</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-继承与多态的重要特性"><a href="#3-继承与多态的重要特性" class="headerlink" title="3. 继承与多态的重要特性"></a>3. 继承与多态的重要特性</h2><h3 id="3-1-方法重写-Override-规则"><a href="#3-1-方法重写-Override-规则" class="headerlink" title="3.1 方法重写(Override)规则"></a>3.1 方法重写(Override)规则</h3><ol><li>方法名和参数列表必须完全相同</li><li>返回类型可以是父类方法返回类型的子类(协变返回类型)</li><li>访问权限不能比父类方法更严格</li><li>不能重写private、final和static方法</li><li>重写方法可以抛出与父类方法相同的异常或不抛出异常或抛出父类异常的子类异常</li></ol><h3 id="3-2-向上转型-Upcasting-和向下转型-Downcasting"><a href="#3-2-向上转型-Upcasting-和向下转型-Downcasting" class="headerlink" title="3.2 向上转型(Upcasting)和向下转型(Downcasting)"></a>3.2 向上转型(Upcasting)和向下转型(Downcasting)</h3><ul><li><p><strong>向上转型</strong>：子类对象赋值给父类引用(自动转换)</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = new Dog(); // 向上转型</span><br></pre></td></tr></table></figure></li><li><p><strong>向下转型</strong>：父类引用强制转换为子类引用(需要显式转换)</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = (Dog)animal; // 向下转型</span><br></pre></td></tr></table></figure></li></ul><p><strong>instanceof运算符</strong>：<br>用于检查对象是否是特定类的实例，常用于向下转型前的安全检查</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (animal instanceof Dog) &#123;</span><br><span class="line">    Dog dog = (Dog)animal;</span><br><span class="line">    dog.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-抽象类与多态"><a href="#3-3-抽象类与多态" class="headerlink" title="3.3 抽象类与多态"></a>3.3 抽象类与多态</h3><ul><li>抽象类不能实例化，只能被继承</li><li>抽象方法没有方法体，必须在子类中实现</li><li>抽象类可以包含普通方法和抽象方法</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">abstract class Shape &#123;</span><br><span class="line">    abstract double area(); // 抽象方法</span><br><span class="line">    </span><br><span class="line">    void display() &#123;        // 普通方法</span><br><span class="line">        System.out.println(&quot;这是一个形状&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle extends Shape &#123;</span><br><span class="line">    double radius;</span><br><span class="line">    </span><br><span class="line">    Circle(double r) &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    double area() &#123;</span><br><span class="line">        return Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle extends Shape &#123;</span><br><span class="line">    double length, width;</span><br><span class="line">    </span><br><span class="line">    Rectangle(double l, double w) &#123;</span><br><span class="line">        length = l;</span><br><span class="line">        width = w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    double area() &#123;</span><br><span class="line">        return length * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-接口与多态"><a href="#3-4-接口与多态" class="headerlink" title="3.4 接口与多态"></a>3.4 接口与多态</h3><ul><li>接口是完全抽象的类，所有方法默认是public abstract</li><li>类可以实现多个接口</li><li>接口可以多继承其他接口</li><li>Java 8后接口可以有默认方法和静态方法</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">interface Flyable &#123;</span><br><span class="line">    void fly(); // 抽象方法</span><br><span class="line">    </span><br><span class="line">    default void land() &#123; // 默认方法</span><br><span class="line">        System.out.println(&quot;正在着陆&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static int getMaxAltitude() &#123; // 静态方法</span><br><span class="line">        return 10000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Swimmable &#123;</span><br><span class="line">    void swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Duck implements Flyable, Swimmable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;鸭子飞起来了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line">        System.out.println(&quot;鸭子在游泳&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-继承与多态的应用场景"><a href="#4-继承与多态的应用场景" class="headerlink" title="4. 继承与多态的应用场景"></a>4. 继承与多态的应用场景</h2><ol><li><strong>代码复用</strong>：通过继承复用父类代码</li><li><strong>扩展功能</strong>：子类可以在继承的基础上添加新功能</li><li><strong>统一接口</strong>：多态允许不同类型的对象响应相同的消息</li><li><strong>框架设计</strong>：通过抽象类和接口定义框架，具体实现由子类完成</li><li><strong>插件架构</strong>：通过接口定义标准，具体实现可以动态加载</li></ol><h2 id="5-tips"><a href="#5-tips" class="headerlink" title="5.tips"></a>5.tips</h2><p>import lombok.AllArgsConstructor:<br>import lombok.Data;<br>import lombok.NoArgsConstructor;<br>&#x2F;&#x2F; lombok技术可以实现为类自动添加getter setter方法无参数构造器，toString方法等</p><p>@Data &#x2F;&#x2F; @Data注解可以自动生成getter setter方法无参构造器 toString方法等</p><p>@NoArgsConstructor</p><p>@AllArgsConstructor</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象编程基础语法</title>
      <link href="/2025/07/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/07/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面向对象编程基础语法"><a href="#Java面向对象编程基础语法" class="headerlink" title="Java面向对象编程基础语法"></a>Java面向对象编程基础语法</h1><h2 id="1-对象-Object"><a href="#1-对象-Object" class="headerlink" title="1. 对象 (Object)"></a>1. 对象 (Object)</h2><p><strong>概念</strong>：</p><ul><li>对象是类的实例，是面向对象编程的基本单位</li><li>对象具有状态(属性)和行为(方法)</li><li>对象在内存中占据独立的空间</li></ul><p><strong>特点</strong>：</p><ul><li>每个对象都有唯一的标识(内存地址)</li><li>对象之间通过消息传递进行交互</li><li>对象是类的具体实现</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = new Person(); // person1是一个Person类的对象</span><br></pre></td></tr></table></figure><h2 id="2-封装-Encapsulation"><a href="#2-封装-Encapsulation" class="headerlink" title="2. 封装 (Encapsulation)"></a>2. 封装 (Encapsulation)</h2><p><strong>概念</strong>：</p><ul><li>将数据(属性)和行为(方法)包装在一个单元(类)中</li><li>隐藏对象的内部实现细节，仅暴露必要的接口</li></ul><p><strong>实现方式</strong>：</p><ul><li>使用访问修饰符控制可见性：<ul><li><code>private</code>：仅本类可见</li><li><code>protected</code>：本包和子类可见</li><li><code>public</code>：所有类可见</li><li>(默认)：本包可见</li></ul></li></ul><p><strong>优点</strong>：</p><ul><li>提高代码安全性</li><li>降低耦合度</li><li>便于修改和维护</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BankAccount &#123;</span><br><span class="line">    private double balance; // 私有属性，外部不可直接访问</span><br><span class="line">    </span><br><span class="line">    // 公有方法，提供受控的访问方式</span><br><span class="line">    public void deposit(double amount) &#123;</span><br><span class="line">        if(amount &gt; 0) &#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public double getBalance() &#123;</span><br><span class="line">        return balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-构造器-Constructor"><a href="#3-构造器-Constructor" class="headerlink" title="3. 构造器 (Constructor)"></a>3. 构造器 (Constructor)</h2><p><strong>概念</strong>：</p><ul><li>一种特殊的方法，用于创建和初始化对象</li><li>方法名与类名相同，没有返回类型(连void也没有)</li></ul><p><strong>特点</strong>：</p><ul><li>在创建对象时自动调用(new时)</li><li>可以重载(多个不同参数的构造器)</li><li>如果没有显式定义构造器，编译器会提供默认无参构造器</li><li>一旦定义了构造器，默认构造器就不再自动提供</li></ul><p><strong>分类</strong>：</p><ol><li>无参构造器</li><li>带参构造器</li></ol><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    // 无参构造器</span><br><span class="line">    public Person() &#123;</span><br><span class="line">        this.name = &quot;未知&quot;;</span><br><span class="line">        this.age = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 带参构造器</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-this关键字"><a href="#4-this关键字" class="headerlink" title="4. this关键字"></a>4. this关键字</h2><p><strong>作用</strong>：</p><ol><li>指代当前对象</li><li>在构造器中调用其他构造器(必须放在第一行)</li><li>区分成员变量和局部变量</li></ol><p><strong>使用场景</strong>：</p><ul><li>当局部变量与成员变量同名时</li><li>在方法中需要返回当前对象时</li><li>在构造器中调用其他构造器时</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int score;</span><br><span class="line">    </span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this(name, 0); // 调用另一个构造器</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Student(String name, int score) &#123;</span><br><span class="line">        this.name = name; // 区分成员变量和参数</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Student getCurrentObject() &#123;</span><br><span class="line">        return this; // 返回当前对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-封装-Encapsulation-补充说明"><a href="#5-封装-Encapsulation-补充说明" class="headerlink" title="5. 封装 (Encapsulation) - 补充说明"></a>5. 封装 (Encapsulation) - 补充说明</h2><p><strong>封装的核心原则</strong>：</p><ul><li>将数据和对数据的操作绑定在一起</li><li>对外隐藏实现细节，只暴露必要的接口</li><li>通过访问控制实现信息隐藏</li></ul><p><strong>封装的具体实现</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    // 私有属性 - 实现封装</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private double score;</span><br><span class="line">    </span><br><span class="line">    // 公开的getter方法 - 提供受控的读访问</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 公开的setter方法 - 提供受控的写访问</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        if(name != null &amp;&amp; !name.isEmpty()) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他业务方法</span><br><span class="line">    public void printInfo() &#123;</span><br><span class="line">        System.out.println(&quot;姓名：&quot; + name + &quot;，年龄：&quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装的好处</strong>：</p><ol><li>防止外部代码随意修改对象内部状态</li><li>可以在setter方法中添加验证逻辑</li><li>修改内部实现不影响外部代码</li><li>提高代码的可维护性和安全性</li></ol><h2 id="6-实体类-Entity-Class"><a href="#6-实体类-Entity-Class" class="headerlink" title="6. 实体类 (Entity Class)"></a>6. 实体类 (Entity Class)</h2><p><strong>概念</strong>：</p><ul><li>用于表示现实世界中的实体或概念的类</li><li>通常对应数据库中的表或业务领域中的对象</li></ul><p><strong>实体类特点</strong>：</p><ol><li>主要包含属性和对应的getter&#x2F;setter方法</li><li>通常实现Serializable接口以支持序列化</li><li>可能包含简单的业务逻辑方法</li><li>一般会重写equals()、hashCode()和toString()方法</li></ol><p><strong>典型实体类示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    // 属性</span><br><span class="line">    private Long id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private Date createTime;</span><br><span class="line">    </span><br><span class="line">    // 构造方法</span><br><span class="line">    public User() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public User(String username, String password) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.createTime = new Date();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // getter和setter</span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他方法...</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, username=&#x27;&quot; + username + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, createTime=&quot; + createTime +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        // 实现equals方法...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        // 实现hashCode方法...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实体类的使用场景</strong>：</p><ul><li>数据传输对象(DTO)</li><li>持久化对象(对应数据库表)</li><li>业务模型对象</li></ul><h2 id="7-static-关键字"><a href="#7-static-关键字" class="headerlink" title="7. static 关键字"></a>7. static 关键字</h2><p><strong>static 的用途</strong>：</p><ol><li>静态变量（类变量）</li><li>静态方法（类方法）</li><li>静态代码块</li><li>静态内部类</li></ol><h3 id="7-1-静态变量（类变量）"><a href="#7-1-静态变量（类变量）" class="headerlink" title="7.1 静态变量（类变量）"></a>7.1 静态变量（类变量）</h3><p><strong>特点</strong>：</p><ul><li>属于类，不属于任何对象实例</li><li>所有对象共享同一份静态变量</li><li>在类加载时初始化</li><li>可以通过类名直接访问</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int id;</span><br><span class="line">    </span><br><span class="line">    // 静态变量 - 记录员工总数</span><br><span class="line">    private static int nextId = 1;</span><br><span class="line">    </span><br><span class="line">    public Employee(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.id = nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int getNextId() &#123;</span><br><span class="line">        return nextId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-静态方法（类方法）"><a href="#7-2-静态方法（类方法）" class="headerlink" title="7.2 静态方法（类方法）"></a>7.2 静态方法（类方法）</h3><p><strong>特点</strong>：</p><ul><li>属于类，不属于对象实例</li><li>不能直接访问实例变量和实例方法</li><li>可以通过类名直接调用</li><li>常用于工具类方法</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MathUtils &#123;</span><br><span class="line">    // 静态方法</span><br><span class="line">    public static double calculateCircleArea(double radius) &#123;</span><br><span class="line">        return Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int max(int a, int b) &#123;</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">double area = MathUtils.calculateCircleArea(5.0);</span><br><span class="line">int maxNum = MathUtils.max(10, 20);</span><br></pre></td></tr></table></figure><h3 id="7-3-静态代码块"><a href="#7-3-静态代码块" class="headerlink" title="7.3 静态代码块"></a>7.3 静态代码块</h3><p><strong>特点</strong>：</p><ul><li>在类加载时执行，且只执行一次</li><li>用于初始化静态变量或执行只需一次的初始化操作</li><li>可以有多个静态代码块，按顺序执行</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class DatabaseConfig &#123;</span><br><span class="line">    private static Properties props;</span><br><span class="line">    </span><br><span class="line">    // 静态代码块</span><br><span class="line">    static &#123;</span><br><span class="line">        props = new Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            props.load(DatabaseConfig.class.getResourceAsStream(&quot;/db.properties&quot;));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static String getConfig(String key) &#123;</span><br><span class="line">        return props.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-静态内部类"><a href="#7-4-静态内部类" class="headerlink" title="7.4 静态内部类"></a>7.4 静态内部类</h3><p><strong>特点</strong>：</p><ul><li>不依赖于外部类的实例</li><li>只能访问外部类的静态成员</li><li>常用于与外部类密切相关但又不需要访问外部类实例的情况</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private static String staticField = &quot;Static Field&quot;;</span><br><span class="line">    </span><br><span class="line">    // 静态内部类</span><br><span class="line">    public static class StaticNestedClass &#123;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(&quot;访问外部类的静态字段：&quot; + staticField);</span><br><span class="line">            // 不能访问非静态字段</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">OuterClass.StaticNestedClass nested = new OuterClass.StaticNestedClass();</span><br><span class="line">nested.print();</span><br></pre></td></tr></table></figure><h2 id="static-使用注意事项"><a href="#static-使用注意事项" class="headerlink" title="static 使用注意事项"></a>static 使用注意事项</h2><ol><li>静态方法中不能使用 this 和 super 关键字</li><li>静态方法只能直接调用其他静态方法</li><li>静态方法只能直接访问静态变量</li><li>静态方法不能被重写（但可以隐藏）</li><li>静态成员在类加载时初始化，早于实例成员的初始化</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BroadcastReceiver</title>
      <link href="/2025/04/20/BroadcastReceiver/"/>
      <url>/2025/04/20/BroadcastReceiver/</url>
      
        <content type="html"><![CDATA[<h2 id="🚨-什么是-BroadcastReceiver？"><a href="#🚨-什么是-BroadcastReceiver？" class="headerlink" title="🚨 什么是 BroadcastReceiver？"></a>🚨 什么是 BroadcastReceiver？</h2><p><code>BroadcastReceiver</code> 是 Android 提供的一个机制，用于<strong>在应用之间或系统与应用之间传递消息</strong>。比如：</p><ul><li>当手机接收到短信时；</li><li>电池电量变化；</li><li>网络连接变化；</li><li>你自己在 App 内发出一个自定义事件。</li></ul><p>这些“消息”叫做<strong>广播（Broadcast）</strong>，而负责“接收广播”的组件就是 <strong>BroadcastReceiver</strong>。</p><hr><h2 id="🧠-工作原理："><a href="#🧠-工作原理：" class="headerlink" title="🧠 工作原理："></a>🧠 工作原理：</h2><ol><li>某个组件（系统或 app）发送一个广播（用 <code>sendBroadcast()</code>）；</li><li>Android 系统会根据你注册的广播类型，找到匹配的 <code>BroadcastReceiver</code>；</li><li><code>BroadcastReceiver</code> 会执行你定义的逻辑（通常在 <code>onReceive()</code> 方法里写处理逻辑）；</li></ol><hr><h2 id="📦-BroadcastReceiver-分类"><a href="#📦-BroadcastReceiver-分类" class="headerlink" title="📦 BroadcastReceiver 分类"></a>📦 BroadcastReceiver 分类</h2><h3 id="1-静态注册"><a href="#1-静态注册" class="headerlink" title="1. 静态注册"></a>1. <strong>静态注册</strong></h3><ul><li>在 <code>AndroidManifest.xml</code> 中注册</li><li>会在 App 没启动的情况下也能接收到广播（某些系统广播）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.MyReceiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure><h3 id="2-动态注册"><a href="#2-动态注册" class="headerlink" title="2. 动态注册"></a>2. <strong>动态注册</strong></h3><ul><li>在 Java&#x2F;Kotlin 代码中注册</li><li>一般在 Activity 或 Service 的生命周期内注册和注销</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReceiver receiver = new MyReceiver();</span><br><span class="line">IntentFilter filter = new IntentFilter(&quot;com.example.MY_BROADCAST&quot;);</span><br><span class="line">registerReceiver(receiver, filter);  // 注册</span><br><span class="line">unregisterReceiver(receiver);        // 注销（避免内存泄漏）</span><br></pre></td></tr></table></figure><hr><h2 id="🧪-示例：自定义广播发送与接收"><a href="#🧪-示例：自定义广播发送与接收" class="headerlink" title="🧪 示例：自定义广播发送与接收"></a>🧪 示例：自定义广播发送与接收</h2><h3 id="1️⃣-创建一个自定义广播接收器："><a href="#1️⃣-创建一个自定义广播接收器：" class="headerlink" title="1️⃣ 创建一个自定义广播接收器："></a>1️⃣ 创建一个自定义广播接收器：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        // 当广播接收到时，这里会执行</span><br><span class="line">        String data = intent.getStringExtra(&quot;msg&quot;);</span><br><span class="line">        Toast.makeText(context, &quot;收到广播: &quot; + data, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2️⃣-动态注册（例如在-MainActivity-中）："><a href="#2️⃣-动态注册（例如在-MainActivity-中）：" class="headerlink" title="2️⃣ 动态注册（例如在 MainActivity 中）："></a>2️⃣ 动态注册（例如在 MainActivity 中）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyReceiver myReceiver = new MyReceiver();</span><br><span class="line">IntentFilter filter = new IntentFilter(&quot;com.example.MY_BROADCAST&quot;);</span><br><span class="line">registerReceiver(myReceiver, filter);</span><br></pre></td></tr></table></figure><h3 id="3️⃣-发送广播："><a href="#3️⃣-发送广播：" class="headerlink" title="3️⃣ 发送广播："></a>3️⃣ 发送广播：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(&quot;com.example.MY_BROADCAST&quot;);</span><br><span class="line">intent.putExtra(&quot;msg&quot;, &quot;你好，世界！&quot;);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure><hr><h2 id="🔐-权限和安全"><a href="#🔐-权限和安全" class="headerlink" title="🔐 权限和安全"></a>🔐 权限和安全</h2><ul><li><p>有些系统广播需要权限，例如监听开机广播：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xml</span><br><span class="line"></span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>Android 8.0（API 26）之后，对静态注册广播做了限制，一些隐式广播不能再静态注册，只能动态注册。</p></li></ul><hr><h2 id="✅-使用小贴士"><a href="#✅-使用小贴士" class="headerlink" title="✅ 使用小贴士"></a>✅ 使用小贴士</h2><table><thead><tr><th>内容</th><th>建议</th></tr></thead><tbody><tr><td>生命周期管理</td><td>动态注册时，记得在 <code>onDestroy()</code> 中注销广播</td></tr><tr><td>安全性</td><td>自定义广播建议使用 <code>LocalBroadcastManager</code>（已废弃，推荐使用 LiveData&#x2F;EventBus 替代）</td></tr><tr><td>不要做耗时操作</td><td><code>onReceive()</code> 中不能做耗时操作，默认运行在主线程</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> android主要组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android主要组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin中的内联函数</title>
      <link href="/2025/04/20/Kotlin%20%E4%B8%AD%E7%9A%84%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>/2025/04/20/Kotlin%20%E4%B8%AD%E7%9A%84%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="🌟-什么是内联函数？"><a href="#🌟-什么是内联函数？" class="headerlink" title="🌟 什么是内联函数？"></a>🌟 什么是内联函数？</h3><p>简单说：</p><blockquote><p><strong>内联函数就是在编译时将函数的调用代码“展开”为函数体本身，从而避免函数调用的开销。</strong></p></blockquote><p>通常高阶函数（比如 <code>map</code>, <code>filter</code>, <code>let</code>, <code>run</code> 等）都会带来额外的开销，因为它们需要创建函数对象、维护调用栈。而使用 <code>inline</code> 关键字修饰的函数在编译时会将其代码“拷贝”到调用处，避免这些额外开销。</p><hr><h3 id="🧪-基本语法"><a href="#🧪-基本语法" class="headerlink" title="🧪 基本语法"></a>🧪 基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun doSomething(action: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;Start&quot;)</span><br><span class="line">    action()</span><br><span class="line">    println(&quot;End&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething &#123;</span><br><span class="line">    println(&quot;Hello inline&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚡ 编译后，大致等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;Start&quot;)</span><br><span class="line">println(&quot;Hello inline&quot;)</span><br><span class="line">println(&quot;End&quot;)</span><br></pre></td></tr></table></figure><p>函数体直接“插入”到调用处。</p><hr><h3 id="✅-优势"><a href="#✅-优势" class="headerlink" title="✅ 优势"></a>✅ 优势</h3><ol><li><strong>性能提升</strong>：避免函数调用、lambda 对象创建的开销。</li><li><strong>允许非局部返回</strong>（下面详细说）</li><li><strong>适合频繁调用的小型函数或高阶函数</strong></li></ol><hr><h3 id="⚠️-注意：非局部返回（non-local-return）"><a href="#⚠️-注意：非局部返回（non-local-return）" class="headerlink" title="⚠️ 注意：非局部返回（non-local return）"></a>⚠️ 注意：<strong>非局部返回（non-local return）</strong></h3><p>Lambda 中用 <code>return</code>，默认是从<strong>外围函数</strong>返回的，这在内联函数中是允许的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">inline fun doSomething(block: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;Before&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;After&quot;)  // 不会执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun test() &#123;</span><br><span class="line">    doSomething &#123;</span><br><span class="line">        println(&quot;Inside&quot;)</span><br><span class="line">        return  // 非局部 return，直接从 test() 返回</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;This will not be printed&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你把 <code>doSomething</code> 的 <code>inline</code> 去掉，这段代码是<strong>无法通过编译</strong>的。</p><hr><h3 id="🔒-使用-noinline-禁止内联某个-lambda"><a href="#🔒-使用-noinline-禁止内联某个-lambda" class="headerlink" title="🔒 使用 noinline 禁止内联某个 lambda"></a>🔒 使用 <code>noinline</code> 禁止内联某个 lambda</h3><p>有时候你不希望某些 lambda 被内联，可以加 <code>noinline</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline fun process(a: () -&gt; Unit, noinline b: () -&gt; Unit) &#123;</span><br><span class="line">    a()     // 内联</span><br><span class="line">    b()     // 不内联</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用于 <strong>将 lambda 作为值传递或多次使用</strong> 的情况。</p><hr><h3 id="💥-crossinline：阻止-lambda-使用-return"><a href="#💥-crossinline：阻止-lambda-使用-return" class="headerlink" title="💥 crossinline：阻止 lambda 使用 return"></a>💥 <code>crossinline</code>：阻止 lambda 使用 return</h3><p>有时候你<strong>必须内联</strong>，但又<strong>不允许 lambda 使用非局部 return</strong>（比如 lambda 传给另一个线程或匿名类），你可以加 <code>crossinline</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun startJob(crossinline job: () -&gt; Unit) &#123;</span><br><span class="line">    Thread &#123;</span><br><span class="line">        job()  // 如果 job 用 return 会报错</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🚀-小总结"><a href="#🚀-小总结" class="headerlink" title="🚀 小总结"></a>🚀 小总结</h3><table><thead><tr><th>关键字</th><th>作用</th></tr></thead><tbody><tr><td><code>inline</code></td><td>编译时将函数体展开，提升性能，允许非局部 return</td></tr><tr><td><code>noinline</code></td><td>禁止某个 lambda 被内联（用于多次调用或当作对象传递）</td></tr><tr><td><code>crossinline</code></td><td>阻止某个 lambda 使用 <code>return</code>（防止非局部 return）</td></tr></tbody></table><hr><h3 id="✅-典型应用场景"><a href="#✅-典型应用场景" class="headerlink" title="✅ 典型应用场景"></a>✅ 典型应用场景</h3><ul><li><code>apply</code> &#x2F; <code>run</code> &#x2F; <code>let</code> 等标准库函数内部都是 <code>inline</code> 的</li><li>DSL 构建器，比如 <code>anko</code>, <code>Jetpack Compose</code>, <code>Ktor</code> 等大量用 <code>inline</code> 优化性能和语法结构</li><li>性能敏感的高阶函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin的高阶函数详解</title>
      <link href="/2025/04/20/Kotlin%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/20/Kotlin%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Kotlin的高阶函数详解</p><p>Kotlin 的高阶函数（Higher-Order Functions，简称 HOF）是函数式编程的一个重要特性，能够显著增强语言的表达力。高阶函数是指那些可以接受其他函数作为参数，或者返回函数的函数。</p><h3 id="1-高阶函数的定义"><a href="#1-高阶函数的定义" class="headerlink" title="1. 高阶函数的定义"></a>1. 高阶函数的定义</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>高阶函数指的是：</p><ul><li>接受函数作为参数</li><li>或者返回函数</li></ul><h4 id="示例：接受函数作为参数"><a href="#示例：接受函数作为参数" class="headerlink" title="示例：接受函数作为参数"></a>示例：接受函数作为参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; List&lt;T&gt;.customFilter(predicate: (T) -&gt; Boolean): List&lt;T&gt; &#123;</span><br><span class="line">    val result = mutableListOf&lt;T&gt;()</span><br><span class="line">    for (item in this) &#123;</span><br><span class="line">        if (predicate(item)) &#123;</span><br><span class="line">            result.add(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val numbers = listOf(1, 2, 3, 4, 5, 6)</span><br><span class="line">val evenNumbers = numbers.customFilter &#123; it % 2 == 0 &#125;</span><br><span class="line">println(evenNumbers)  // 输出: [2, 4, 6]</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>customFilter</code> 是一个高阶函数，它接受一个函数 <code>predicate</code> 作为参数，并根据该函数筛选列表中的元素。</p><h4 id="示例：返回函数"><a href="#示例：返回函数" class="headerlink" title="示例：返回函数"></a>示例：返回函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun multiplyBy(factor: Int): (Int) -&gt; Int &#123;</span><br><span class="line">    return &#123; number -&gt; number * factor &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val multiplyBy2 = multiplyBy(2)</span><br><span class="line">println(multiplyBy2(4))  // 输出: 8</span><br></pre></td></tr></table></figure><p>这里，<code>multiplyBy</code> 函数返回一个新的函数，它接受一个整数并将其乘以 <code>factor</code>。</p><h3 id="2-常见的高阶函数"><a href="#2-常见的高阶函数" class="headerlink" title="2. 常见的高阶函数"></a>2. 常见的高阶函数</h3><p>Kotlin 标准库包含了许多高阶函数，下面是一些常见的高阶函数。</p><h4 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a><code>map</code> 函数</h4><p><code>map</code> 是一个高阶函数，它接受一个变换函数，并返回一个新集合，其中包含应用该变换函数后的每个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val squared = numbers.map &#123; it * it &#125;</span><br><span class="line">println(squared)  // 输出: [1, 4, 9, 16]</span><br></pre></td></tr></table></figure><h4 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a><code>filter</code> 函数</h4><p><code>filter</code> 函数接受一个筛选条件，并返回一个新集合，只包含符合条件的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4, 5, 6)</span><br><span class="line">val evenNumbers = numbers.filter &#123; it % 2 == 0 &#125;</span><br><span class="line">println(evenNumbers)  // 输出: [2, 4, 6]</span><br></pre></td></tr></table></figure><h4 id="fold-函数"><a href="#fold-函数" class="headerlink" title="fold 函数"></a><code>fold</code> 函数</h4><p><code>fold</code> 是一个折叠函数，它将集合中的每个元素通过一个指定的操作组合起来，返回一个单一的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val sum = numbers.fold(0) &#123; accumulator, element -&gt; accumulator + element &#125;</span><br><span class="line">println(sum)  // 输出: 10</span><br></pre></td></tr></table></figure><p>这里，<code>fold</code> 从初始值 <code>0</code> 开始，依次将每个元素加到累加器上。</p><h4 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce 函数"></a><code>reduce</code> 函数</h4><p><code>reduce</code> 与 <code>fold</code> 类似，区别在于它没有初始值，直接使用集合的第一个元素作为初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val product = numbers.reduce &#123; accumulator, element -&gt; accumulator * element &#125;</span><br><span class="line">println(product)  // 输出: 24</span><br></pre></td></tr></table></figure><h4 id="forEach-函数"><a href="#forEach-函数" class="headerlink" title="forEach 函数"></a><code>forEach</code> 函数</h4><p><code>forEach</code> 是一个遍历集合的高阶函数，它接受一个操作函数，在集合的每个元素上执行该操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3)</span><br><span class="line">numbers.forEach &#123; println(it) &#125;</span><br><span class="line">// 输出:</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><h3 id="3-Lambda-表达式和高阶函数"><a href="#3-Lambda-表达式和高阶函数" class="headerlink" title="3. Lambda 表达式和高阶函数"></a>3. Lambda 表达式和高阶函数</h3><p>Kotlin 中，高阶函数通常与 Lambda 表达式一起使用，Lambda 表达式是一个匿名函数，它可以简洁地表示函数参数。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val sum = &#123; a: Int, b: Int -&gt; a + b &#125;</span><br><span class="line">println(sum(3, 4))  // 输出: 7</span><br></pre></td></tr></table></figure><h3 id="4-函数作为返回值"><a href="#4-函数作为返回值" class="headerlink" title="4. 函数作为返回值"></a>4. 函数作为返回值</h3><p>在 Kotlin 中，函数也可以作为返回值，且可以直接返回一个 Lambda 表达式。</p><h4 id="示例：返回一个高阶函数"><a href="#示例：返回一个高阶函数" class="headerlink" title="示例：返回一个高阶函数"></a>示例：返回一个高阶函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun operation(type: String): (Int, Int) -&gt; Int &#123;</span><br><span class="line">    return when (type) &#123;</span><br><span class="line">        &quot;sum&quot; -&gt; &#123; a, b -&gt; a + b &#125;</span><br><span class="line">        &quot;multiply&quot; -&gt; &#123; a, b -&gt; a * b &#125;</span><br><span class="line">        else -&gt; &#123; a, b -&gt; 0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val sumOperation = operation(&quot;sum&quot;)</span><br><span class="line">println(sumOperation(3, 4))  // 输出: 7</span><br><span class="line"></span><br><span class="line">val multiplyOperation = operation(&quot;multiply&quot;)</span><br><span class="line">println(multiplyOperation(3, 4))  // 输出: 12</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>operation</code> 函数根据不同的 <code>type</code> 返回不同的操作函数。</p><h3 id="5-高阶函数与集合操作结合"><a href="#5-高阶函数与集合操作结合" class="headerlink" title="5. 高阶函数与集合操作结合"></a>5. 高阶函数与集合操作结合</h3><p>Kotlin 高阶函数常常与集合操作结合使用，使得集合的处理更加简洁和高效。比如链式调用 <code>map</code>、<code>filter</code>、<code>reduce</code> 等操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4, 5)</span><br><span class="line">val result = numbers.filter &#123; it % 2 == 0 &#125;</span><br><span class="line">                     .map &#123; it * it &#125;</span><br><span class="line">                     .reduce &#123; acc, i -&gt; acc + i &#125;</span><br><span class="line">println(result)  // 输出: 20</span><br></pre></td></tr></table></figure><h3 id="6-高阶函数和匿名函数的结合"><a href="#6-高阶函数和匿名函数的结合" class="headerlink" title="6. 高阶函数和匿名函数的结合"></a>6. 高阶函数和匿名函数的结合</h3><p>Kotlin 还支持匿名函数，它们和 Lambda 表达式的使用方法类似，但可以显式声明参数类型和返回类型。</p><h4 id="示例：匿名函数"><a href="#示例：匿名函数" class="headerlink" title="示例：匿名函数"></a>示例：匿名函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val sum: (Int, Int) -&gt; Int = fun(a: Int, b: Int): Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(sum(2, 3))  // 输出: 5</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>高阶函数是 Kotlin 中非常强大的功能，它让函数式编程成为可能，能够简化代码并提高可读性。Kotlin 提供了一些内建的高阶函数，如 <code>map</code>、<code>filter</code>、<code>fold</code> 等，允许你对集合和数据进行更灵活的操作。</p><ul><li><strong>接受函数作为参数</strong>：<code>map</code>, <code>filter</code>, <code>fold</code>, 等。</li><li><strong>返回函数</strong>：可以返回一个 Lambda 函数或匿名函数。</li><li><strong>结合 Lambda 表达式使用</strong>：使得代码更加简洁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin的扩展函数和运算符重载</title>
      <link href="/2025/04/06/Kotlin%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2025/04/06/Kotlin%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 的扩展函数（Extension Functions）和运算符重载（Operator Overloading）是两个强大又常用的特性，用于让代码更简洁、表达力更强。</p><hr><h2 id="✅-扩展函数（Extension-Functions）"><a href="#✅-扩展函数（Extension-Functions）" class="headerlink" title="✅ 扩展函数（Extension Functions）"></a>✅ 扩展函数（Extension Functions）</h2><p><strong>定义</strong>：在不修改原类源码的情况下，为类添加新的函数。</p><h3 id="🌟-语法"><a href="#🌟-语法" class="headerlink" title="🌟 语法"></a>🌟 语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun ClassName.functionName(params): ReturnType &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🧪-示例"><a href="#🧪-示例" class="headerlink" title="🧪 示例"></a>🧪 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun String.lastChar(): Char &#123;</span><br><span class="line">    return this[this.length - 1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val s = &quot;Hello&quot;</span><br><span class="line">    println(s.lastChar())  // 输出：&#x27;o&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="📌-注意"><a href="#📌-注意" class="headerlink" title="📌 注意"></a>📌 注意</h3><ul><li><code>this</code> 代表接收者对象（上例中是 <code>String</code>）</li><li>扩展函数<strong>不会真正修改原类</strong>，只是通过静态方式实现“扩展”</li><li>若类有成员函数与扩展函数同名，<strong>成员函数优先</strong></li></ul><hr><h2 id="➕-运算符重载（Operator-Overloading）"><a href="#➕-运算符重载（Operator-Overloading）" class="headerlink" title="➕ 运算符重载（Operator Overloading）"></a>➕ 运算符重载（Operator Overloading）</h2><p><strong>定义</strong>：通过定义带有 <code>operator</code> 关键字的函数，自定义类的运算符行为（如 <code>+</code>, <code>-</code>, <code>[]</code>, <code>==</code> 等）。</p><h3 id="🌟-支持的运算符（部分）"><a href="#🌟-支持的运算符（部分）" class="headerlink" title="🌟 支持的运算符（部分）"></a>🌟 支持的运算符（部分）</h3><table><thead><tr><th>运算符</th><th>对应函数名</th></tr></thead><tbody><tr><td><code>+</code></td><td><code>plus</code></td></tr><tr><td><code>-</code></td><td><code>minus</code></td></tr><tr><td><code>*</code></td><td><code>times</code></td></tr><tr><td><code>/</code></td><td><code>div</code></td></tr><tr><td><code>%</code></td><td><code>rem</code></td></tr><tr><td><code>==</code></td><td><code>equals</code></td></tr><tr><td><code>[]</code></td><td><code>get</code>, <code>set</code></td></tr><tr><td><code>..</code></td><td><code>rangeTo</code></td></tr><tr><td><code>in</code></td><td><code>contains</code></td></tr></tbody></table><h3 id="🧪-示例-1"><a href="#🧪-示例-1" class="headerlink" title="🧪 示例"></a>🧪 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data class Point(val x: Int, val y: Int) &#123;</span><br><span class="line">    operator fun plus(other: Point): Point &#123;</span><br><span class="line">        return Point(x + other.x, y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val p1 = Point(1, 2)</span><br><span class="line">    val p2 = Point(3, 4)</span><br><span class="line">    println(p1 + p2) // 输出：Point(x=4, y=6)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⚠️-注意"><a href="#⚠️-注意" class="headerlink" title="⚠️ 注意"></a>⚠️ 注意</h3><ul><li>需加 <code>operator</code> 关键字</li><li>Kotlin 会根据运算符自动映射到相应的函数</li></ul><hr><h2 id="✨-拓展-运算符重载的组合示例"><a href="#✨-拓展-运算符重载的组合示例" class="headerlink" title="✨ 拓展+运算符重载的组合示例"></a>✨ 拓展+运算符重载的组合示例</h2><p>你甚至可以为已有类<strong>扩展运算符函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">operator fun String.times(n: Int): String &#123;</span><br><span class="line">    return this.repeat(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;Hi! &quot; * 3) // 输出：Hi! Hi! Hi! </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延迟初始化与封装类</title>
      <link href="/2025/04/06/%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%B0%81%E8%A3%85%E7%B1%BB/"/>
      <url>/2025/04/06/%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%B0%81%E8%A3%85%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="🔹-1-延迟初始化-lateinit"><a href="#🔹-1-延迟初始化-lateinit" class="headerlink" title="🔹 1. 延迟初始化 (lateinit)"></a>🔹 1. 延迟初始化 (<code>lateinit</code>)</h2><h3 id="✅-用途："><a href="#✅-用途：" class="headerlink" title="✅ 用途："></a>✅ 用途：</h3><p>当你不想在定义变量时立刻初始化它，但又确定在使用前一定会初始化（比如依赖注入、测试、Android View 绑定等）。</p><h3 id="✅-语法："><a href="#✅-语法：" class="headerlink" title="✅ 语法："></a>✅ 语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lateinit var name: String</span><br></pre></td></tr></table></figure><h3 id="✅-注意事项："><a href="#✅-注意事项：" class="headerlink" title="✅ 注意事项："></a>✅ 注意事项：</h3><ul><li>只能用于 **<code>var</code>**，不能用于 <code>val</code>。</li><li>只能用于 <strong>非空类型的引用类型</strong>（不能是原始类型如 <code>Int</code>、<code>Double</code>）。</li><li>使用前如果没初始化，会抛出 **<code>UninitializedPropertyAccessException</code>**。</li></ul><h3 id="✅-示例："><a href="#✅-示例：" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    lateinit var nickname: String</span><br><span class="line"></span><br><span class="line">    fun initNickname() &#123;</span><br><span class="line">        nickname = &quot;KotlinFan&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun printNickname() &#123;</span><br><span class="line">        if (::nickname.isInitialized) &#123;</span><br><span class="line">            println(nickname)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println(&quot;nickname 尚未初始化&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-2-密封类（sealed-class）"><a href="#🔹-2-密封类（sealed-class）" class="headerlink" title="🔹 2. 密封类（sealed class）"></a>🔹 2. 密封类（<code>sealed class</code>）</h2><h3 id="✅-用途：-1"><a href="#✅-用途：-1" class="headerlink" title="✅ 用途："></a>✅ 用途：</h3><p>用于表示<strong>受限的类继承结构</strong>，所有子类都必须声明在同一个文件中。常用于表示状态、结果、事件等。</p><p>类似于 Java 的 <code>enum</code>，但可以携带数据。常配合 <code>when</code> 表达式使用，可以 <strong>无需 else</strong> 分支。</p><h3 id="✅-示例：-1"><a href="#✅-示例：-1" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sealed class Result</span><br><span class="line"></span><br><span class="line">data class Success(val data: String) : Result()</span><br><span class="line">data class Error(val message: String) : Result()</span><br><span class="line">object Loading : Result()</span><br><span class="line"></span><br><span class="line">fun handleResult(result: Result) &#123;</span><br><span class="line">    when (result) &#123;</span><br><span class="line">        is Success -&gt; println(&quot;成功: $&#123;result.data&#125;&quot;)</span><br><span class="line">        is Error -&gt; println(&quot;失败: $&#123;result.message&#125;&quot;)</span><br><span class="line">        Loading -&gt; println(&quot;加载中...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔸-总结对比"><a href="#🔸-总结对比" class="headerlink" title="🔸 总结对比"></a>🔸 总结对比</h2><table><thead><tr><th>特性</th><th><code>lateinit</code></th><th><code>sealed class</code></th></tr></thead><tbody><tr><td>用途</td><td>延迟初始化引用变量</td><td>表示受限的继承结构，常用于状态建模</td></tr><tr><td>限制</td><td>不能用于 <code>val</code> 或基本类型</td><td>所有子类必须在同一文件中定义</td></tr><tr><td>常用场景</td><td>Android View、依赖注入等</td><td>网络请求结果、UI状态、表达式分支等</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin lambda编程</title>
      <link href="/2025/03/28/kotlin%20lambda/"/>
      <url>/2025/03/28/kotlin%20lambda/</url>
      
        <content type="html"><![CDATA[<h1 id="kotlin-lambda编程"><a href="#kotlin-lambda编程" class="headerlink" title="kotlin lambda编程"></a>kotlin lambda编程</h1><p>Kotlin 的 Lambda（匿名函数）是函数式编程的核心特性之一，允许你以简洁的方式编写代码，尤其适用于集合操作、回调、DSL（领域特定语言）等场景。</p><h2 id="1-Lambda-表达式基础"><a href="#1-Lambda-表达式基础" class="headerlink" title="1. Lambda 表达式基础"></a>1. Lambda 表达式基础</h2><p>Lambda 表达式是一个匿名函数，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val sum: (Int, Int) -&gt; Int = &#123; a, b -&gt; a + b &#125;</span><br><span class="line">println(sum(2, 3)) // 输出 5</span><br></pre></td></tr></table></figure><p><strong>语法说明</strong>：</p><ul><li><code>&#123; 参数1, 参数2 -&gt; 函数体 &#125;</code></li><li><code>val sum: (Int, Int) -&gt; Int</code> 明确声明了函数类型，表示它接收两个 <code>Int</code> 并返回 <code>Int</code>。</li></ul><h2 id="2-使用-it-关键字"><a href="#2-使用-it-关键字" class="headerlink" title="2. 使用 it 关键字"></a>2. 使用 <code>it</code> 关键字</h2><p>当 Lambda 只有一个参数时，可以用 <code>it</code> 代替参数名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val square: (Int) -&gt; Int = &#123; it * it &#125;</span><br><span class="line">println(square(4)) // 输出 16</span><br></pre></td></tr></table></figure><h2 id="3-Lambda-作为函数参数"><a href="#3-Lambda-作为函数参数" class="headerlink" title="3. Lambda 作为函数参数"></a>3. Lambda 作为函数参数</h2><p>Lambda 可以作为参数传递给函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun operateOnNumbers(a: Int, b: Int, operation: (Int, Int) -&gt; Int): Int &#123;</span><br><span class="line">    return operation(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val result = operateOnNumbers(4, 5) &#123; x, y -&gt; x * y &#125;</span><br><span class="line">println(result) // 输出 20</span><br></pre></td></tr></table></figure><h2 id="4-高阶函数-结合-Lambda"><a href="#4-高阶函数-结合-Lambda" class="headerlink" title="4. 高阶函数 结合 Lambda"></a>4. <code>高阶函数</code> 结合 Lambda</h2><p>Kotlin 支持高阶函数（即参数或返回值是函数的函数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun higherOrderFunction(operation: () -&gt; Unit) &#123;</span><br><span class="line">    operation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">higherOrderFunction &#123; println(&quot;Hello, Lambda!&quot;) &#125;</span><br></pre></td></tr></table></figure><h2 id="5-在集合操作中的应用"><a href="#5-在集合操作中的应用" class="headerlink" title="5. 在集合操作中的应用"></a>5. 在集合操作中的应用</h2><p>Lambda 在 Kotlin 的集合 API 中应用广泛，如 <code>map</code>、<code>filter</code>、<code>reduce</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4, 5)</span><br><span class="line">val squaredNumbers = numbers.map &#123; it * it &#125;</span><br><span class="line">println(squaredNumbers) // 输出 [1, 4, 9, 16, 25]</span><br><span class="line"></span><br><span class="line">val evenNumbers = numbers.filter &#123; it % 2 == 0 &#125;</span><br><span class="line">println(evenNumbers) // 输出 [2, 4]</span><br></pre></td></tr></table></figure><h2 id="6-let、apply、run、with、also"><a href="#6-let、apply、run、with、also" class="headerlink" title="6. let、apply、run、with、also"></a>6. <code>let</code>、<code>apply</code>、<code>run</code>、<code>with</code>、<code>also</code></h2><p>Kotlin 提供了一系列作用域函数，结合 Lambda 使用非常强大：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val name: String? = &quot;Kotlin&quot;</span><br><span class="line">name?.let &#123; println(it.uppercase()) &#125; // 非空时执行</span><br><span class="line"></span><br><span class="line">val person = Person(&quot;John&quot;).apply &#123; age = 30 &#125; // apply 适用于修改对象属性</span><br><span class="line">println(person)</span><br></pre></td></tr></table></figure><h2 id="7-闭包（Closure）"><a href="#7-闭包（Closure）" class="headerlink" title="7. 闭包（Closure）"></a>7. 闭包（Closure）</h2><p>Lambda 表达式可以访问外部变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun counter(): () -&gt; Int &#123;</span><br><span class="line">    var count = 0</span><br><span class="line">    return &#123; count++ &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val next = counter()</span><br><span class="line">println(next()) // 0</span><br><span class="line">println(next()) // 1</span><br><span class="line">println(next()) // 2</span><br></pre></td></tr></table></figure><h2 id="8-带-return-的-Lambda"><a href="#8-带-return-的-Lambda" class="headerlink" title="8. 带 return 的 Lambda"></a>8. 带 <code>return</code> 的 Lambda</h2><p>Lambda 默认返回最后一行的值，如果需要提前返回，可以使用 <code>return@label</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listOf(1, 2, 3, 4, 5).forEach &#123; </span><br><span class="line">    if (it == 3) return@forEach </span><br><span class="line">    println(it) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intent</title>
      <link href="/2025/03/28/%E6%98%BE%E5%BC%8FIntent%E4%B8%8E%E9%9A%90%E5%BC%8FIntent/"/>
      <url>/2025/03/28/%E6%98%BE%E5%BC%8FIntent%E4%B8%8E%E9%9A%90%E5%BC%8FIntent/</url>
      
        <content type="html"><![CDATA[<p>显式Intent与隐式Intent</p><h6 id="ChatGPT-说："><a href="#ChatGPT-说：" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>在 Android 中，<strong>Intent（意图）</strong> 是组件（Activity、Service、BroadcastReceiver）之间进行通信的机制。Intent 主要分为两种类型：</p><h3 id="1-显式-Intent（Explicit-Intent）"><a href="#1-显式-Intent（Explicit-Intent）" class="headerlink" title="1. 显式 Intent（Explicit Intent）"></a><strong>1. 显式 Intent（Explicit Intent）</strong></h3><p>显式 Intent 直接指定目标组件（Activity、Service）的 <strong>类名</strong>，用于在 <strong>应用内部</strong> 启动组件。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(this, SecondActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li><strong>适用于应用内部</strong> 组件间的交互，比如从 <code>MainActivity</code> 跳转到 <code>SecondActivity</code>。</li><li><strong>指定目标类名</strong>，不会让系统去匹配 <code>intent-filter</code>。</li><li><strong>性能更高</strong>，因为不需要系统查找匹配的组件。</li></ul><hr><h3 id="2-隐式-Intent（Implicit-Intent）"><a href="#2-隐式-Intent（Implicit-Intent）" class="headerlink" title="2. 隐式 Intent（Implicit Intent）"></a><strong>2. 隐式 Intent（Implicit Intent）</strong></h3><p>隐式 Intent <strong>不指定</strong> 目标组件的类名，而是使用 <strong>动作（Action）、类别（Category）、数据（Data）</strong> 让系统找到符合条件的组件。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><p>打开网页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(Uri.parse(&quot;https://www.example.com&quot;));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>拨打电话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(Intent.ACTION_DIAL);</span><br><span class="line">intent.setData(Uri.parse(&quot;tel:123456789&quot;));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li><p><strong>适用于调用其他应用的功能</strong>，例如打开浏览器、拨号、分享文本等。</p></li><li><p>需要在 <code>AndroidManifest.xml</code> 中声明 <code>intent-filter</code>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.ThirdActivity&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">        &lt;data android:scheme=&quot;https&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>系统会自动匹配</strong> 适合的应用来处理这个 Intent。</p></li></ul><hr><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a><strong>对比总结</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>显式 Intent</strong></th><th><strong>隐式 Intent</strong></th></tr></thead><tbody><tr><td><strong>目标组件</strong></td><td><strong>明确指定</strong> 类名，如 <code>SecondActivity.class</code></td><td><strong>不指定</strong> 类名，使用 <code>Action + Data</code> 让系统匹配</td></tr><tr><td><strong>适用场景</strong></td><td>应用内部跳转，如 <code>ActivityA → ActivityB</code></td><td>调用系统&#x2F;其他应用功能，如打开网页、拨打电话</td></tr><tr><td><strong>匹配方式</strong></td><td><strong>直接找到组件</strong> 并启动</td><td><strong>系统匹配 <code>intent-filter</code></strong> 找到合适的组件</td></tr><tr><td><strong>性能</strong></td><td><strong>更快</strong>，因为不需要匹配</td><td><strong>稍慢</strong>，需要查询可能的匹配组件</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> android主要组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android主要组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空指针检查</title>
      <link href="/2025/03/28/%E7%A9%BA%E6%8C%87%E9%92%88%E6%A3%80%E6%9F%A5/"/>
      <url>/2025/03/28/%E7%A9%BA%E6%8C%87%E9%92%88%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 通过 <strong>空安全（Null Safety）</strong> 机制减少了空指针异常（NullPointerException，NPE）。以下是 Kotlin 中处理空指针的常见方式：</p><hr><h3 id="1-可空类型"><a href="#1-可空类型" class="headerlink" title="1. 可空类型 (?)"></a>1. <strong>可空类型 (<code>?</code>)</strong></h3><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251126223421829.png" alt="image-20251126223421759"></p><p>Kotlin 默认所有变量都不能为空。如果需要允许 <code>null</code>，必须显式声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = &quot;Kotlin&quot;</span><br><span class="line">name = null  // 允许赋值 null</span><br></pre></td></tr></table></figure><hr><h3 id="2-安全调用"><a href="#2-安全调用" class="headerlink" title="2. 安全调用 (?.)"></a>2. <strong>安全调用 (<code>?.</code>)</strong></h3><p>当变量可能为 <code>null</code> 时，可以使用 <strong>安全调用</strong> 来避免 NPE：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val length: Int? = name?.length  // name 为 null 时，length 也为 null</span><br></pre></td></tr></table></figure><hr><h3 id="3-Elvis-运算符"><a href="#3-Elvis-运算符" class="headerlink" title="3. Elvis 运算符 (?:)"></a>3. <strong>Elvis 运算符 (<code>?:</code>)</strong></h3><p>提供默认值，避免 <code>null</code> 影响程序逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val length: Int = name?.length ?: 0  // name 为 null 时，length 取 0</span><br></pre></td></tr></table></figure><hr><h3 id="4-非空断言"><a href="#4-非空断言" class="headerlink" title="4. 非空断言 (!!)"></a>4. <strong>非空断言 (<code>!!</code>)</strong></h3><p>强制告诉编译器变量不为空，否则抛出 <code>NullPointerException</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val length: Int = name!!.length  // 如果 name 为空，则抛出 NPE</span><br></pre></td></tr></table></figure><p>⚠ <strong>慎用 <code>!!</code>，仅在明确不为空时使用！</strong></p><hr><h3 id="5-let-作用域函数"><a href="#5-let-作用域函数" class="headerlink" title="5. let 作用域函数"></a>5. <strong><code>let</code> 作用域函数</strong></h3><p><code>let</code> 结合安全调用 (<code>?.</code>)，可用于在非空时执行某些操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name?.let &#123;</span><br><span class="line">    println(&quot;Length: $&#123;it.length&#125;&quot;)  // 仅当 name 不为空时执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-lateinit-和-by-lazy"><a href="#6-lateinit-和-by-lazy" class="headerlink" title="6. lateinit 和 by lazy"></a>6. <strong><code>lateinit</code> 和 <code>by lazy</code></strong></h3><ul><li><p><code>lateinit</code> 适用于非 <code>null</code> 类型的延迟初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lateinit var text: String</span><br><span class="line">// text.length // 若未初始化，访问会抛出 UninitializedPropertyAccessException</span><br></pre></td></tr></table></figure></li><li><p><code>lazy</code> 适用于 <code>val</code> 类型的惰性初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val message: String by lazy &#123; &quot;Hello, Kotlin!&quot; &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-requireNotNull-和-checkNotNull"><a href="#7-requireNotNull-和-checkNotNull" class="headerlink" title="7. requireNotNull 和 checkNotNull"></a>7. <strong><code>requireNotNull</code> 和 <code>checkNotNull</code></strong></h3><p>手动检查 <code>null</code> 并抛出异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val nonNullName: String = requireNotNull(name) &#123; &quot;name 不能为空&quot; &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-数据类默认值"><a href="#8-数据类默认值" class="headerlink" title="8. 数据类默认值"></a>8. <strong>数据类默认值</strong></h3><p>如果某个字段可能为空，最好提供默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">data class User(val name: String = &quot;Unknown&quot;)</span><br></pre></td></tr></table></figure><hr><h3 id="9-平台类型-Java-互操作"><a href="#9-平台类型-Java-互操作" class="headerlink" title="9. 平台类型 (Java 互操作)"></a>9. <strong>平台类型 (<code>Java</code> 互操作)</strong></h3><p>从 Java 代码获取的变量可能为空，Kotlin 不能自动推断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val text: String? = javaMethodReturningNullable()  // Java 方法返回值可能为 null</span><br></pre></td></tr></table></figure><hr><h3 id="10-使用-Nullable-和-NotNull-注解"><a href="#10-使用-Nullable-和-NotNull-注解" class="headerlink" title="10. 使用 @Nullable 和 @NotNull 注解"></a>10. <strong>使用 <code>@Nullable</code> 和 <code>@NotNull</code> 注解</strong></h3><p>在 Kotlin 互操作 Java 时，可以使用这些注解来增强类型安全：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">public String getNullableString() &#123; return null; &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>方式</th><th>作用</th></tr></thead><tbody><tr><td><code>?</code></td><td>允许 <code>null</code></td></tr><tr><td><code>?.</code></td><td>安全调用</td></tr><tr><td><code>?:</code></td><td>默认值</td></tr><tr><td><code>!!</code></td><td>非空断言（可能抛 NPE）</td></tr><tr><td><code>let</code></td><td>仅在非空时执行</td></tr><tr><td><code>lateinit</code> &#x2F; <code>lazy</code></td><td>延迟初始化</td></tr><tr><td><code>requireNotNull</code></td><td>手动 <code>null</code> 检查</td></tr><tr><td><code>@Nullable</code></td><td>Java 互操作</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
