<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>抽象类与接口</title>
      <link href="/2025/07/02/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2025/07/02/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、抽象类（Abstract-Class）"><a href="#一、抽象类（Abstract-Class）" class="headerlink" title="一、抽象类（Abstract Class）"></a>一、抽象类（Abstract Class）</h2><h3 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title="1. 基本特性"></a>1. 基本特性</h3><ul><li>使用<code>abstract</code>关键字声明</li><li>可以包含抽象方法和具体方法</li><li>不能直接实例化（不能new）</li><li>可以包含成员变量、构造方法、普通方法</li></ul><h3 id="2-语法结构"><a href="#2-语法结构" class="headerlink" title="2. 语法结构"></a>2. 语法结构</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line">    // 成员变量</span><br><span class="line">    protected String name;</span><br><span class="line">    </span><br><span class="line">    // 构造方法</span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 抽象方法（无实现）</span><br><span class="line">    public abstract void makeSound();</span><br><span class="line">    </span><br><span class="line">    // 具体方法</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(name + &quot;正在吃东西&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用要点"><a href="#3-使用要点" class="headerlink" title="3. 使用要点"></a>3. 使用要点</h3><ul><li><strong>抽象方法</strong>：没有方法体，必须用<code>abstract</code>修饰</li><li><strong>子类要求</strong>：非抽象子类必须实现所有抽象方法</li><li><strong>构造方法</strong>：虽然不能实例化，但可以有构造方法供子类调用</li><li><strong>访问控制</strong>：抽象方法不能用private修饰（因为需要子类实现）</li></ul><h3 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h3><ul><li>多个相关类共享代码和关系</li><li>需要定义子类的共同行为规范</li><li>需要包含非public的成员和方法</li><li>需要定义非static、非final的成员变量</li></ul><h2 id="二、接口（Interface）"><a href="#二、接口（Interface）" class="headerlink" title="二、接口（Interface）"></a>二、接口（Interface）</h2><h3 id="1-基本特性-1"><a href="#1-基本特性-1" class="headerlink" title="1. 基本特性"></a>1. 基本特性</h3><ul><li>Java 7及以前：纯抽象（只有抽象方法）</li><li>Java 8开始：支持默认方法（default）和静态方法</li><li>Java 9开始：支持私有方法</li><li>不能包含实例字段（只能是static final常量）</li><li>不能有构造方法</li></ul><h3 id="2-语法演进"><a href="#2-语法演进" class="headerlink" title="2. 语法演进"></a>2. 语法演进</h3><h4 id="Java-7及以前"><a href="#Java-7及以前" class="headerlink" title="Java 7及以前"></a>Java 7及以前</h4><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Flyable &#123;</span><br><span class="line">    // 常量（默认public static final）</span><br><span class="line">    int MAX_HEIGHT = 10000;</span><br><span class="line">    </span><br><span class="line">    // 抽象方法（默认public abstract）</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8+"></a>Java 8+</h4><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface SmartDevice &#123;</span><br><span class="line">    // 抽象方法</span><br><span class="line">    void turnOn();</span><br><span class="line">    </span><br><span class="line">    // 默认方法</span><br><span class="line">    default void updateFirmware() &#123;</span><br><span class="line">        System.out.println(&quot;执行默认固件更新&quot;);</span><br><span class="line">        privateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 静态方法</span><br><span class="line">    static void showVersion() &#123;</span><br><span class="line">        System.out.println(&quot;智能设备接口v2.0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Java 9私有方法</span><br><span class="line">    private void privateMethod() &#123;</span><br><span class="line">        System.out.println(&quot;私有方法执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用要点-1"><a href="#3-使用要点-1" class="headerlink" title="3. 使用要点"></a>3. 使用要点</h3><ul><li><strong>实现要求</strong>：类实现接口必须实现所有抽象方法（默认方法可选）</li><li><strong>多继承</strong>：一个类可以实现多个接口</li><li><strong>接口继承</strong>：接口可以继承多个其他接口</li><li><strong>默认冲突</strong>：当多个接口有相同默认方法时，实现类必须重写</li></ul><h3 id="4-适用场景-1"><a href="#4-适用场景-1" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h3><ul><li>定义不相关类的共同行为</li><li>需要多重继承的场景</li><li>作为API的定义规范</li><li>需要定义回调函数（如EventListener）</li></ul><h2 id="三、抽象类与接口对比"><a href="#三、抽象类与接口对比" class="headerlink" title="三、抽象类与接口对比"></a>三、抽象类与接口对比</h2><table><thead><tr><th align="left">特性</th><th align="left">抽象类</th><th align="left">接口</th></tr></thead><tbody><tr><td align="left"><strong>关键字</strong></td><td align="left">abstract class</td><td align="left">interface</td></tr><tr><td align="left"><strong>方法类型</strong></td><td align="left">抽象方法+具体方法</td><td align="left">Java 8前只有抽象方法，之后有默认方法和静态方法</td></tr><tr><td align="left"><strong>变量</strong></td><td align="left">可以有各种成员变量</td><td align="left">只能是public static final常量</td></tr><tr><td align="left"><strong>构造方法</strong></td><td align="left">有</td><td align="left">没有</td></tr><tr><td align="left"><strong>继承&#x2F;实现</strong></td><td align="left">单继承（extends）</td><td align="left">多实现（implements）</td></tr><tr><td align="left"><strong>设计目的</strong></td><td align="left">代码复用和层次化设计</td><td align="left">定义行为规范和能力</td></tr><tr><td align="left"><strong>访问控制</strong></td><td align="left">可以是任意访问修饰符</td><td align="left">默认public（不能是protected&#x2F;private）</td></tr><tr><td align="left"><strong>多态支持</strong></td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left"><strong>JDK版本影响</strong></td><td align="left">不受影响</td><td align="left">功能随版本增强</td></tr></tbody></table><h2 id="四、选择原则"><a href="#四、选择原则" class="headerlink" title="四、选择原则"></a>四、选择原则</h2><ol><li><p><strong>使用抽象类当</strong>：</p><ul><li>多个相关类需要共享代码</li><li>需要定义非public的成员</li><li>需要定义非static、非final的字段</li><li>需要定义构造方法逻辑</li></ul></li><li><p><strong>使用接口当</strong>：</p><ul><li>不相关的类需要实现相同的行为</li><li>需要多重继承</li><li>只关注行为规范而非实现</li><li>作为API定义供他人实现</li></ul></li><li><p><strong>组合使用</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 抽象类提供基础实现</span><br><span class="line">abstract class Bird extends Animal implements Flyable &#123;</span><br><span class="line">    // 既继承Animal的特性，又实现Flyable的能力</span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;用翅膀飞行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="五、最新发展（Java-8-17）"><a href="#五、最新发展（Java-8-17）" class="headerlink" title="五、最新发展（Java 8-17）"></a>五、最新发展（Java 8-17）</h2><ol><li><strong>接口的增强</strong>：<ul><li>默认方法（解决接口演化问题）</li><li>静态方法（工具方法）</li><li>私有方法（Java 9，代码复用）</li></ul></li><li><strong>接口与抽象类的界限模糊</strong>：<ul><li>接口现在也可以有方法实现</li><li>但接口仍然不能有实例状态（成员变量）</li></ul></li><li><strong>record类与sealed类</strong>：<ul><li>Java 14引入record（数据载体）</li><li>Java 15引入sealed类（受限继承）</li><li>这些新特性与抽象类&#x2F;接口形成互补</li></ul></li></ol><h2 id="六、设计模式中的应用"><a href="#六、设计模式中的应用" class="headerlink" title="六、设计模式中的应用"></a>六、设计模式中的应用</h2><ol><li><p><strong>模板方法模式</strong>（抽象类典型应用）：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract class Game &#123;</span><br><span class="line">    abstract void initialize();</span><br><span class="line">    abstract void startPlay();</span><br><span class="line">    </span><br><span class="line">    // 模板方法</span><br><span class="line">    public final void play() &#123;</span><br><span class="line">        initialize();</span><br><span class="line">        startPlay();</span><br><span class="line">        endPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>策略模式</strong>（接口典型应用）：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface PaymentStrategy &#123;</span><br><span class="line">    void pay(int amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CreditCardPayment implements PaymentStrategy &#123;</span><br><span class="line">    public void pay(int amount) &#123; /*...*/ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>适配器模式</strong>（结合使用）：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Target &#123;</span><br><span class="line">    void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Adapter implements Target &#123;</span><br><span class="line">    public void request() &#123; /* 默认实现 */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>掌握抽象类和接口的区别与适用场景，是Java面向对象设计的重要基础。随着Java版本的更新，两者的功能都在不断增强，但核心设计理念保持不变：抽象类侧重于”是什么”，接口侧重于”能做什么”。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承与多态总结</title>
      <link href="/2025/07/01/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E6%80%BB%E7%BB%93/"/>
      <url>/2025/07/01/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="继承与多态核心知识点总结"><a href="#继承与多态核心知识点总结" class="headerlink" title="继承与多态核心知识点总结"></a>继承与多态核心知识点总结</h1><h2 id="1-继承-Inheritance"><a href="#1-继承-Inheritance" class="headerlink" title="1. 继承 (Inheritance)"></a>1. 继承 (Inheritance)</h2><p><strong>概念</strong>：</p><ul><li>允许一个类(子类)继承另一个类(父类)的特征和行为</li><li>子类可以获得父类的属性和方法，并可以添加新的属性和方法</li></ul><p><strong>语法</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">    // 子类特有的属性和方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ol><li>Java是单继承，一个类只能直接继承一个父类</li><li>子类继承父类非private的成员(属性和方法)</li><li>子类可以重写(override)父类的方法</li><li>构造方法不能被继承</li></ol><p><strong>关键字</strong>：</p><ul><li><code>extends</code>：表示继承关系</li><li><code>super</code>：引用父类的成员<ul><li><code>super()</code>：调用父类构造方法</li><li><code>super.方法名()</code>：调用父类方法</li></ul></li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(name + &quot;正在吃东西&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    String breed;</span><br><span class="line">    </span><br><span class="line">    public Dog(String name, String breed) &#123;</span><br><span class="line">        super(name); // 调用父类构造方法</span><br><span class="line">        this.breed = breed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        super.eat(); // 调用父类方法</span><br><span class="line">        System.out.println(name + &quot;正在吃狗粮&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void bark() &#123;</span><br><span class="line">        System.out.println(name + &quot;汪汪叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-多态-Polymorphism"><a href="#2-多态-Polymorphism" class="headerlink" title="2. 多态 (Polymorphism)"></a>2. 多态 (Polymorphism)</h2><p><strong>概念</strong>：</p><ul><li>同一操作作用于不同对象，可以有不同的解释，产生不同的执行结果</li><li>主要包括编译时多态(方法重载)和运行时多态(方法重写)</li></ul><p><strong>实现条件</strong>：</p><ol><li>继承关系</li><li>方法重写</li><li>父类引用指向子类对象</li></ol><p><strong>表现形式</strong>：</p><ol><li>方法重载(Overload) - 编译时多态<ul><li>同一个类中，方法名相同，参数列表不同</li></ul></li><li>方法重写(Override) - 运行时多态<ul><li>子类中定义与父类相同签名的方法</li></ul></li></ol><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 方法重载示例</span><br><span class="line">class Calculator &#123;</span><br><span class="line">    public int add(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public double add(double a, double b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法重写(多态)示例</span><br><span class="line">class Animal &#123;</span><br><span class="line">    public void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;动物发出声音&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;喵喵叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;汪汪叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal myAnimal = new Animal();  // Animal对象</span><br><span class="line">        Animal myCat = new Cat();       // Cat对象</span><br><span class="line">        Animal myDog = new Dog();        // Dog对象</span><br><span class="line">        </span><br><span class="line">        myAnimal.makeSound();  // 输出: 动物发出声音</span><br><span class="line">        myCat.makeSound();    // 输出: 喵喵叫</span><br><span class="line">        myDog.makeSound();     // 输出: 汪汪叫</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-继承与多态的重要特性"><a href="#3-继承与多态的重要特性" class="headerlink" title="3. 继承与多态的重要特性"></a>3. 继承与多态的重要特性</h2><h3 id="3-1-方法重写-Override-规则"><a href="#3-1-方法重写-Override-规则" class="headerlink" title="3.1 方法重写(Override)规则"></a>3.1 方法重写(Override)规则</h3><ol><li>方法名和参数列表必须完全相同</li><li>返回类型可以是父类方法返回类型的子类(协变返回类型)</li><li>访问权限不能比父类方法更严格</li><li>不能重写private、final和static方法</li><li>重写方法可以抛出与父类方法相同的异常或不抛出异常或抛出父类异常的子类异常</li></ol><h3 id="3-2-向上转型-Upcasting-和向下转型-Downcasting"><a href="#3-2-向上转型-Upcasting-和向下转型-Downcasting" class="headerlink" title="3.2 向上转型(Upcasting)和向下转型(Downcasting)"></a>3.2 向上转型(Upcasting)和向下转型(Downcasting)</h3><ul><li><p><strong>向上转型</strong>：子类对象赋值给父类引用(自动转换)</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = new Dog(); // 向上转型</span><br></pre></td></tr></table></figure></li><li><p><strong>向下转型</strong>：父类引用强制转换为子类引用(需要显式转换)</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = (Dog)animal; // 向下转型</span><br></pre></td></tr></table></figure></li></ul><p><strong>instanceof运算符</strong>：<br>用于检查对象是否是特定类的实例，常用于向下转型前的安全检查</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (animal instanceof Dog) &#123;</span><br><span class="line">    Dog dog = (Dog)animal;</span><br><span class="line">    dog.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-抽象类与多态"><a href="#3-3-抽象类与多态" class="headerlink" title="3.3 抽象类与多态"></a>3.3 抽象类与多态</h3><ul><li>抽象类不能实例化，只能被继承</li><li>抽象方法没有方法体，必须在子类中实现</li><li>抽象类可以包含普通方法和抽象方法</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">abstract class Shape &#123;</span><br><span class="line">    abstract double area(); // 抽象方法</span><br><span class="line">    </span><br><span class="line">    void display() &#123;        // 普通方法</span><br><span class="line">        System.out.println(&quot;这是一个形状&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle extends Shape &#123;</span><br><span class="line">    double radius;</span><br><span class="line">    </span><br><span class="line">    Circle(double r) &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    double area() &#123;</span><br><span class="line">        return Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle extends Shape &#123;</span><br><span class="line">    double length, width;</span><br><span class="line">    </span><br><span class="line">    Rectangle(double l, double w) &#123;</span><br><span class="line">        length = l;</span><br><span class="line">        width = w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    double area() &#123;</span><br><span class="line">        return length * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-接口与多态"><a href="#3-4-接口与多态" class="headerlink" title="3.4 接口与多态"></a>3.4 接口与多态</h3><ul><li>接口是完全抽象的类，所有方法默认是public abstract</li><li>类可以实现多个接口</li><li>接口可以多继承其他接口</li><li>Java 8后接口可以有默认方法和静态方法</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">interface Flyable &#123;</span><br><span class="line">    void fly(); // 抽象方法</span><br><span class="line">    </span><br><span class="line">    default void land() &#123; // 默认方法</span><br><span class="line">        System.out.println(&quot;正在着陆&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static int getMaxAltitude() &#123; // 静态方法</span><br><span class="line">        return 10000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Swimmable &#123;</span><br><span class="line">    void swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Duck implements Flyable, Swimmable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;鸭子飞起来了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line">        System.out.println(&quot;鸭子在游泳&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-继承与多态的应用场景"><a href="#4-继承与多态的应用场景" class="headerlink" title="4. 继承与多态的应用场景"></a>4. 继承与多态的应用场景</h2><ol><li><strong>代码复用</strong>：通过继承复用父类代码</li><li><strong>扩展功能</strong>：子类可以在继承的基础上添加新功能</li><li><strong>统一接口</strong>：多态允许不同类型的对象响应相同的消息</li><li><strong>框架设计</strong>：通过抽象类和接口定义框架，具体实现由子类完成</li><li><strong>插件架构</strong>：通过接口定义标准，具体实现可以动态加载</li></ol><h2 id="5-tips"><a href="#5-tips" class="headerlink" title="5.tips"></a>5.tips</h2><p>import lombok.AllArgsConstructor:<br>import lombok.Data;<br>import lombok.NoArgsConstructor;<br>&#x2F;&#x2F; lombok技术可以实现为类自动添加getter setter方法无参数构造器，toString方法等</p><p>@Data &#x2F;&#x2F; @Data注解可以自动生成getter setter方法无参构造器 toString方法等</p><p>@NoArgsConstructor</p><p>@AllArgsConstructor</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面向对象编程基础语法</title>
      <link href="/2025/07/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/07/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面向对象编程基础语法"><a href="#Java面向对象编程基础语法" class="headerlink" title="Java面向对象编程基础语法"></a>Java面向对象编程基础语法</h1><h2 id="1-对象-Object"><a href="#1-对象-Object" class="headerlink" title="1. 对象 (Object)"></a>1. 对象 (Object)</h2><p><strong>概念</strong>：</p><ul><li>对象是类的实例，是面向对象编程的基本单位</li><li>对象具有状态(属性)和行为(方法)</li><li>对象在内存中占据独立的空间</li></ul><p><strong>特点</strong>：</p><ul><li>每个对象都有唯一的标识(内存地址)</li><li>对象之间通过消息传递进行交互</li><li>对象是类的具体实现</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = new Person(); // person1是一个Person类的对象</span><br></pre></td></tr></table></figure><h2 id="2-封装-Encapsulation"><a href="#2-封装-Encapsulation" class="headerlink" title="2. 封装 (Encapsulation)"></a>2. 封装 (Encapsulation)</h2><p><strong>概念</strong>：</p><ul><li>将数据(属性)和行为(方法)包装在一个单元(类)中</li><li>隐藏对象的内部实现细节，仅暴露必要的接口</li></ul><p><strong>实现方式</strong>：</p><ul><li>使用访问修饰符控制可见性：<ul><li><code>private</code>：仅本类可见</li><li><code>protected</code>：本包和子类可见</li><li><code>public</code>：所有类可见</li><li>(默认)：本包可见</li></ul></li></ul><p><strong>优点</strong>：</p><ul><li>提高代码安全性</li><li>降低耦合度</li><li>便于修改和维护</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BankAccount &#123;</span><br><span class="line">    private double balance; // 私有属性，外部不可直接访问</span><br><span class="line">    </span><br><span class="line">    // 公有方法，提供受控的访问方式</span><br><span class="line">    public void deposit(double amount) &#123;</span><br><span class="line">        if(amount &gt; 0) &#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public double getBalance() &#123;</span><br><span class="line">        return balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-构造器-Constructor"><a href="#3-构造器-Constructor" class="headerlink" title="3. 构造器 (Constructor)"></a>3. 构造器 (Constructor)</h2><p><strong>概念</strong>：</p><ul><li>一种特殊的方法，用于创建和初始化对象</li><li>方法名与类名相同，没有返回类型(连void也没有)</li></ul><p><strong>特点</strong>：</p><ul><li>在创建对象时自动调用(new时)</li><li>可以重载(多个不同参数的构造器)</li><li>如果没有显式定义构造器，编译器会提供默认无参构造器</li><li>一旦定义了构造器，默认构造器就不再自动提供</li></ul><p><strong>分类</strong>：</p><ol><li>无参构造器</li><li>带参构造器</li></ol><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    // 无参构造器</span><br><span class="line">    public Person() &#123;</span><br><span class="line">        this.name = &quot;未知&quot;;</span><br><span class="line">        this.age = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 带参构造器</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-this关键字"><a href="#4-this关键字" class="headerlink" title="4. this关键字"></a>4. this关键字</h2><p><strong>作用</strong>：</p><ol><li>指代当前对象</li><li>在构造器中调用其他构造器(必须放在第一行)</li><li>区分成员变量和局部变量</li></ol><p><strong>使用场景</strong>：</p><ul><li>当局部变量与成员变量同名时</li><li>在方法中需要返回当前对象时</li><li>在构造器中调用其他构造器时</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int score;</span><br><span class="line">    </span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this(name, 0); // 调用另一个构造器</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Student(String name, int score) &#123;</span><br><span class="line">        this.name = name; // 区分成员变量和参数</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Student getCurrentObject() &#123;</span><br><span class="line">        return this; // 返回当前对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-封装-Encapsulation-补充说明"><a href="#5-封装-Encapsulation-补充说明" class="headerlink" title="5. 封装 (Encapsulation) - 补充说明"></a>5. 封装 (Encapsulation) - 补充说明</h2><p><strong>封装的核心原则</strong>：</p><ul><li>将数据和对数据的操作绑定在一起</li><li>对外隐藏实现细节，只暴露必要的接口</li><li>通过访问控制实现信息隐藏</li></ul><p><strong>封装的具体实现</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    // 私有属性 - 实现封装</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private double score;</span><br><span class="line">    </span><br><span class="line">    // 公开的getter方法 - 提供受控的读访问</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 公开的setter方法 - 提供受控的写访问</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        if(name != null &amp;&amp; !name.isEmpty()) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他业务方法</span><br><span class="line">    public void printInfo() &#123;</span><br><span class="line">        System.out.println(&quot;姓名：&quot; + name + &quot;，年龄：&quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装的好处</strong>：</p><ol><li>防止外部代码随意修改对象内部状态</li><li>可以在setter方法中添加验证逻辑</li><li>修改内部实现不影响外部代码</li><li>提高代码的可维护性和安全性</li></ol><h2 id="6-实体类-Entity-Class"><a href="#6-实体类-Entity-Class" class="headerlink" title="6. 实体类 (Entity Class)"></a>6. 实体类 (Entity Class)</h2><p><strong>概念</strong>：</p><ul><li>用于表示现实世界中的实体或概念的类</li><li>通常对应数据库中的表或业务领域中的对象</li></ul><p><strong>实体类特点</strong>：</p><ol><li>主要包含属性和对应的getter&#x2F;setter方法</li><li>通常实现Serializable接口以支持序列化</li><li>可能包含简单的业务逻辑方法</li><li>一般会重写equals()、hashCode()和toString()方法</li></ol><p><strong>典型实体类示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    // 属性</span><br><span class="line">    private Long id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private Date createTime;</span><br><span class="line">    </span><br><span class="line">    // 构造方法</span><br><span class="line">    public User() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public User(String username, String password) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.createTime = new Date();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // getter和setter</span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他方法...</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, username=&#x27;&quot; + username + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, createTime=&quot; + createTime +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        // 实现equals方法...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        // 实现hashCode方法...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实体类的使用场景</strong>：</p><ul><li>数据传输对象(DTO)</li><li>持久化对象(对应数据库表)</li><li>业务模型对象</li></ul><h2 id="7-static-关键字"><a href="#7-static-关键字" class="headerlink" title="7. static 关键字"></a>7. static 关键字</h2><p><strong>static 的用途</strong>：</p><ol><li>静态变量（类变量）</li><li>静态方法（类方法）</li><li>静态代码块</li><li>静态内部类</li></ol><h3 id="7-1-静态变量（类变量）"><a href="#7-1-静态变量（类变量）" class="headerlink" title="7.1 静态变量（类变量）"></a>7.1 静态变量（类变量）</h3><p><strong>特点</strong>：</p><ul><li>属于类，不属于任何对象实例</li><li>所有对象共享同一份静态变量</li><li>在类加载时初始化</li><li>可以通过类名直接访问</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int id;</span><br><span class="line">    </span><br><span class="line">    // 静态变量 - 记录员工总数</span><br><span class="line">    private static int nextId = 1;</span><br><span class="line">    </span><br><span class="line">    public Employee(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.id = nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int getNextId() &#123;</span><br><span class="line">        return nextId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-静态方法（类方法）"><a href="#7-2-静态方法（类方法）" class="headerlink" title="7.2 静态方法（类方法）"></a>7.2 静态方法（类方法）</h3><p><strong>特点</strong>：</p><ul><li>属于类，不属于对象实例</li><li>不能直接访问实例变量和实例方法</li><li>可以通过类名直接调用</li><li>常用于工具类方法</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MathUtils &#123;</span><br><span class="line">    // 静态方法</span><br><span class="line">    public static double calculateCircleArea(double radius) &#123;</span><br><span class="line">        return Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int max(int a, int b) &#123;</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">double area = MathUtils.calculateCircleArea(5.0);</span><br><span class="line">int maxNum = MathUtils.max(10, 20);</span><br></pre></td></tr></table></figure><h3 id="7-3-静态代码块"><a href="#7-3-静态代码块" class="headerlink" title="7.3 静态代码块"></a>7.3 静态代码块</h3><p><strong>特点</strong>：</p><ul><li>在类加载时执行，且只执行一次</li><li>用于初始化静态变量或执行只需一次的初始化操作</li><li>可以有多个静态代码块，按顺序执行</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class DatabaseConfig &#123;</span><br><span class="line">    private static Properties props;</span><br><span class="line">    </span><br><span class="line">    // 静态代码块</span><br><span class="line">    static &#123;</span><br><span class="line">        props = new Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            props.load(DatabaseConfig.class.getResourceAsStream(&quot;/db.properties&quot;));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static String getConfig(String key) &#123;</span><br><span class="line">        return props.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-静态内部类"><a href="#7-4-静态内部类" class="headerlink" title="7.4 静态内部类"></a>7.4 静态内部类</h3><p><strong>特点</strong>：</p><ul><li>不依赖于外部类的实例</li><li>只能访问外部类的静态成员</li><li>常用于与外部类密切相关但又不需要访问外部类实例的情况</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private static String staticField = &quot;Static Field&quot;;</span><br><span class="line">    </span><br><span class="line">    // 静态内部类</span><br><span class="line">    public static class StaticNestedClass &#123;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(&quot;访问外部类的静态字段：&quot; + staticField);</span><br><span class="line">            // 不能访问非静态字段</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">OuterClass.StaticNestedClass nested = new OuterClass.StaticNestedClass();</span><br><span class="line">nested.print();</span><br></pre></td></tr></table></figure><h2 id="static-使用注意事项"><a href="#static-使用注意事项" class="headerlink" title="static 使用注意事项"></a>static 使用注意事项</h2><ol><li>静态方法中不能使用 this 和 super 关键字</li><li>静态方法只能直接调用其他静态方法</li><li>静态方法只能直接访问静态变量</li><li>静态方法不能被重写（但可以隐藏）</li><li>静态成员在类加载时初始化，早于实例成员的初始化</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin的高阶函数详解</title>
      <link href="/2025/04/20/Kotlin%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/20/Kotlin%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Kotlin的高阶函数详解</p><p>Kotlin 的高阶函数（Higher-Order Functions，简称 HOF）是函数式编程的一个重要特性，能够显著增强语言的表达力。高阶函数是指那些可以接受其他函数作为参数，或者返回函数的函数。</p><h3 id="1-高阶函数的定义"><a href="#1-高阶函数的定义" class="headerlink" title="1. 高阶函数的定义"></a>1. 高阶函数的定义</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>高阶函数指的是：</p><ul><li>接受函数作为参数</li><li>或者返回函数</li></ul><h4 id="示例：接受函数作为参数"><a href="#示例：接受函数作为参数" class="headerlink" title="示例：接受函数作为参数"></a>示例：接受函数作为参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; List&lt;T&gt;.customFilter(predicate: (T) -&gt; Boolean): List&lt;T&gt; &#123;</span><br><span class="line">    val result = mutableListOf&lt;T&gt;()</span><br><span class="line">    for (item in this) &#123;</span><br><span class="line">        if (predicate(item)) &#123;</span><br><span class="line">            result.add(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val numbers = listOf(1, 2, 3, 4, 5, 6)</span><br><span class="line">val evenNumbers = numbers.customFilter &#123; it % 2 == 0 &#125;</span><br><span class="line">println(evenNumbers)  // 输出: [2, 4, 6]</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>customFilter</code> 是一个高阶函数，它接受一个函数 <code>predicate</code> 作为参数，并根据该函数筛选列表中的元素。</p><h4 id="示例：返回函数"><a href="#示例：返回函数" class="headerlink" title="示例：返回函数"></a>示例：返回函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun multiplyBy(factor: Int): (Int) -&gt; Int &#123;</span><br><span class="line">    return &#123; number -&gt; number * factor &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val multiplyBy2 = multiplyBy(2)</span><br><span class="line">println(multiplyBy2(4))  // 输出: 8</span><br></pre></td></tr></table></figure><p>这里，<code>multiplyBy</code> 函数返回一个新的函数，它接受一个整数并将其乘以 <code>factor</code>。</p><h3 id="2-常见的高阶函数"><a href="#2-常见的高阶函数" class="headerlink" title="2. 常见的高阶函数"></a>2. 常见的高阶函数</h3><p>Kotlin 标准库包含了许多高阶函数，下面是一些常见的高阶函数。</p><h4 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a><code>map</code> 函数</h4><p><code>map</code> 是一个高阶函数，它接受一个变换函数，并返回一个新集合，其中包含应用该变换函数后的每个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val squared = numbers.map &#123; it * it &#125;</span><br><span class="line">println(squared)  // 输出: [1, 4, 9, 16]</span><br></pre></td></tr></table></figure><h4 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a><code>filter</code> 函数</h4><p><code>filter</code> 函数接受一个筛选条件，并返回一个新集合，只包含符合条件的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4, 5, 6)</span><br><span class="line">val evenNumbers = numbers.filter &#123; it % 2 == 0 &#125;</span><br><span class="line">println(evenNumbers)  // 输出: [2, 4, 6]</span><br></pre></td></tr></table></figure><h4 id="fold-函数"><a href="#fold-函数" class="headerlink" title="fold 函数"></a><code>fold</code> 函数</h4><p><code>fold</code> 是一个折叠函数，它将集合中的每个元素通过一个指定的操作组合起来，返回一个单一的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val sum = numbers.fold(0) &#123; accumulator, element -&gt; accumulator + element &#125;</span><br><span class="line">println(sum)  // 输出: 10</span><br></pre></td></tr></table></figure><p>这里，<code>fold</code> 从初始值 <code>0</code> 开始，依次将每个元素加到累加器上。</p><h4 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce 函数"></a><code>reduce</code> 函数</h4><p><code>reduce</code> 与 <code>fold</code> 类似，区别在于它没有初始值，直接使用集合的第一个元素作为初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val product = numbers.reduce &#123; accumulator, element -&gt; accumulator * element &#125;</span><br><span class="line">println(product)  // 输出: 24</span><br></pre></td></tr></table></figure><h4 id="forEach-函数"><a href="#forEach-函数" class="headerlink" title="forEach 函数"></a><code>forEach</code> 函数</h4><p><code>forEach</code> 是一个遍历集合的高阶函数，它接受一个操作函数，在集合的每个元素上执行该操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3)</span><br><span class="line">numbers.forEach &#123; println(it) &#125;</span><br><span class="line">// 输出:</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><h3 id="3-Lambda-表达式和高阶函数"><a href="#3-Lambda-表达式和高阶函数" class="headerlink" title="3. Lambda 表达式和高阶函数"></a>3. Lambda 表达式和高阶函数</h3><p>Kotlin 中，高阶函数通常与 Lambda 表达式一起使用，Lambda 表达式是一个匿名函数，它可以简洁地表示函数参数。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val sum = &#123; a: Int, b: Int -&gt; a + b &#125;</span><br><span class="line">println(sum(3, 4))  // 输出: 7</span><br></pre></td></tr></table></figure><h3 id="4-函数作为返回值"><a href="#4-函数作为返回值" class="headerlink" title="4. 函数作为返回值"></a>4. 函数作为返回值</h3><p>在 Kotlin 中，函数也可以作为返回值，且可以直接返回一个 Lambda 表达式。</p><h4 id="示例：返回一个高阶函数"><a href="#示例：返回一个高阶函数" class="headerlink" title="示例：返回一个高阶函数"></a>示例：返回一个高阶函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun operation(type: String): (Int, Int) -&gt; Int &#123;</span><br><span class="line">    return when (type) &#123;</span><br><span class="line">        &quot;sum&quot; -&gt; &#123; a, b -&gt; a + b &#125;</span><br><span class="line">        &quot;multiply&quot; -&gt; &#123; a, b -&gt; a * b &#125;</span><br><span class="line">        else -&gt; &#123; a, b -&gt; 0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val sumOperation = operation(&quot;sum&quot;)</span><br><span class="line">println(sumOperation(3, 4))  // 输出: 7</span><br><span class="line"></span><br><span class="line">val multiplyOperation = operation(&quot;multiply&quot;)</span><br><span class="line">println(multiplyOperation(3, 4))  // 输出: 12</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>operation</code> 函数根据不同的 <code>type</code> 返回不同的操作函数。</p><h3 id="5-高阶函数与集合操作结合"><a href="#5-高阶函数与集合操作结合" class="headerlink" title="5. 高阶函数与集合操作结合"></a>5. 高阶函数与集合操作结合</h3><p>Kotlin 高阶函数常常与集合操作结合使用，使得集合的处理更加简洁和高效。比如链式调用 <code>map</code>、<code>filter</code>、<code>reduce</code> 等操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4, 5)</span><br><span class="line">val result = numbers.filter &#123; it % 2 == 0 &#125;</span><br><span class="line">                     .map &#123; it * it &#125;</span><br><span class="line">                     .reduce &#123; acc, i -&gt; acc + i &#125;</span><br><span class="line">println(result)  // 输出: 20</span><br></pre></td></tr></table></figure><h3 id="6-高阶函数和匿名函数的结合"><a href="#6-高阶函数和匿名函数的结合" class="headerlink" title="6. 高阶函数和匿名函数的结合"></a>6. 高阶函数和匿名函数的结合</h3><p>Kotlin 还支持匿名函数，它们和 Lambda 表达式的使用方法类似，但可以显式声明参数类型和返回类型。</p><h4 id="示例：匿名函数"><a href="#示例：匿名函数" class="headerlink" title="示例：匿名函数"></a>示例：匿名函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val sum: (Int, Int) -&gt; Int = fun(a: Int, b: Int): Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(sum(2, 3))  // 输出: 5</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>高阶函数是 Kotlin 中非常强大的功能，它让函数式编程成为可能，能够简化代码并提高可读性。Kotlin 提供了一些内建的高阶函数，如 <code>map</code>、<code>filter</code>、<code>fold</code> 等，允许你对集合和数据进行更灵活的操作。</p><ul><li><strong>接受函数作为参数</strong>：<code>map</code>, <code>filter</code>, <code>fold</code>, 等。</li><li><strong>返回函数</strong>：可以返回一个 Lambda 函数或匿名函数。</li><li><strong>结合 Lambda 表达式使用</strong>：使得代码更加简洁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BroadcastReceiver</title>
      <link href="/2025/04/20/BroadcastReceiver/"/>
      <url>/2025/04/20/BroadcastReceiver/</url>
      
        <content type="html"><![CDATA[<h2 id="🚨-什么是-BroadcastReceiver？"><a href="#🚨-什么是-BroadcastReceiver？" class="headerlink" title="🚨 什么是 BroadcastReceiver？"></a>🚨 什么是 BroadcastReceiver？</h2><p><code>BroadcastReceiver</code> 是 Android 提供的一个机制，用于<strong>在应用之间或系统与应用之间传递消息</strong>。比如：</p><ul><li>当手机接收到短信时；</li><li>电池电量变化；</li><li>网络连接变化；</li><li>你自己在 App 内发出一个自定义事件。</li></ul><p>这些“消息”叫做<strong>广播（Broadcast）</strong>，而负责“接收广播”的组件就是 <strong>BroadcastReceiver</strong>。</p><hr><h2 id="🧠-工作原理："><a href="#🧠-工作原理：" class="headerlink" title="🧠 工作原理："></a>🧠 工作原理：</h2><ol><li>某个组件（系统或 app）发送一个广播（用 <code>sendBroadcast()</code>）；</li><li>Android 系统会根据你注册的广播类型，找到匹配的 <code>BroadcastReceiver</code>；</li><li><code>BroadcastReceiver</code> 会执行你定义的逻辑（通常在 <code>onReceive()</code> 方法里写处理逻辑）；</li></ol><hr><h2 id="📦-BroadcastReceiver-分类"><a href="#📦-BroadcastReceiver-分类" class="headerlink" title="📦 BroadcastReceiver 分类"></a>📦 BroadcastReceiver 分类</h2><h3 id="1-静态注册"><a href="#1-静态注册" class="headerlink" title="1. 静态注册"></a>1. <strong>静态注册</strong></h3><ul><li>在 <code>AndroidManifest.xml</code> 中注册</li><li>会在 App 没启动的情况下也能接收到广播（某些系统广播）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.MyReceiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure><h3 id="2-动态注册"><a href="#2-动态注册" class="headerlink" title="2. 动态注册"></a>2. <strong>动态注册</strong></h3><ul><li>在 Java&#x2F;Kotlin 代码中注册</li><li>一般在 Activity 或 Service 的生命周期内注册和注销</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReceiver receiver = new MyReceiver();</span><br><span class="line">IntentFilter filter = new IntentFilter(&quot;com.example.MY_BROADCAST&quot;);</span><br><span class="line">registerReceiver(receiver, filter);  // 注册</span><br><span class="line">unregisterReceiver(receiver);        // 注销（避免内存泄漏）</span><br></pre></td></tr></table></figure><hr><h2 id="🧪-示例：自定义广播发送与接收"><a href="#🧪-示例：自定义广播发送与接收" class="headerlink" title="🧪 示例：自定义广播发送与接收"></a>🧪 示例：自定义广播发送与接收</h2><h3 id="1️⃣-创建一个自定义广播接收器："><a href="#1️⃣-创建一个自定义广播接收器：" class="headerlink" title="1️⃣ 创建一个自定义广播接收器："></a>1️⃣ 创建一个自定义广播接收器：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        // 当广播接收到时，这里会执行</span><br><span class="line">        String data = intent.getStringExtra(&quot;msg&quot;);</span><br><span class="line">        Toast.makeText(context, &quot;收到广播: &quot; + data, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2️⃣-动态注册（例如在-MainActivity-中）："><a href="#2️⃣-动态注册（例如在-MainActivity-中）：" class="headerlink" title="2️⃣ 动态注册（例如在 MainActivity 中）："></a>2️⃣ 动态注册（例如在 MainActivity 中）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyReceiver myReceiver = new MyReceiver();</span><br><span class="line">IntentFilter filter = new IntentFilter(&quot;com.example.MY_BROADCAST&quot;);</span><br><span class="line">registerReceiver(myReceiver, filter);</span><br></pre></td></tr></table></figure><h3 id="3️⃣-发送广播："><a href="#3️⃣-发送广播：" class="headerlink" title="3️⃣ 发送广播："></a>3️⃣ 发送广播：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(&quot;com.example.MY_BROADCAST&quot;);</span><br><span class="line">intent.putExtra(&quot;msg&quot;, &quot;你好，世界！&quot;);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure><hr><h2 id="🔐-权限和安全"><a href="#🔐-权限和安全" class="headerlink" title="🔐 权限和安全"></a>🔐 权限和安全</h2><ul><li><p>有些系统广播需要权限，例如监听开机广播：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xml</span><br><span class="line"></span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>Android 8.0（API 26）之后，对静态注册广播做了限制，一些隐式广播不能再静态注册，只能动态注册。</p></li></ul><hr><h2 id="✅-使用小贴士"><a href="#✅-使用小贴士" class="headerlink" title="✅ 使用小贴士"></a>✅ 使用小贴士</h2><table><thead><tr><th>内容</th><th>建议</th></tr></thead><tbody><tr><td>生命周期管理</td><td>动态注册时，记得在 <code>onDestroy()</code> 中注销广播</td></tr><tr><td>安全性</td><td>自定义广播建议使用 <code>LocalBroadcastManager</code>（已废弃，推荐使用 LiveData&#x2F;EventBus 替代）</td></tr><tr><td>不要做耗时操作</td><td><code>onReceive()</code> 中不能做耗时操作，默认运行在主线程</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> android主要组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android主要组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin中的内联函数</title>
      <link href="/2025/04/20/Kotlin%20%E4%B8%AD%E7%9A%84%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>/2025/04/20/Kotlin%20%E4%B8%AD%E7%9A%84%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="🌟-什么是内联函数？"><a href="#🌟-什么是内联函数？" class="headerlink" title="🌟 什么是内联函数？"></a>🌟 什么是内联函数？</h3><p>简单说：</p><blockquote><p><strong>内联函数就是在编译时将函数的调用代码“展开”为函数体本身，从而避免函数调用的开销。</strong></p></blockquote><p>通常高阶函数（比如 <code>map</code>, <code>filter</code>, <code>let</code>, <code>run</code> 等）都会带来额外的开销，因为它们需要创建函数对象、维护调用栈。而使用 <code>inline</code> 关键字修饰的函数在编译时会将其代码“拷贝”到调用处，避免这些额外开销。</p><hr><h3 id="🧪-基本语法"><a href="#🧪-基本语法" class="headerlink" title="🧪 基本语法"></a>🧪 基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun doSomething(action: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;Start&quot;)</span><br><span class="line">    action()</span><br><span class="line">    println(&quot;End&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething &#123;</span><br><span class="line">    println(&quot;Hello inline&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚡ 编译后，大致等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;Start&quot;)</span><br><span class="line">println(&quot;Hello inline&quot;)</span><br><span class="line">println(&quot;End&quot;)</span><br></pre></td></tr></table></figure><p>函数体直接“插入”到调用处。</p><hr><h3 id="✅-优势"><a href="#✅-优势" class="headerlink" title="✅ 优势"></a>✅ 优势</h3><ol><li><strong>性能提升</strong>：避免函数调用、lambda 对象创建的开销。</li><li><strong>允许非局部返回</strong>（下面详细说）</li><li><strong>适合频繁调用的小型函数或高阶函数</strong></li></ol><hr><h3 id="⚠️-注意：非局部返回（non-local-return）"><a href="#⚠️-注意：非局部返回（non-local-return）" class="headerlink" title="⚠️ 注意：非局部返回（non-local return）"></a>⚠️ 注意：<strong>非局部返回（non-local return）</strong></h3><p>Lambda 中用 <code>return</code>，默认是从<strong>外围函数</strong>返回的，这在内联函数中是允许的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">inline fun doSomething(block: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;Before&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;After&quot;)  // 不会执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun test() &#123;</span><br><span class="line">    doSomething &#123;</span><br><span class="line">        println(&quot;Inside&quot;)</span><br><span class="line">        return  // 非局部 return，直接从 test() 返回</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;This will not be printed&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你把 <code>doSomething</code> 的 <code>inline</code> 去掉，这段代码是<strong>无法通过编译</strong>的。</p><hr><h3 id="🔒-使用-noinline-禁止内联某个-lambda"><a href="#🔒-使用-noinline-禁止内联某个-lambda" class="headerlink" title="🔒 使用 noinline 禁止内联某个 lambda"></a>🔒 使用 <code>noinline</code> 禁止内联某个 lambda</h3><p>有时候你不希望某些 lambda 被内联，可以加 <code>noinline</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline fun process(a: () -&gt; Unit, noinline b: () -&gt; Unit) &#123;</span><br><span class="line">    a()     // 内联</span><br><span class="line">    b()     // 不内联</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用于 <strong>将 lambda 作为值传递或多次使用</strong> 的情况。</p><hr><h3 id="💥-crossinline：阻止-lambda-使用-return"><a href="#💥-crossinline：阻止-lambda-使用-return" class="headerlink" title="💥 crossinline：阻止 lambda 使用 return"></a>💥 <code>crossinline</code>：阻止 lambda 使用 return</h3><p>有时候你<strong>必须内联</strong>，但又<strong>不允许 lambda 使用非局部 return</strong>（比如 lambda 传给另一个线程或匿名类），你可以加 <code>crossinline</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun startJob(crossinline job: () -&gt; Unit) &#123;</span><br><span class="line">    Thread &#123;</span><br><span class="line">        job()  // 如果 job 用 return 会报错</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🚀-小总结"><a href="#🚀-小总结" class="headerlink" title="🚀 小总结"></a>🚀 小总结</h3><table><thead><tr><th>关键字</th><th>作用</th></tr></thead><tbody><tr><td><code>inline</code></td><td>编译时将函数体展开，提升性能，允许非局部 return</td></tr><tr><td><code>noinline</code></td><td>禁止某个 lambda 被内联（用于多次调用或当作对象传递）</td></tr><tr><td><code>crossinline</code></td><td>阻止某个 lambda 使用 <code>return</code>（防止非局部 return）</td></tr></tbody></table><hr><h3 id="✅-典型应用场景"><a href="#✅-典型应用场景" class="headerlink" title="✅ 典型应用场景"></a>✅ 典型应用场景</h3><ul><li><code>apply</code> &#x2F; <code>run</code> &#x2F; <code>let</code> 等标准库函数内部都是 <code>inline</code> 的</li><li>DSL 构建器，比如 <code>anko</code>, <code>Jetpack Compose</code>, <code>Ktor</code> 等大量用 <code>inline</code> 优化性能和语法结构</li><li>性能敏感的高阶函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin的扩展函数和运算符重载</title>
      <link href="/2025/04/06/Kotlin%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2025/04/06/Kotlin%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 的扩展函数（Extension Functions）和运算符重载（Operator Overloading）是两个强大又常用的特性，用于让代码更简洁、表达力更强。</p><hr><h2 id="✅-扩展函数（Extension-Functions）"><a href="#✅-扩展函数（Extension-Functions）" class="headerlink" title="✅ 扩展函数（Extension Functions）"></a>✅ 扩展函数（Extension Functions）</h2><p><strong>定义</strong>：在不修改原类源码的情况下，为类添加新的函数。</p><h3 id="🌟-语法"><a href="#🌟-语法" class="headerlink" title="🌟 语法"></a>🌟 语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun ClassName.functionName(params): ReturnType &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🧪-示例"><a href="#🧪-示例" class="headerlink" title="🧪 示例"></a>🧪 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun String.lastChar(): Char &#123;</span><br><span class="line">    return this[this.length - 1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val s = &quot;Hello&quot;</span><br><span class="line">    println(s.lastChar())  // 输出：&#x27;o&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="📌-注意"><a href="#📌-注意" class="headerlink" title="📌 注意"></a>📌 注意</h3><ul><li><code>this</code> 代表接收者对象（上例中是 <code>String</code>）</li><li>扩展函数<strong>不会真正修改原类</strong>，只是通过静态方式实现“扩展”</li><li>若类有成员函数与扩展函数同名，<strong>成员函数优先</strong></li></ul><hr><h2 id="➕-运算符重载（Operator-Overloading）"><a href="#➕-运算符重载（Operator-Overloading）" class="headerlink" title="➕ 运算符重载（Operator Overloading）"></a>➕ 运算符重载（Operator Overloading）</h2><p><strong>定义</strong>：通过定义带有 <code>operator</code> 关键字的函数，自定义类的运算符行为（如 <code>+</code>, <code>-</code>, <code>[]</code>, <code>==</code> 等）。</p><h3 id="🌟-支持的运算符（部分）"><a href="#🌟-支持的运算符（部分）" class="headerlink" title="🌟 支持的运算符（部分）"></a>🌟 支持的运算符（部分）</h3><table><thead><tr><th>运算符</th><th>对应函数名</th></tr></thead><tbody><tr><td><code>+</code></td><td><code>plus</code></td></tr><tr><td><code>-</code></td><td><code>minus</code></td></tr><tr><td><code>*</code></td><td><code>times</code></td></tr><tr><td><code>/</code></td><td><code>div</code></td></tr><tr><td><code>%</code></td><td><code>rem</code></td></tr><tr><td><code>==</code></td><td><code>equals</code></td></tr><tr><td><code>[]</code></td><td><code>get</code>, <code>set</code></td></tr><tr><td><code>..</code></td><td><code>rangeTo</code></td></tr><tr><td><code>in</code></td><td><code>contains</code></td></tr></tbody></table><h3 id="🧪-示例-1"><a href="#🧪-示例-1" class="headerlink" title="🧪 示例"></a>🧪 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data class Point(val x: Int, val y: Int) &#123;</span><br><span class="line">    operator fun plus(other: Point): Point &#123;</span><br><span class="line">        return Point(x + other.x, y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val p1 = Point(1, 2)</span><br><span class="line">    val p2 = Point(3, 4)</span><br><span class="line">    println(p1 + p2) // 输出：Point(x=4, y=6)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⚠️-注意"><a href="#⚠️-注意" class="headerlink" title="⚠️ 注意"></a>⚠️ 注意</h3><ul><li>需加 <code>operator</code> 关键字</li><li>Kotlin 会根据运算符自动映射到相应的函数</li></ul><hr><h2 id="✨-拓展-运算符重载的组合示例"><a href="#✨-拓展-运算符重载的组合示例" class="headerlink" title="✨ 拓展+运算符重载的组合示例"></a>✨ 拓展+运算符重载的组合示例</h2><p>你甚至可以为已有类<strong>扩展运算符函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">operator fun String.times(n: Int): String &#123;</span><br><span class="line">    return this.repeat(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;Hi! &quot; * 3) // 输出：Hi! Hi! Hi! </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延迟初始化与封装类</title>
      <link href="/2025/04/06/%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%B0%81%E8%A3%85%E7%B1%BB/"/>
      <url>/2025/04/06/%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%B0%81%E8%A3%85%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="🔹-1-延迟初始化-lateinit"><a href="#🔹-1-延迟初始化-lateinit" class="headerlink" title="🔹 1. 延迟初始化 (lateinit)"></a>🔹 1. 延迟初始化 (<code>lateinit</code>)</h2><h3 id="✅-用途："><a href="#✅-用途：" class="headerlink" title="✅ 用途："></a>✅ 用途：</h3><p>当你不想在定义变量时立刻初始化它，但又确定在使用前一定会初始化（比如依赖注入、测试、Android View 绑定等）。</p><h3 id="✅-语法："><a href="#✅-语法：" class="headerlink" title="✅ 语法："></a>✅ 语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lateinit var name: String</span><br></pre></td></tr></table></figure><h3 id="✅-注意事项："><a href="#✅-注意事项：" class="headerlink" title="✅ 注意事项："></a>✅ 注意事项：</h3><ul><li>只能用于 **<code>var</code>**，不能用于 <code>val</code>。</li><li>只能用于 <strong>非空类型的引用类型</strong>（不能是原始类型如 <code>Int</code>、<code>Double</code>）。</li><li>使用前如果没初始化，会抛出 **<code>UninitializedPropertyAccessException</code>**。</li></ul><h3 id="✅-示例："><a href="#✅-示例：" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    lateinit var nickname: String</span><br><span class="line"></span><br><span class="line">    fun initNickname() &#123;</span><br><span class="line">        nickname = &quot;KotlinFan&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun printNickname() &#123;</span><br><span class="line">        if (::nickname.isInitialized) &#123;</span><br><span class="line">            println(nickname)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println(&quot;nickname 尚未初始化&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-2-密封类（sealed-class）"><a href="#🔹-2-密封类（sealed-class）" class="headerlink" title="🔹 2. 密封类（sealed class）"></a>🔹 2. 密封类（<code>sealed class</code>）</h2><h3 id="✅-用途：-1"><a href="#✅-用途：-1" class="headerlink" title="✅ 用途："></a>✅ 用途：</h3><p>用于表示<strong>受限的类继承结构</strong>，所有子类都必须声明在同一个文件中。常用于表示状态、结果、事件等。</p><p>类似于 Java 的 <code>enum</code>，但可以携带数据。常配合 <code>when</code> 表达式使用，可以 <strong>无需 else</strong> 分支。</p><h3 id="✅-示例：-1"><a href="#✅-示例：-1" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sealed class Result</span><br><span class="line"></span><br><span class="line">data class Success(val data: String) : Result()</span><br><span class="line">data class Error(val message: String) : Result()</span><br><span class="line">object Loading : Result()</span><br><span class="line"></span><br><span class="line">fun handleResult(result: Result) &#123;</span><br><span class="line">    when (result) &#123;</span><br><span class="line">        is Success -&gt; println(&quot;成功: $&#123;result.data&#125;&quot;)</span><br><span class="line">        is Error -&gt; println(&quot;失败: $&#123;result.message&#125;&quot;)</span><br><span class="line">        Loading -&gt; println(&quot;加载中...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔸-总结对比"><a href="#🔸-总结对比" class="headerlink" title="🔸 总结对比"></a>🔸 总结对比</h2><table><thead><tr><th>特性</th><th><code>lateinit</code></th><th><code>sealed class</code></th></tr></thead><tbody><tr><td>用途</td><td>延迟初始化引用变量</td><td>表示受限的继承结构，常用于状态建模</td></tr><tr><td>限制</td><td>不能用于 <code>val</code> 或基本类型</td><td>所有子类必须在同一文件中定义</td></tr><tr><td>常用场景</td><td>Android View、依赖注入等</td><td>网络请求结果、UI状态、表达式分支等</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin lambda编程</title>
      <link href="/2025/03/28/kotlin%20lambda/"/>
      <url>/2025/03/28/kotlin%20lambda/</url>
      
        <content type="html"><![CDATA[<h1 id="kotlin-lambda编程"><a href="#kotlin-lambda编程" class="headerlink" title="kotlin lambda编程"></a>kotlin lambda编程</h1><p>Kotlin 的 Lambda（匿名函数）是函数式编程的核心特性之一，允许你以简洁的方式编写代码，尤其适用于集合操作、回调、DSL（领域特定语言）等场景。</p><h2 id="1-Lambda-表达式基础"><a href="#1-Lambda-表达式基础" class="headerlink" title="1. Lambda 表达式基础"></a>1. Lambda 表达式基础</h2><p>Lambda 表达式是一个匿名函数，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val sum: (Int, Int) -&gt; Int = &#123; a, b -&gt; a + b &#125;</span><br><span class="line">println(sum(2, 3)) // 输出 5</span><br></pre></td></tr></table></figure><p><strong>语法说明</strong>：</p><ul><li><code>&#123; 参数1, 参数2 -&gt; 函数体 &#125;</code></li><li><code>val sum: (Int, Int) -&gt; Int</code> 明确声明了函数类型，表示它接收两个 <code>Int</code> 并返回 <code>Int</code>。</li></ul><h2 id="2-使用-it-关键字"><a href="#2-使用-it-关键字" class="headerlink" title="2. 使用 it 关键字"></a>2. 使用 <code>it</code> 关键字</h2><p>当 Lambda 只有一个参数时，可以用 <code>it</code> 代替参数名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val square: (Int) -&gt; Int = &#123; it * it &#125;</span><br><span class="line">println(square(4)) // 输出 16</span><br></pre></td></tr></table></figure><h2 id="3-Lambda-作为函数参数"><a href="#3-Lambda-作为函数参数" class="headerlink" title="3. Lambda 作为函数参数"></a>3. Lambda 作为函数参数</h2><p>Lambda 可以作为参数传递给函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun operateOnNumbers(a: Int, b: Int, operation: (Int, Int) -&gt; Int): Int &#123;</span><br><span class="line">    return operation(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val result = operateOnNumbers(4, 5) &#123; x, y -&gt; x * y &#125;</span><br><span class="line">println(result) // 输出 20</span><br></pre></td></tr></table></figure><h2 id="4-高阶函数-结合-Lambda"><a href="#4-高阶函数-结合-Lambda" class="headerlink" title="4. 高阶函数 结合 Lambda"></a>4. <code>高阶函数</code> 结合 Lambda</h2><p>Kotlin 支持高阶函数（即参数或返回值是函数的函数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun higherOrderFunction(operation: () -&gt; Unit) &#123;</span><br><span class="line">    operation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">higherOrderFunction &#123; println(&quot;Hello, Lambda!&quot;) &#125;</span><br></pre></td></tr></table></figure><h2 id="5-在集合操作中的应用"><a href="#5-在集合操作中的应用" class="headerlink" title="5. 在集合操作中的应用"></a>5. 在集合操作中的应用</h2><p>Lambda 在 Kotlin 的集合 API 中应用广泛，如 <code>map</code>、<code>filter</code>、<code>reduce</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4, 5)</span><br><span class="line">val squaredNumbers = numbers.map &#123; it * it &#125;</span><br><span class="line">println(squaredNumbers) // 输出 [1, 4, 9, 16, 25]</span><br><span class="line"></span><br><span class="line">val evenNumbers = numbers.filter &#123; it % 2 == 0 &#125;</span><br><span class="line">println(evenNumbers) // 输出 [2, 4]</span><br></pre></td></tr></table></figure><h2 id="6-let、apply、run、with、also"><a href="#6-let、apply、run、with、also" class="headerlink" title="6. let、apply、run、with、also"></a>6. <code>let</code>、<code>apply</code>、<code>run</code>、<code>with</code>、<code>also</code></h2><p>Kotlin 提供了一系列作用域函数，结合 Lambda 使用非常强大：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val name: String? = &quot;Kotlin&quot;</span><br><span class="line">name?.let &#123; println(it.uppercase()) &#125; // 非空时执行</span><br><span class="line"></span><br><span class="line">val person = Person(&quot;John&quot;).apply &#123; age = 30 &#125; // apply 适用于修改对象属性</span><br><span class="line">println(person)</span><br></pre></td></tr></table></figure><h2 id="7-闭包（Closure）"><a href="#7-闭包（Closure）" class="headerlink" title="7. 闭包（Closure）"></a>7. 闭包（Closure）</h2><p>Lambda 表达式可以访问外部变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun counter(): () -&gt; Int &#123;</span><br><span class="line">    var count = 0</span><br><span class="line">    return &#123; count++ &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val next = counter()</span><br><span class="line">println(next()) // 0</span><br><span class="line">println(next()) // 1</span><br><span class="line">println(next()) // 2</span><br></pre></td></tr></table></figure><h2 id="8-带-return-的-Lambda"><a href="#8-带-return-的-Lambda" class="headerlink" title="8. 带 return 的 Lambda"></a>8. 带 <code>return</code> 的 Lambda</h2><p>Lambda 默认返回最后一行的值，如果需要提前返回，可以使用 <code>return@label</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listOf(1, 2, 3, 4, 5).forEach &#123; </span><br><span class="line">    if (it == 3) return@forEach </span><br><span class="line">    println(it) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intent</title>
      <link href="/2025/03/28/%E6%98%BE%E5%BC%8FIntent%E4%B8%8E%E9%9A%90%E5%BC%8FIntent/"/>
      <url>/2025/03/28/%E6%98%BE%E5%BC%8FIntent%E4%B8%8E%E9%9A%90%E5%BC%8FIntent/</url>
      
        <content type="html"><![CDATA[<p>显式Intent与隐式Intent</p><h6 id="ChatGPT-说："><a href="#ChatGPT-说：" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>在 Android 中，<strong>Intent（意图）</strong> 是组件（Activity、Service、BroadcastReceiver）之间进行通信的机制。Intent 主要分为两种类型：</p><h3 id="1-显式-Intent（Explicit-Intent）"><a href="#1-显式-Intent（Explicit-Intent）" class="headerlink" title="1. 显式 Intent（Explicit Intent）"></a><strong>1. 显式 Intent（Explicit Intent）</strong></h3><p>显式 Intent 直接指定目标组件（Activity、Service）的 <strong>类名</strong>，用于在 <strong>应用内部</strong> 启动组件。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(this, SecondActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li><strong>适用于应用内部</strong> 组件间的交互，比如从 <code>MainActivity</code> 跳转到 <code>SecondActivity</code>。</li><li><strong>指定目标类名</strong>，不会让系统去匹配 <code>intent-filter</code>。</li><li><strong>性能更高</strong>，因为不需要系统查找匹配的组件。</li></ul><hr><h3 id="2-隐式-Intent（Implicit-Intent）"><a href="#2-隐式-Intent（Implicit-Intent）" class="headerlink" title="2. 隐式 Intent（Implicit Intent）"></a><strong>2. 隐式 Intent（Implicit Intent）</strong></h3><p>隐式 Intent <strong>不指定</strong> 目标组件的类名，而是使用 <strong>动作（Action）、类别（Category）、数据（Data）</strong> 让系统找到符合条件的组件。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><p>打开网页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(Uri.parse(&quot;https://www.example.com&quot;));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>拨打电话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(Intent.ACTION_DIAL);</span><br><span class="line">intent.setData(Uri.parse(&quot;tel:123456789&quot;));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li><p><strong>适用于调用其他应用的功能</strong>，例如打开浏览器、拨号、分享文本等。</p></li><li><p>需要在 <code>AndroidManifest.xml</code> 中声明 <code>intent-filter</code>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.ThirdActivity&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">        &lt;data android:scheme=&quot;https&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>系统会自动匹配</strong> 适合的应用来处理这个 Intent。</p></li></ul><hr><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a><strong>对比总结</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>显式 Intent</strong></th><th><strong>隐式 Intent</strong></th></tr></thead><tbody><tr><td><strong>目标组件</strong></td><td><strong>明确指定</strong> 类名，如 <code>SecondActivity.class</code></td><td><strong>不指定</strong> 类名，使用 <code>Action + Data</code> 让系统匹配</td></tr><tr><td><strong>适用场景</strong></td><td>应用内部跳转，如 <code>ActivityA → ActivityB</code></td><td>调用系统&#x2F;其他应用功能，如打开网页、拨打电话</td></tr><tr><td><strong>匹配方式</strong></td><td><strong>直接找到组件</strong> 并启动</td><td><strong>系统匹配 <code>intent-filter</code></strong> 找到合适的组件</td></tr><tr><td><strong>性能</strong></td><td><strong>更快</strong>，因为不需要匹配</td><td><strong>稍慢</strong>，需要查询可能的匹配组件</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> android主要组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android主要组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空指针检查</title>
      <link href="/2025/03/28/%E7%A9%BA%E6%8C%87%E9%92%88%E6%A3%80%E6%9F%A5/"/>
      <url>/2025/03/28/%E7%A9%BA%E6%8C%87%E9%92%88%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 通过 <strong>空安全（Null Safety）</strong> 机制减少了空指针异常（NullPointerException，NPE）。以下是 Kotlin 中处理空指针的常见方式：</p><hr><h3 id="1-可空类型"><a href="#1-可空类型" class="headerlink" title="1. 可空类型 (?)"></a>1. <strong>可空类型 (<code>?</code>)</strong></h3><p>Kotlin 默认所有变量都不能为空。如果需要允许 <code>null</code>，必须显式声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = &quot;Kotlin&quot;</span><br><span class="line">name = null  // 允许赋值 null</span><br></pre></td></tr></table></figure><hr><h3 id="2-安全调用"><a href="#2-安全调用" class="headerlink" title="2. 安全调用 (?.)"></a>2. <strong>安全调用 (<code>?.</code>)</strong></h3><p>当变量可能为 <code>null</code> 时，可以使用 <strong>安全调用</strong> 来避免 NPE：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val length: Int? = name?.length  // name 为 null 时，length 也为 null</span><br></pre></td></tr></table></figure><hr><h3 id="3-Elvis-运算符"><a href="#3-Elvis-运算符" class="headerlink" title="3. Elvis 运算符 (?:)"></a>3. <strong>Elvis 运算符 (<code>?:</code>)</strong></h3><p>提供默认值，避免 <code>null</code> 影响程序逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val length: Int = name?.length ?: 0  // name 为 null 时，length 取 0</span><br></pre></td></tr></table></figure><hr><h3 id="4-非空断言"><a href="#4-非空断言" class="headerlink" title="4. 非空断言 (!!)"></a>4. <strong>非空断言 (<code>!!</code>)</strong></h3><p>强制告诉编译器变量不为空，否则抛出 <code>NullPointerException</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val length: Int = name!!.length  // 如果 name 为空，则抛出 NPE</span><br></pre></td></tr></table></figure><p>⚠ <strong>慎用 <code>!!</code>，仅在明确不为空时使用！</strong></p><hr><h3 id="5-let-作用域函数"><a href="#5-let-作用域函数" class="headerlink" title="5. let 作用域函数"></a>5. <strong><code>let</code> 作用域函数</strong></h3><p><code>let</code> 结合安全调用 (<code>?.</code>)，可用于在非空时执行某些操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name?.let &#123;</span><br><span class="line">    println(&quot;Length: $&#123;it.length&#125;&quot;)  // 仅当 name 不为空时执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-lateinit-和-by-lazy"><a href="#6-lateinit-和-by-lazy" class="headerlink" title="6. lateinit 和 by lazy"></a>6. <strong><code>lateinit</code> 和 <code>by lazy</code></strong></h3><ul><li><p><code>lateinit</code> 适用于非 <code>null</code> 类型的延迟初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lateinit var text: String</span><br><span class="line">// text.length // 若未初始化，访问会抛出 UninitializedPropertyAccessException</span><br></pre></td></tr></table></figure></li><li><p><code>lazy</code> 适用于 <code>val</code> 类型的惰性初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val message: String by lazy &#123; &quot;Hello, Kotlin!&quot; &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-requireNotNull-和-checkNotNull"><a href="#7-requireNotNull-和-checkNotNull" class="headerlink" title="7. requireNotNull 和 checkNotNull"></a>7. <strong><code>requireNotNull</code> 和 <code>checkNotNull</code></strong></h3><p>手动检查 <code>null</code> 并抛出异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val nonNullName: String = requireNotNull(name) &#123; &quot;name 不能为空&quot; &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-数据类默认值"><a href="#8-数据类默认值" class="headerlink" title="8. 数据类默认值"></a>8. <strong>数据类默认值</strong></h3><p>如果某个字段可能为空，最好提供默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">data class User(val name: String = &quot;Unknown&quot;)</span><br></pre></td></tr></table></figure><hr><h3 id="9-平台类型-Java-互操作"><a href="#9-平台类型-Java-互操作" class="headerlink" title="9. 平台类型 (Java 互操作)"></a>9. <strong>平台类型 (<code>Java</code> 互操作)</strong></h3><p>从 Java 代码获取的变量可能为空，Kotlin 不能自动推断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val text: String? = javaMethodReturningNullable()  // Java 方法返回值可能为 null</span><br></pre></td></tr></table></figure><hr><h3 id="10-使用-Nullable-和-NotNull-注解"><a href="#10-使用-Nullable-和-NotNull-注解" class="headerlink" title="10. 使用 @Nullable 和 @NotNull 注解"></a>10. <strong>使用 <code>@Nullable</code> 和 <code>@NotNull</code> 注解</strong></h3><p>在 Kotlin 互操作 Java 时，可以使用这些注解来增强类型安全：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">public String getNullableString() &#123; return null; &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>方式</th><th>作用</th></tr></thead><tbody><tr><td><code>?</code></td><td>允许 <code>null</code></td></tr><tr><td><code>?.</code></td><td>安全调用</td></tr><tr><td><code>?:</code></td><td>默认值</td></tr><tr><td><code>!!</code></td><td>非空断言（可能抛 NPE）</td></tr><tr><td><code>let</code></td><td>仅在非空时执行</td></tr><tr><td><code>lateinit</code> &#x2F; <code>lazy</code></td><td>延迟初始化</td></tr><tr><td><code>requireNotNull</code></td><td>手动 <code>null</code> 检查</td></tr><tr><td><code>@Nullable</code></td><td>Java 互操作</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
