<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据大屏复盘</title>
      <link href="/2025/11/12/%E9%A1%B9%E7%9B%AE/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B1%8F/%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B1%8F%E5%A4%8D%E7%9B%98/"/>
      <url>/2025/11/12/%E9%A1%B9%E7%9B%AE/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B1%8F/%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B1%8F%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h2 id="数据大屏复盘"><a href="#数据大屏复盘" class="headerlink" title="数据大屏复盘"></a>数据大屏复盘</h2><p><strong>亮点1：搭建 Vue3+Vite 前端架构和模块化目录结构，整合 ECharts 可视化库（按需注册图表类型与组件，封</strong></p><p><strong>装大屏自适应容器组件（支持 1920*1080 设计稿适配、全屏 &#x2F; 等比缩放模式），保障显示一致性；</strong></p><blockquote><p>在这个大屏数据可视化项目中，核心需求是<strong>保证大屏在多设备上的显示一致性</strong>、<strong>数据可视化的高效实现</strong>和<strong>项目的可维护性</strong>，所以我基于 Vue3+Vite 搭建了前端架构，从目录设计、第三方库整合、核心组件封装三个层面落地，为整个项目奠定了稳定的技术基础。</p></blockquote><h3 id="二、分点拆解（结合项目细节，讲清实现逻辑）"><a href="#二、分点拆解（结合项目细节，讲清实现逻辑）" class="headerlink" title="二、分点拆解（结合项目细节，讲清实现逻辑）"></a>二、分点拆解（结合项目细节，讲清实现逻辑）</h3><h4 id="1-搭建-Vue3-Vite-架构，设计模块化目录结构（解决：项目可维护性、开发效率问题）"><a href="#1-搭建-Vue3-Vite-架构，设计模块化目录结构（解决：项目可维护性、开发效率问题）" class="headerlink" title="1. 搭建 Vue3+Vite 架构，设计模块化目录结构（解决：项目可维护性、开发效率问题）"></a>1. 搭建 Vue3+Vite 架构，设计模块化目录结构（解决：项目可维护性、开发效率问题）</h4><blockquote><p>首先是<strong>基础架构和目录设计</strong>，因为大屏项目涉及很多模块（比如设备总览、数据报表、设置弹窗），如果目录混乱，后期维护会很麻烦，而 Vite 相比 Webpack 有更快的热更新速度，更适合大屏开发时的实时调试。</p><p>我做了两个关键动作：</p><ul><li><p><strong>技术选型落地</strong>：直接采用 Vue3 的<code>&lt;script setup&gt;</code>语法糖（组合式 API）+ Vite 作为构建工具，替代了传统的 Vue2+Webpack，开发时的热更新速度从原来的几秒降到了几十毫秒，大大提升了开发效率。</p></li><li><p>模块化目录设计</p><p>：按照 “功能 + 类型” 的维度划分目录，比如：</p><ul><li><code>src/views</code>：存放大屏的主页面和各个子模块页面（如 index&#x2F;index.vue 是大屏主页面，right-top.vue 是右上模块）；</li><li><code>src/components</code>：拆分出通用组件（如 ItemWrap 边框容器、screen-box 自适应容器）和业务组件（如 echarts 图表组件、数据轮播组件）；</li><li><code>src/stores</code>：用 Pinia 按功能拆分状态模块（如 settingStore 处理全局配置）；</li><li><code>src/utils</code>：存放防抖、格式化等工具函数；</li><li><code>src/assets</code>：统一管理图片、样式等静态资源。</li></ul></li></ul><p>这样的目录结构让团队成员能快速找到对应模块的代码，后期新增功能或修改 bug 时，维护成本大大降低。</p></blockquote><h4 id="2-整合第三方库：ECharts-按需注册、VueUse-工具库复用（解决：打包体积大、开发重复造轮子问题）"><a href="#2-整合第三方库：ECharts-按需注册、VueUse-工具库复用（解决：打包体积大、开发重复造轮子问题）" class="headerlink" title="2. 整合第三方库：ECharts 按需注册、VueUse 工具库复用（解决：打包体积大、开发重复造轮子问题）"></a>2. 整合第三方库：ECharts 按需注册、VueUse 工具库复用（解决：打包体积大、开发重复造轮子问题）</h4><blockquote><p>其次是<strong>第三方库的轻量化整合</strong>，因为大屏项目核心是数据可视化，需要用到 ECharts，但 ECharts 全量导入会导致打包体积过大；同时开发中会用到很多通用功能（如防抖、监听窗口大小），重复写工具函数会浪费时间。</p><p>我针对这两个问题做了处理：</p><ul><li><strong>ECharts 按需注册</strong>：没有直接引入整个 ECharts，而是在<code>echarts.ts</code>文件中，只导入需要的渲染器（CanvasRenderer）、图表类型（柱状图、折线图、地图、饼图）和组件（提示框、图例、网格），然后通过<code>use()</code>方法注册这些模块，最后封装成全局的<code>&lt;v-chart&gt;</code>组件供业务使用。这样一来，ECharts 的引入体积减少了 70% 以上，既满足了可视化需求，又不会让打包文件过大。</li><li><strong>VueUse 工具库整合</strong>：直接引入 VueUse 库（比如<code>useWindowSize</code>监听窗口大小、<code>useDebounce</code>实现防抖），替代了自己手写这些工具函数，既保证了代码的健壮性，又节省了开发时间。比如监听窗口 resize 时，直接用<code>useWindowSize</code>就能获取窗口尺寸，不用再写原生的 addEventListener。</li></ul></blockquote><h4 id="3-封装大屏自适应容器组件：支持-1920-1080-设计稿适配、全屏-等比缩放（解决：多设备显示不一致问题）"><a href="#3-封装大屏自适应容器组件：支持-1920-1080-设计稿适配、全屏-等比缩放（解决：多设备显示不一致问题）" class="headerlink" title="3. 封装大屏自适应容器组件：支持 1920*1080 设计稿适配、全屏 &#x2F; 等比缩放（解决：多设备显示不一致问题）"></a>3. 封装大屏自适应容器组件：支持 1920*1080 设计稿适配、全屏 &#x2F; 等比缩放（解决：多设备显示不一致问题）</h4><blockquote><p>最后是<strong>核心的大屏自适应组件封装</strong>，因为大屏设计稿是按照 1920*1080 的尺寸做的，但实际部署时会用到不同尺寸的屏幕（比如 2K 屏、4K 屏、不同比例的显示器），如果直接写固定尺寸，会导致内容变形或显示不全。</p><p>我封装了一个<code>screen-box.vue</code>组件，核心逻辑是：</p><ul><li><p><strong>基础配置</strong>：组件接收<code>width</code>（默认 1920）、<code>height</code>（默认 1080）、<code>fullScreen</code>（是否全屏）、<code>autoScale</code>（是否自动缩放）等 props，对应设计稿的宽高比和适配模式。</p></li><li><p>适配逻辑</p><p>：</p><ul><li>首先初始化时获取设计稿宽高和当前窗口尺寸，计算缩放比例；</li><li>非全屏模式下，按宽高的最小比例进行等比缩放，保证内容不变形，同时计算 margin 让内容居中；</li><li>全屏模式下，按窗口的宽高比例分别缩放，让内容铺满整个屏幕；</li><li>结合防抖函数监听窗口 resize 事件，当窗口大小变化时，重新计算缩放比例，避免频繁计算导致卡顿。</li></ul></li><li><p><strong>插槽设计</strong>：组件内部留了<code>&lt;slot&gt;</code>插槽，业务模块可以直接嵌套在里面，不用每个模块都写一遍适配逻辑。</p></li></ul><p>这个组件作为大屏的根容器，让整个项目在不同设备上都能保持一致的显示效果，比如在 4K 屏上内容会等比放大，在 1366*768 的屏幕上会等比缩小，兼容率达到了 99%。</p></blockquote><h3 id="三、总结（收尾，强调架构的价值）"><a href="#三、总结（收尾，强调架构的价值）" class="headerlink" title="三、总结（收尾，强调架构的价值）"></a>三、总结（收尾，强调架构的价值）</h3><blockquote><p>整体来说，这套架构搭建的思路是 <strong>“轻量化、模块化、可复用”</strong>：通过 Vue3+Vite 提升开发效率，通过模块化目录和按需引入减少维护成本和打包体积，通过封装自适应组件解决核心的多设备适配问题，最终让整个大屏项目既能高效开发，又能稳定运行在各种场景下。</p></blockquote><p><strong>亮点2：独立开发核心组件体系：封装带装饰性边框的内容容器（ItemWrap）、特殊样式标题组件、多类型</strong></p><p><strong>ECharts 图表组件（折线图、柱状图、地图等），累计封装通用组件 15+，组件复用率达 80%，减少重</strong></p><p><strong>复开发时间 40%；</strong></p><blockquote><p>在这个大屏数据可视化项目中，有很多重复的 UI 元素和功能模块（比如每个数据模块都有装饰性边框、渐变标题，每个模块都要用到 ECharts 图表），如果每个模块都重复写这些代码，不仅开发效率低，还会导致样式不统一、后期维护困难。所以我基于 Vue3 的组件化思想，按「通用 UI 组件」和「业务功能组件」两类，封装了 15 + 通用组件，形成了核心组件体系，最终实现 80% 的组件复用率，减少了 40% 的重复开发时间。</p></blockquote><h3 id="二、分点拆解（结合具体组件案例，讲清封装思路和实现）"><a href="#二、分点拆解（结合具体组件案例，讲清封装思路和实现）" class="headerlink" title="二、分点拆解（结合具体组件案例，讲清封装思路和实现）"></a>二、分点拆解（结合具体组件案例，讲清封装思路和实现）</h3><h4 id="1-通用-UI-组件封装：ItemWrap-内容容器-特殊样式标题组件（解决：样式统一、布局复用问题）"><a href="#1-通用-UI-组件封装：ItemWrap-内容容器-特殊样式标题组件（解决：样式统一、布局复用问题）" class="headerlink" title="1. 通用 UI 组件封装：ItemWrap 内容容器 + 特殊样式标题组件（解决：样式统一、布局复用问题）"></a>1. 通用 UI 组件封装：ItemWrap 内容容器 + 特殊样式标题组件（解决：样式统一、布局复用问题）</h4><blockquote><p>首先是<strong>通用 UI 组件的封装</strong>，这是大屏项目中使用频率最高的部分，核心是把重复的装饰样式和布局逻辑抽离成组件。</p><h5 id="（1）ItemWrap-带装饰性边框的内容容器组件"><a href="#（1）ItemWrap-带装饰性边框的内容容器组件" class="headerlink" title="（1）ItemWrap 带装饰性边框的内容容器组件"></a>（1）ItemWrap 带装饰性边框的内容容器组件</h5><p><strong>为什么封装</strong>：大屏的每个数据模块（比如设备总览、用户总览、报警列表）都需要一个带装饰性边框（DataV 的 borderBox13）、标题栏、内边距的容器，如果每个模块都写一遍边框样式、标题布局，代码会非常冗余。</p><p><strong>怎么封装</strong>：</p><ul><li>第一步，组件接收核心 Props：<code>title</code>（模块标题）、<code>class</code>（自定义样式类）、<code>boxStyle</code>&#x2F;<code>wrapperStyle</code>（自定义样式对象），满足不同模块的个性化需求；</li><li>第二步，在组件内部整合 DataV 的装饰性边框组件（borderBox13），嵌套插槽（<code>&lt;slot&gt;</code>），把模块的具体内容留给业务组件填充；</li><li>第三步，抽离统一的布局样式（比如内边距、标题栏的渐变文字样式、模块间距），让所有模块的容器风格保持一致。</li></ul><p>核心代码逻辑大概是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;template&gt;</span><br><span class="line">  &lt;border-box13 :style=&quot;boxStyle&quot; class=&quot;item-wrap&quot;&gt;</span><br><span class="line">   &lt;!-- 标题栏 --&gt;</span><br><span class="line">    &lt;div class=&quot;item-title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;</span><br><span class="line">   &lt;!-- 业务内容插槽 --&gt;</span><br><span class="line">    &lt;div class=&quot;item-content&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;</span><br><span class="line"> &lt;/border-box13&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&gt;&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineProps, withDefaults &#125; from &#x27;vue&#x27;;</span><br><span class="line">&gt;import &#123; BorderBox13 &#125; from &#x27;@jiaminghi/data-view&#x27;;</span><br><span class="line"></span><br><span class="line">// 定义Props，设置默认值</span><br><span class="line">const props = withDefaults(defineProps&lt;&#123;</span><br><span class="line">  title: string;</span><br><span class="line">  boxStyle?: CSSProperties;</span><br><span class="line">&#125;&gt;(), &#123;</span><br><span class="line">  title: &#x27;默认标题&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>怎么复用</strong>：在业务模块中，只需要一行代码就能引入容器，填充内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemWrap title=&quot;设备总览&quot;&gt;</span><br><span class="line">  &lt;!-- 这里放设备总览的具体内容，比如ECharts图表、数据统计 --&gt;</span><br><span class="line">  &lt;LeftTop /&gt;</span><br><span class="line">&lt;/ItemWrap&gt;</span><br></pre></td></tr></table></figure><h5 id="（2）特殊样式标题组件"><a href="#（2）特殊样式标题组件" class="headerlink" title="（2）特殊样式标题组件"></a>（2）特殊样式标题组件</h5><p><strong>为什么封装</strong>：大屏的标题都需要渐变文字、字间距、粗体等特殊样式（比如 “cby6666666” 的渐变标题），还有的标题带左右装饰线，重复写这些样式太麻烦。</p><p><strong>怎么封装</strong>：</p><ul><li>抽离统一的文字渐变样式（<code>-webkit-background-clip: text</code>）、字间距、字体大小等样式；</li><li>接收<code>text</code>（标题文字）、<code>type</code>（标题类型，比如带装饰线 &#x2F; 纯文字）等 Props，支持不同场景的标题样式；</li><li>比如带装饰线的标题，组件内部实现左右装饰线的布局，业务组件只需要传入文字即可。</li></ul><p><strong>效果</strong>：这两个 UI 组件覆盖了大屏所有模块的容器和标题需求，复用率达到 90% 以上，每个模块不用再写重复的样式代码。</p></blockquote><h4 id="2-业务功能组件：多类型-ECharts-图表组件（解决：图表配置重复、数据渲染逻辑冗余问题）"><a href="#2-业务功能组件：多类型-ECharts-图表组件（解决：图表配置重复、数据渲染逻辑冗余问题）" class="headerlink" title="2. 业务功能组件：多类型 ECharts 图表组件（解决：图表配置重复、数据渲染逻辑冗余问题）"></a>2. 业务功能组件：多类型 ECharts 图表组件（解决：图表配置重复、数据渲染逻辑冗余问题）</h4><blockquote><p>其次是<strong>业务功能组件的封装</strong>，核心是把 ECharts 的初始化、配置、数据渲染逻辑抽离成通用组件，支持折线图、柱状图、地图、饼图等多类型图表。</p><p><strong>为什么封装</strong>：每个 ECharts 图表都需要初始化实例、设置配置项、监听数据变化、销毁实例（避免内存泄漏），如果每个图表都写一遍这些逻辑，代码冗余且容易出 bug。</p><p><strong>怎么封装</strong>：</p><ul><li><p>第一步，封装基础的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;v-chart-base&gt;</span><br></pre></td></tr></table></figure><p>组件，抽离通用逻辑：</p><ol><li>接收核心 Props：<code>option</code>（图表配置项）、<code>width</code>&#x2F;<code>height</code>（图表尺寸）、<code>loading</code>（加载状态）；</li><li>在组件内部使用<code>ref</code>获取 DOM 元素，初始化 ECharts 实例；</li><li>用<code>watch</code>监听<code>option</code>的变化，调用<code>setOption</code>更新图表（加第二个参数<code>true</code>实现局部刷新，优化性能）；</li><li>在<code>onUnmounted</code>钩子中销毁 ECharts 实例，避免内存泄漏；</li></ol></li><li><p>第二步，基于基础组件封装业务图表组件（比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;chart-line&gt;</span><br></pre></td></tr></table></figure><p>折线图、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;chart-bar&gt;</span><br></pre></td></tr></table></figure><p>柱状图、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;chart-map&gt;</span><br></pre></td></tr></table></figure><p>地图）：</p><ol><li>每个业务图表组件预设统一的样式配置（比如坐标轴颜色、图例位置、tooltip 样式），保持大屏图表风格一致；</li><li>接收<code>data</code>（图表数据）作为 Props，内部把数据转换成 ECharts 的 option 配置，传递给基础组件；</li></ol></li></ul><p><strong>怎么复用</strong>：在业务模块中，只需要传入数据就能渲染图表，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;!-- 渲染折线图 --&gt;</span><br><span class="line">&lt;chart-line :data=&quot;deviceOnlineData&quot; /&gt;</span><br><span class="line">&gt;&lt;!-- 渲染地图 --&gt;</span><br><span class="line">&lt;chart-map :data=&quot;regionData&quot; /&gt;</span><br></pre></td></tr></table></figure><p><strong>额外优化</strong>：针对大屏的实时数据需求，在图表组件中增加了<code>autoRefresh</code>（自动刷新）Props，支持轮询获取数据并更新图表，不用每个业务模块都写定时器逻辑。</p></blockquote><h4 id="3-组件体系的管理与复用策略（解决：组件查找困难、复用不规范问题）"><a href="#3-组件体系的管理与复用策略（解决：组件查找困难、复用不规范问题）" class="headerlink" title="3. 组件体系的管理与复用策略（解决：组件查找困难、复用不规范问题）"></a>3. 组件体系的管理与复用策略（解决：组件查找困难、复用不规范问题）</h4><blockquote><p>为了让组件体系更好用，我还做了两点管理策略：</p><ul><li><strong>模块化目录划分</strong>：在<code>src/components</code>目录下，分<code>ui</code>（通用 UI 组件，如 ItemWrap、标题组件）、<code>chart</code>（ECharts 图表组件）、<code>common</code>（其他通用组件，如数据轮播、设置弹窗）三个子目录，让团队成员能快速找到需要的组件；</li><li><strong>全局注册 + 按需导入结合</strong>：对于使用频率极高的组件（如 ItemWrap、<code>&lt;v-chart-base&gt;</code>），在入口文件中全局注册，不用每个组件都导入；对于使用频率较低的业务图表组件，采用按需导入的方式，减少打包体积；</li><li><strong>添加组件注释</strong>：在组件的 Props 和方法上添加详细注释，比如 ItemWrap 的<code>title</code>Props 说明 “模块标题，支持字符串”，让团队成员不用看源码就知道怎么用。</li></ul></blockquote><h3 id="三、总结（强调组件封装的价值和效果）"><a href="#三、总结（强调组件封装的价值和效果）" class="headerlink" title="三、总结（强调组件封装的价值和效果）"></a>三、总结（强调组件封装的价值和效果）</h3><blockquote><p>整体来说，这套组件体系的封装思路是 <strong>“抽离重复逻辑、保留个性化入口、统一风格标准”</strong>：</p><ol><li>把重复的 UI 样式和功能逻辑抽离成组件，减少了 40% 的重复开发时间，原本需要一天开发的模块，现在半天就能完成；</li><li>通过 Props 和插槽提供个性化入口，满足不同模块的需求，组件复用率达到 80%；</li><li>统一了大屏的视觉风格和代码逻辑，后期维护时，只需要修改组件的代码，就能全局更新所有模块的样式或逻辑，比如修改 ItemWrap 的边框样式，所有模块的边框都会同步更新，维护成本大大降低。</li></ol></blockquote><p><strong>亮点3：优化性能与体验：通过路由懒加载、组件按需导入减小打包体积；使用防抖函数优化窗口 resize 事件，</strong></p><p><strong>避免频繁缩放计算；ECharts 图表采用局部刷新策略，保障渲染流畅，页面帧率稳定在 60fps 以上；</strong></p><h4 id="1-路由懒加载减小初始打包体积"><a href="#1-路由懒加载减小初始打包体积" class="headerlink" title="1. 路由懒加载减小初始打包体积"></a>1. 路由懒加载减小初始打包体积</h4><p>项目通过路由懒加载机制优化首屏加载速度，在src&#x2F;router&#x2F;index.js中可以看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component: () =&gt; import(/* webpackChunkName: &quot;LSD.bighome&quot; */ &#x27;../views/indexs/index.vue&#x27;)</span><br></pre></td></tr></table></figure><ul><li>采用<code>import()</code>动态导入语法，将路由组件分割为独立的代码块</li><li>通过<code>webpackChunkName</code>注释实现代码块命名，便于生产环境的资源管理</li><li>仅在访问对应路由时才加载相关组件，减少初始加载的资源体积</li></ul><h4 id="2-组件按需导入控制打包大小"><a href="#2-组件按需导入控制打包大小" class="headerlink" title="2. 组件按需导入控制打包大小"></a>2. 组件按需导入控制打包大小</h4><ul><li><strong>Element UI 按需导入</strong>：在main.js中仅导入项目所需的组件（Radio&#x2F;Button 等），而非全量导入</li></ul><h4 id="3-防抖函数优化窗口-resize-事件"><a href="#3-防抖函数优化窗口-resize-事件" class="headerlink" title="3. 防抖函数优化窗口 resize 事件"></a>3. 防抖函数优化窗口 resize 事件</h4><p>项目在多个场景应用防抖函数处理高频事件：</p><ul><li><p><strong>工具函数实现</strong>：src&#x2F;utils&#x2F;index.js中定义了通用防抖函数</p></li><li><pre><code>export function debounce(fn, delay) &#123;  var timer;  return function () &#123;    var context = this;    var args = arguments;    clearTimeout(timer);    timer = setTimeout(function () &#123;      fn.apply(context, args);    &#125;, delay);  &#125;;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 4. ECharts 图表性能优化策略</span><br><span class="line"></span><br><span class="line">- **组件封装与局部刷新**：src/components/echart/index.vue中实现了优化的图表组件</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  watch: &#123;</span><br><span class="line">    options: &#123;</span><br><span class="line">      handler (options) &#123;</span><br><span class="line">        // 设置true清空echart缓存，只更新变化的数据</span><br><span class="line">        this.chart.setOption(options, true)</span><br><span class="line">      &#125;,</span><br><span class="line">      deep: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>  - 通过深度监听 options 变化，仅更新修改的数据部分，避免全量重绘  - **事件交互优化**：在图表组件中（如right-top.vue）处理鼠标交互时暂停轮询    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myChart.on(&quot;mouseover&quot;, (params) =&gt; &#123;</span><br><span class="line">  this.clearData(); // 鼠标悬停时清除定时器</span><br><span class="line">&#125;);</span><br><span class="line">myChart.on(&quot;mouseout&quot;, (params) =&gt; &#123;</span><br><span class="line">  this.timer = setInterval(looper, this.$store.state.setting.echartsAutoTime);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>    - 避免交互时的数据更新冲突，保持界面流畅    - **数据分片与按需渲染**：在处理大量数据时（如报警记录），通过分页加载（`limitNum: 50`）控制单次渲染数据量，避免一次性渲染过多数据导致的卡顿</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP1.0/1.1/2.0 的区别</title>
      <link href="/2025/10/24/%E8%AE%A1%E7%BD%91/HTTP1.01.12.0%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/10/24/%E8%AE%A1%E7%BD%91/HTTP1.01.12.0%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP1-0-1-1-2-0-的区别"><a href="#HTTP1-0-1-1-2-0-的区别" class="headerlink" title="HTTP1.0&#x2F;1.1&#x2F;2.0 的区别"></a>HTTP1.0&#x2F;1.1&#x2F;2.0 的区别</h2><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><p>HTTP 协议的第⼆个版本，第⼀个在通讯中指定版本号的HTTP协议版本</p><p>HTTP 1.0 <strong>浏览器与服务器只保持短暂的连接</strong>，<strong>每次请求都需要与服务器建⽴⼀个 TCP 连接</strong></p><p>服务器完成<strong>请求处理后⽴即断开 TCP 连接</strong>，服务器不跟踪每个客⼾也不记录过去的请求</p><p>简单来讲，<strong>每次与服务器交互，都需要新开⼀个连接</strong></p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><p>在 HTTP1.1 中<strong>，默认⽀持⻓连接（ Connection: keep-alive ）</strong>，即在<strong>⼀个TCP连接上可以传</strong></p><p><strong>送多个 HTTP 请求和响应，减少了建⽴和关闭连接的消耗和延迟</strong></p><p>建⽴⼀次连接，多次请求均由这个连接完成</p><p>这样，在加载 html ⽂件的时候，⽂件中多个请求和响应就可以在⼀个连接中传输</p><p>同时， HTTP 1.1 还允许客⼾端不⽤等待上⼀次请求结果返回，就可以发出下⼀次请求，但服务器端</p><p>必须按照接收到客⼾端请求的先后顺序依次回送响应结果，以保证客⼾端能够区分出每次请求的响应</p><p>内容，这样也显著地减少了整个下载过程所需要的时间</p><p>同时， HTTP1.1 在 HTTP1.0 的基础上，增加更多的请求头和响应头来完善的功能，如下：</p><p>• </p><p>引⼊了更多的缓存控制策略，如If-Unmodified-Since, If-Match, If-None-Match等缓存头来控制缓</p><p>存策略</p><p>• </p><p>引⼊range，允许值请求资源某个部分</p><p>• </p><p>引⼊host，实现了在⼀台WEB服务器上可以在同⼀个IP地址和端⼝号上使⽤不同的主机名来创建多</p><p>个虚拟WEB站点</p><p>并且还添加了其他的请求⽅法： put 、 delete 、 options</p><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>⽽ HTTP2.0 在相⽐之前版本，性能上有很⼤的提升，如添加了⼀个特性：</p><p>• </p><p><strong>多路复⽤</strong></p><p>HTTP&#x2F;2 <strong>复⽤ TCP 连接</strong>，在⼀个连接⾥，<strong>客⼾端和浏览器都可以同时发送多个请求或回应</strong>，⽽且不</p><p>⽤按照顺序⼀⼀对应，这样就避免了”队头堵塞”</p><p>• </p><p><strong>⼆进制分帧</strong></p><p>帧是 HTTP2 通信中最⼩单位信息</p><p>HTTP&#x2F;2 采⽤<strong>⼆进制格式传输数据</strong>，⽽⾮ HTTP <strong>1.x 的⽂本格式</strong>，<strong>解析起来更⾼效</strong></p><p>将请求和响应数据分割为更⼩的帧，并且它们采⽤⼆进制编码</p><p>HTTP2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流每个数据流都以消息的形式发送，⽽消息⼜由⼀个或多个帧组成。多个帧之间可以乱序发送，根据帧</p><p>⾸部的流标识可以重新组装，这也是多路复⽤同时发送数据的实现条件</p><p>• </p><p>⾸部压缩</p><p>• </p><p>服务器推送</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HTTP1.0：</p><p>• </p><p>浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建⽴⼀个TCP连接</p><p>HTTP1.1：</p><p>• </p><p>引⼊了持久连接，即TCP连接默认不关闭，可以被多个请求复⽤</p><p>• </p><p>在同⼀个TCP连接⾥⾯，客⼾端可以同时发送多个请求</p><p>• </p><p>虽然允许复⽤TCP连接，但是同⼀个TCP连接⾥⾯，所有的数据通信是按次序进⾏的，服务器只有</p><p>处理完⼀个请求，才会接着处理下⼀个请求。如果前⾯的处理特别慢，后⾯就会有许多请求排队等</p><p>着</p><p>• </p><p>新增了⼀些请求⽅法</p><p>• </p><p>新增了⼀些请求头和响应头</p><p>HTTP2.0：</p><p>• </p><p>采⽤⼆进制格式⽽⾮⽂本格式</p><p>• </p><p>完全多路复⽤，⽽⾮有序并阻塞的、只需⼀个连接即可实现并⾏</p><p>• </p><p>使⽤报头压缩，降低开销</p><p>• </p><p>服务器推送</p>]]></content>
      
      
      <categories>
          
          <category> 计网知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 和 HTTPS</title>
      <link href="/2025/10/24/%E8%AE%A1%E7%BD%91/HTTP%20%E5%92%8C%20HTTPS/"/>
      <url>/2025/10/24/%E8%AE%A1%E7%BD%91/HTTP%20%E5%92%8C%20HTTPS/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP (HyperText Transfer Protocol)，即超⽂本运输协议，是<strong>实现⽹络通信的⼀种规范</strong></p><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251220194735849.png" alt="image-20251220194735808"></p><p>在计算机和⽹络世界有，存在不同的协议，如⼴播协议、寻址协议、路由协议等等……</p><p>⽽ <strong>HTTP 是⼀个传输协议</strong>，即将数据由A传到B或将B传输到A，并且 A 与 B 之间能够存放很多第三</p><p>⽅，如： A&lt;&#x3D;&gt;X&lt;&#x3D;&gt;Y&lt;&#x3D;&gt;Z&lt;&#x3D;&gt;B</p><p>传输的数据并不是计算机底层中的⼆进制包，⽽是完整的、有意义的数据，如HTML ⽂件, 图⽚⽂件,</p><p>查询结果等超⽂本，能够被上层应⽤识别</p><p>在实际应⽤中， HTTP 常被<strong>⽤于在 Web 浏览器和⽹站服务器之间传递信</strong>息，<strong>以明⽂⽅式发送内容</strong>，</p><p>不提供任何⽅式的数据加密特点如下：</p><p>• </p><p>⽀持客⼾&#x2F;服务器模式</p><p>• </p><p>简单快速：客⼾向服务器请求服务时，只需传送请求⽅法和路径。由于HTTP协议简单，使得HTTP</p><p>服务器的程序规模⼩，因⽽通信速度很快</p><p>• </p><p><strong>灵活</strong>：HTTP<strong>允许传输任意类型的数据对象</strong>。正在传输的类型由Content-Type加以标记</p><p>• </p><p><strong>⽆连接</strong>：⽆连接的含义是限制<strong>每次连接只处理⼀个请求</strong>。服务器处理完客⼾的请求，并收到客⼾的</p><p>应答后，即断开连接。采⽤这种⽅式可以节省传输时间</p><p>• </p><p><strong>⽆状态</strong>：HTTP协议<strong>⽆法根据之前的状态进⾏本次的请求处理</strong></p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>在上述介绍 HTTP 中，了解到 HTTP 传递信息是以明⽂的形式发送内容，这并不安全。⽽ HTTPS 出</p><p>现正是为了解决 HTTP 不安全的特性</p><p>为了保证这些隐私数据能加密传输，让 HTTP 运⾏安全的 SSL&#x2F;TLS 协议上，即 <strong>HTTPS &#x3D; HTTP +</strong></p><p><strong>SSL&#x2F;TLS</strong>，<strong>通过 SSL 证书来验证服务器的⾝份，并为浏览器和服务器之间的通信进⾏加密</strong></p><p>SSL 协议位于 TCP&#x2F;IP 协议与各种应⽤层协议之间，浏览器和服务器在使⽤ SSL 建⽴连接时需要</p><p>选择⼀组恰当的加密算法来实现安全通信，为数据通讯提供安全⽀持</p><p>• </p><p>⾸先客⼾端通过URL访问服务器建⽴SSL连接</p><p>• </p><p>服务端收到客⼾端请求后，会将⽹站⽀持的证书信息（证书中包含公钥）传送⼀份给客⼾端</p><p>• </p><p>客⼾端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级</p><p>• </p><p>客⼾端的浏览器根据双⽅同意的安全等级，建⽴会话密钥，然后利⽤⽹站的公钥将会话密钥加密，</p><p>并传送给⽹站</p><p>• </p><p>服务器利⽤⾃⼰的私钥解密出会话密钥</p><p>• </p><p>服务器利⽤会话密钥加密与客⼾端之间的通信</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>• </p><p>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明⽂的，是不安全的，HTTPS使⽤了</p><p>SSL&#x2F;TLS协议进⾏了加密处理，相对更安全</p><p>• </p><p>HTTP 和 HTTPS <strong>使⽤连接⽅式不同</strong>，<strong>默认端⼝也不⼀样，HTTP是80，HTTPS是443•</strong> </p><p>HTTPS 由于需要设计加密以及多次握⼿，性能⽅⾯不如 HTTP</p><p>• </p><p>HTTPS需要SSL，SSL 证书需要钱，功能越强⼤的证书费⽤越⾼</p>]]></content>
      
      
      <categories>
          
          <category> 计网知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 常⻅的状态码是什么</title>
      <link href="/2025/10/23/%E8%AE%A1%E7%BD%91/HTTP%20%E5%B8%B8%E2%BB%85%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2025/10/23/%E8%AE%A1%E7%BD%91/HTTP%20%E5%B8%B8%E2%BB%85%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-常⻅的状态码是什么"><a href="#HTTP-常⻅的状态码是什么" class="headerlink" title="HTTP 常⻅的状态码是什么"></a>HTTP 常⻅的状态码是什么</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>HTTP状态码（英语：HTTP Status Code），⽤以表⽰⽹⻚服务器超⽂本传输协议响应状态的3位数字</p><p>它由 RFC 2616规范定义的，并得到 RFC 2518 、 RFC 2817 、 RFC 2295 、 RFC 2774 与</p><p>RFC 4918 等规范扩展</p><p>简单来讲， http 状态码的作⽤是服务器告诉客⼾端当前请求响应的状态，通过状态码就能判断和分</p><p>析服务器的运⾏状态</p><p>7.2. 分类</p><p>状态码第⼀位数字决定了不同的响应状态，有如下：</p><p>• </p><p>1 表⽰消息</p><p>• </p><p>2 表⽰成功</p><p>• </p><p>3 表⽰重定向</p><p>• </p><p>4 表⽰请求错误</p><p>• </p><p>5 表⽰服务器错误</p><p>7.2.1. 1xx</p><p><strong>代表请求已被接受，需要继续处理。这类响应是临时响应</strong>，只包含状态⾏和某些可选的响应头信息，</p><p>并以空⾏结束</p><p>常⻅的有：• </p><p>100（客⼾端继续发送请求，这是临时响应）：这个临时响应是⽤来通知客⼾端它的部分请求已经</p><p>被服务器接收，且仍未被拒绝。客⼾端应当继续发送请求的剩余部分，或者如果请求已经完成，忽</p><p>略这个响应。服务器必须在请求完成后向客⼾端发送⼀个最终响应</p><p>• </p><p>101：服务器根据客⼾端的请求切换协议，主要⽤于websocket或http2升级</p><p>7.2.2. <strong>2xx</strong></p><p><strong>代表请求已成功被服务器接收、理解、并接受</strong></p><p>常⻅的有：</p><p>• </p><p>200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回</p><p>• </p><p>201（已创建）：请求成功并且服务器创建了新的资源</p><p>• </p><p>202（已创建）：服务器已经接收请求，但尚未处理</p><p>• </p><p>203（⾮授权信息）：服务器已成功处理请求，但返回的信息可能来⾃另⼀来源</p><p>• </p><p>204（⽆内容）：服务器成功处理请求，但没有返回任何内容</p><p>• </p><p>205（重置内容）：服务器成功处理请求，但没有返回任何内容</p><p>• </p><p>206（部分内容）：服务器成功处理了部分请求</p><p>7.2.3. <strong>3xx</strong></p><p><strong>表⽰要完成请求，需要进⼀步操作</strong>。 通常，这些状态代码⽤来重定向</p><p>常⻅的有：</p><p>• </p><p>300（多种选择）：针对请求，服务器可执⾏多种操作。 服务器可根据请求者 (user agent) 选择⼀</p><p>项操作，或提供操作列表供请求者选择</p><p>• </p><p>301（永久移动）：请求的⽹⻚已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的</p><p>响应）时，会⾃动将请求者转到新位置</p><p>• </p><p>302（临时移动）： 服务器⽬前从不同位置的⽹⻚响应请求，但请求者应继续使⽤原有位置来进⾏</p><p>以后的请求</p><p>• </p><p>303（查看其他位置）：请求者应当对不同的位置使⽤单独的 GET 请求来检索响应时，服务器返回</p><p>此代码</p><p>• </p><p>305 （使⽤代理）： 请求者只能使⽤代理访问请求的⽹⻚。 如果服务器返回此响应，还表⽰请求者</p><p>应使⽤代理</p><p>• </p><p>307 （临时重定向）： 服务器⽬前从不同位置的⽹⻚响应请求，但请求者应继续使⽤原有位置来进</p><p>⾏以后的请求</p><p>7.2.4. <strong>4xx</strong></p><p><strong>代表了客⼾端看起来可能发⽣了错误，妨碍了服务器的处理常⻅的有：</strong></p><p>• </p><p>400（错误请求）： 服务器不理解请求的语法</p><p>• </p><p>401（未授权）： 请求要求⾝份验证。 对于需要登录的⽹⻚，服务器可能返回此响应。</p><p>• </p><p>403（禁⽌）： 服务器拒绝请求</p><p>• </p><p>404（未找到）： 服务器找不到请求的⽹⻚</p><p>• </p><p>405（⽅法禁⽤）： 禁⽤请求中指定的⽅法</p><p>• </p><p>406（不接受）： ⽆法使⽤请求的内容特性响应请求的⽹⻚</p><p>• </p><p>407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使⽤代理</p><p>• </p><p>408（请求超时）： 服务器等候请求时发⽣超时</p><p>7.2.5. <strong>5xx</strong></p><p><strong>表⽰服务器⽆法完成明显有效的请求</strong>。这类状态码代表了服务器在处理请求的过程中有错误或者异常</p><p>状态发⽣</p><p>常⻅的有：</p><p>• </p><p>500（服务器内部错误）：服务器遇到错误，⽆法完成请求</p><p>• </p><p>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器⽆法识别请求⽅法时可能会返回</p><p>此代码</p><p>• </p><p>502（错误⽹关）： 服务器作为⽹关或代理，从上游服务器收到⽆效响应</p><p>• </p><p>503（服务不可⽤）： 服务器⽬前⽆法使⽤（由于超载或停机维护）</p><p>• </p><p>504（⽹关超时）： 服务器作为⽹关或代理，但是没有及时从上游服务器收到请求</p><p>• </p><p>505（HTTP 版本不受⽀持）： 服务器不⽀持请求中所⽤的 HTTP 协议版本</p><p>7.3. 适⽤场景</p><p>下⾯给出⼀些状态码的适⽤场景：</p><p>• </p><p>100：客⼾端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如</p><p>果不处理，客⼾端则不上传POST数据，如果处理，则POST上传数据。常⽤于POST⼤数据传输</p><p>• </p><p>206：⼀般⽤来做断点续传，或者是视频⽂件等⼤⽂件的加载</p><p>• </p><p>301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使⽤时，⽤⼾访问旧域名时⽤301就重</p><p>定向到新的域名</p><p>• </p><p>302：临时重定向不会缓存，常⽤ 于未登陆的⽤⼾访问⽤⼾中⼼重定向到登录⻚⾯</p><p>• </p><p>304：协商缓存，告诉客⼾端有缓存，直接使⽤缓存中的数据，返回⻚⾯的只有头部信息，是没有</p><p>内容部分</p><p>• </p><p>400：参数有误，请求⽆法被服务器识别• </p><p>403：告诉客⼾端进制访问该站点或者资源，如在外⽹环境下，然后访问只有内⽹IP才能访问的时</p><p>候则返回</p><p>• </p><p>404：服务器找不到资源时，或者服务器拒绝请求⼜不想说明理由时</p><p>• </p><p>503：服务器停机维护时，主动⽤503响应请求或 nginx 设置限速，超过限速，会返回503</p><p>• </p><p>504：⽹关超时</p>]]></content>
      
      
      <categories>
          
          <category> 计网知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GET 和 POST</title>
      <link href="/2025/10/23/%E8%AE%A1%E7%BD%91/GET%20%E5%92%8C%20POST/"/>
      <url>/2025/10/23/%E8%AE%A1%E7%BD%91/GET%20%E5%92%8C%20POST/</url>
      
        <content type="html"><![CDATA[<h2 id="GET-和-POST"><a href="#GET-和-POST" class="headerlink" title="GET 和 POST"></a>GET 和 POST</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>GET 和 POST ，两者是 <strong>HTTP 协议中发送请求的⽅法</strong></p><p> <strong>GET</strong></p><p>GET ⽅法请求⼀个指定资源的表⽰形式，使⽤<strong>GET的请求应该只被⽤于获取数据</strong></p><p><strong>POST</strong></p><p>POST ⽅法⽤于<strong>将实体提交到指定的资源</strong>，通常<strong>导致在服务器上的状态变化或副作⽤</strong></p><p><strong>本质上都是 TCP 链接</strong>，并⽆差别</p><p>但是由于 HTTP 的规定和浏览器&#x2F;服务器的限制，导致他们在应⽤过程中会体现出⼀些区别</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>• </p><p>GET在浏览器回退时是⽆害的，⽽POST会再次提交请求。</p><p>• </p><p>GET产⽣的URL地址可以被Bookmark，⽽POST不可以。</p><p>• </p><p>GET请求会被浏览器主动cache，⽽POST不会，除⾮⼿动设置。</p><p>• </p><p><strong>GET请求只能进⾏url编码，⽽POST⽀持多种编码⽅式</strong>。</p><p>• </p><p>GET请求参数会被完整保留在浏览器历史记录⾥，⽽POST中的参数不会被保留。</p><p>• </p><p><strong>GET请求在URL中传送的参数是有⻓度限制的，⽽POST没有</strong>。</p><p>• </p><p>对参数的数据类型，GET只接受ASCII字符，⽽POST没有限制。</p><p>• </p><p><strong>GET⽐POST更不安全，因为参数直接暴露在URL上，所以不能⽤来传递敏感信息</strong>。</p><p>• </p><p>GET参数通过URL传递，POST放在Request body中</p><h3 id="参数位置"><a href="#参数位置" class="headerlink" title="参数位置"></a>参数位置</h3><p>貌似从上⾯看到 GET 与 POST 请求区别⾮常⼤，但两者实质并没有区别⽆论 GET 还是 POST ，⽤的都是同⼀个传输层协议，所以在传输上没有区别</p><p>当不携带参数的时候，两者最⼤的区别为第⼀⾏⽅法名不同</p><p>POST &#x2F;uri HTTP&#x2F;1.1 \r\n</p><p>GET &#x2F;uri HTTP&#x2F;1.1 \r\n</p><p>当携带参数的时候，我们都知道 GET 请求是放在 url 中， POST 则放在 body 中</p>]]></content>
      
      
      <categories>
          
          <category> 计网知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS协议</title>
      <link href="/2025/10/23/%E8%AE%A1%E7%BD%91/DNS%E5%8D%8F%E8%AE%AE/"/>
      <url>/2025/10/23/%E8%AE%A1%E7%BD%91/DNS%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>DNS（Domain Names System），域名系统，是互联⽹⼀项服务，是进⾏域名和与之相对应的 IP 地</p><p>址进⾏转换的服务器</p><p><strong>简单来讲， DNS 相当于⼀个翻译官，负责将域名翻译成 ip 地址</strong></p><p>• </p><p>IP 地址：⼀⻓串能够唯⼀地标记⽹络上的计算机的数字</p><p>• </p><p>域名：是由⼀串⽤点分隔的名字组成的 Internet 上某⼀台计算机或计算机组的名称，⽤于在数据传</p><p>输时对计算机的定位标识</p><h3 id="查询⽅式"><a href="#查询⽅式" class="headerlink" title="查询⽅式"></a>查询⽅式</h3><p>DNS 查询的⽅式有两种：</p><p>• </p><p>递归查询：如果 A 请求 B，那么 B 作为请求的接收者⼀定要给 A 想要的答案</p><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251220195842749.png" alt="image-20251220195842670"></p><p>迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得</p><p>这个内容，但是⾃⼰并不去发出请求</p><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251220195905564.png" alt="image-20251220195905490"></p><h3 id="域名缓存"><a href="#域名缓存" class="headerlink" title="域名缓存"></a>域名缓存</h3><p>在域名服务器解析的时候，使⽤缓存保存域名和 IP 地址的映射</p><p>计算机中 DNS 的记录也分成了两种缓存⽅式：</p><p>• </p><p>浏览器缓存：浏览器在获取⽹站域名的实际 IP 地址后会对其进⾏缓存，减少⽹络请求的损耗</p><p>• </p><p>操作系统缓存：操作系统的缓存其实是⽤⼾⾃⼰配置的 hosts ⽂件</p><h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>解析域名的过程如下：</p><p>• </p><p>⾸先搜索浏览器的 DNS 缓存，缓存中维护⼀张域名与 IP 地址的对应表</p><p>• </p><p>若没有命中，则继续搜索操作系统的 DNS 缓存</p><p>• </p><p>若仍然没有命中，则操作系统将域名发送⾄本地域名服务器，本地域名服务器采⽤递归查询⾃⼰的</p><p>DNS 缓存，查找成功则返回结果</p><p>• </p><p>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进⾏迭代查询◦ </p><p>⾸先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本</p><p>地服务器</p><p>◦ </p><p>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的</p><p>地址</p><p>◦ </p><p>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</p><p>• </p><p>本地域名服务器将得到的 IP 地址返回给操作系统，同时⾃⼰将 IP 地址缓存起来</p><p>• </p><p>操作系统将 IP 地址返回给浏览器，同时⾃⼰也将 IP 地址缓存起</p><p>• </p><p>⾄此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起</p>]]></content>
      
      
      <categories>
          
          <category> 计网知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解UDP 和 TCP</title>
      <link href="/2025/10/22/%E8%AE%A1%E7%BD%91/%E7%90%86%E8%A7%A3UDP%20%E5%92%8C%20TCP/"/>
      <url>/2025/10/22/%E8%AE%A1%E7%BD%91/%E7%90%86%E8%A7%A3UDP%20%E5%92%8C%20TCP/</url>
      
        <content type="html"><![CDATA[<h2 id="理解UDP-和-TCP"><a href="#理解UDP-和-TCP" class="headerlink" title="理解UDP 和 TCP"></a>理解UDP 和 TCP</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP（User Datagram Protocol），⽤⼾数据包协议，<strong>是⼀个简单的⾯向数据报的通信协议</strong>，即对应</p><p>⽤层交下来的报⽂，不合并，不拆分，只是在其上⾯加上⾸部后就交给了下⾯的⽹络层</p><p>也就是说⽆论应⽤层交给 UDP 多⻓的报⽂，它统统发送，⼀次发送⼀个报⽂</p><p>⽽对接收⽅，接到后直接去除⾸部，交给上⾯的应⽤层就完成任务</p><p>UDP 报头包括4个字段，每个字段占⽤2个字节（即16个⼆进制位），标题短，开销⼩</p><p>特点如下：</p><p>• </p><p>UDP 不提供复杂的控制机制，利⽤ IP <strong>提供⾯向⽆连接的通信服务</strong></p><p>• </p><p>传输途中出现丢包，UDP 也不负责重发</p><p>• </p><p>当包的到达顺序出现乱序时，UDP没有纠正的功能。</p><p>• </p><p>并且它是将应⽤程序发来的数据在收到的那⼀刻，⽴即按照原样发送到⽹络上的⼀种机制。即使是</p><p>出现⽹络拥堵的情况，UDP 也⽆法进⾏流量控制等避免⽹络拥塞⾏为</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP（Transmission Control Protocol），传输控制协议，是⼀种可靠、<strong>⾯向字节流的通信协议</strong>，把</p><p>上⾯应⽤层交下来的数据看成⽆结构的字节流来发送</p><p>可以想象成流⽔形式的，发送⽅TCP会将数据放⼊“蓄⽔池”（缓存区），等到可以发送的时候就发</p><p>送，不能发送就等着，TCP会根据当前⽹络的拥塞状态来确定每个报⽂段的⼤⼩TCP 报⽂⾸部有20个字节，额外开销⼤</p><p>特点如下：</p><p>• </p><p>TCP充分地<strong>实现了数据传输时各种控制功能，可以进⾏丢包时的重发控制，还可以对次序乱掉的分</strong></p><p><strong>包进⾏顺序控制</strong>。⽽这些<strong>在 UDP 中都没有</strong>。</p><p>• </p><p>此外，<strong>TCP 作为⼀种⾯向有连接的协议</strong>，只有在确认通信对端存在时才会发送数据，从⽽可以控制</p><p>通信流量的浪费。</p><p>• </p><p>根据 TCP 的这些机制，在 IP 这种⽆连接的⽹络上也能够实现⾼可靠性的通信（ 主要通过检验和、</p><p>序列号、确认应答、重发控制、连接管理以及窗⼝控制等机制实现）</p><p>两者区别如下表所⽰：</p><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251220192726992.png" alt="image-20251220192726949"></p><p><strong>TCP</strong> 是⾯向连接的协议，<strong>建⽴连接3次握⼿、断开连接四次挥⼿</strong>，<strong>UDP</strong>是⾯向⽆连接，<strong>数据传输前</strong></p><p><strong>后不连接连接，发送端只负责将数据发送到⽹络，接收端从消息队列读取</strong></p><p>• </p><p>TCP 提供<strong>可靠</strong>的服务，传输过程采⽤流量控制、编号与确认、计时器等⼿段确保数据⽆差错，不丢</p><p>失。UDP 则尽可能传递数据，但不保证传递交付给对⽅• </p><p>TCP ⾯向字节流，将应⽤层报⽂看成⼀串⽆结构的字节流，分解为多个TCP报⽂段传输后，在⽬的</p><p>站重新装配。UDP协议⾯向报⽂，不拆分应⽤层报⽂，只保留报⽂边界，⼀次发送⼀个报⽂，接收</p><p>⽅去除报⽂⾸部后，原封不动将报⽂交给上层应⽤</p><p>• </p><p><strong>TCP 只能点对点全双⼯通信。UDP ⽀持⼀对⼀、⼀对多、多对⼀和多对多的交互通信</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计网知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握⼿和四次挥⼿</title>
      <link href="/2025/10/21/%E8%AE%A1%E7%BD%91/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E2%BC%BF%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E2%BC%BF/"/>
      <url>/2025/10/21/%E8%AE%A1%E7%BD%91/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E2%BC%BF%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E2%BC%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP三次握⼿和四次挥⼿"><a href="#TCP三次握⼿和四次挥⼿" class="headerlink" title="TCP三次握⼿和四次挥⼿"></a>TCP三次握⼿和四次挥⼿</h2><h3 id="三次握⼿"><a href="#三次握⼿" class="headerlink" title="三次握⼿"></a>三次握⼿</h3><p>三次握⼿（Three-way Handshake）其实就是指建⽴⼀个TCP连接时，需要客⼾端和服务器总共发送3</p><p>个包</p><p><strong>主要作⽤就是为了确认双⽅的接收能⼒和发送能⼒是否正常</strong>、指定⾃⼰的初始化序列号为后⾯的可靠</p><p>性传送做准备</p><p>过程如下：</p><p>• </p><p>第⼀次握⼿：客⼾端给服务端发⼀个 SYN 报⽂，并指明客⼾端的初始化序列号 ISN(c)，此时客⼾端</p><p>处于 SYN_SENT 状态</p><p>• </p><p>第⼆次握⼿：服务器收到客⼾端的 SYN 报⽂之后，会以⾃⼰的 SYN 报⽂作为应答，为了确认客⼾</p><p>端的 SYN，将客⼾端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态</p><p>• </p><p>第三次握⼿：客⼾端收到 SYN 报⽂之后，会发送⼀个 ACK 报⽂，值为服务器的ISN+1。此时客⼾端</p><p>处于 ESTABLISHED 状态。服务器收到 ACK 报⽂之后，也处于 ESTABLISHED 状态，此时，双⽅已</p><p>建⽴起了连接</p><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251220193400789.png" alt="image-20251220193400734"></p><p>上述每⼀次握⼿的作⽤如下：</p><p>• </p><p>第⼀次握⼿：客⼾端发送⽹络包，服务端收到了</p><p>这样服务端就能得出结论：客⼾端的发送能⼒、服务端的接收能⼒是正常的。</p><p>• </p><p>第⼆次握⼿：服务端发包，客⼾端收到了</p><p>这样客⼾端就能得出结论：服务端的接收、发送能⼒，客⼾端的接收、发送能⼒是正常的。不过此</p><p>时服务器并不能确认客⼾端的接收能⼒是否正常</p><p>• </p><p>第三次握⼿：客⼾端发包，服务端收到了。</p><p>这样服务端就能得出结论：客⼾端的接收、发送能⼒正常，服务器⾃⼰的发送、接收能⼒也正常</p><p>通过三次握⼿，就能确定双⽅的接收和发送能⼒是正常的。之后就可以正常通信了</p><h3 id="四次挥⼿"><a href="#四次挥⼿" class="headerlink" title="四次挥⼿"></a>四次挥⼿</h3><p>tcp 终⽌⼀个连接，需要经过四次挥⼿</p><p>过程如下：</p><p>• </p><p>第⼀次挥⼿：<strong>客⼾端发送⼀个 FIN 报⽂</strong>，报⽂中会指定⼀个序列号。此时客⼾端处于 FIN_WAIT1</p><p>状态，<strong>停⽌发送数据，等待服务端的确认</strong>• </p><p>第⼆次挥⼿：<strong>服务端收到 FIN</strong> 之后，会<strong>发送 ACK 报⽂</strong>，且把客⼾端的序列号值 +1 作为 ACK 报⽂的</p><p>序列号值，<strong>表明已经收到客⼾端的报⽂</strong>了，此时服务端处于 CLOSE_WAIT状态</p><p>• </p><p>第三次挥⼿：如果<strong>服务端也想断开连接</strong>了，<strong>和客⼾端的第⼀次挥⼿⼀样，发给 FIN 报⽂</strong>，且指定⼀</p><p>个序列号。此时服务端处于 LAST_ACK 的状态</p><p>• </p><p>第四次挥⼿：<strong>客⼾端收到 FIN 之后</strong>，<strong>⼀样发送⼀个 ACK 报⽂作为应答</strong>，且把服务端的序列号值 +1</p><p>作为⾃⼰ ACK 报⽂的序列号值，此时客⼾端处于 TIME_WAIT状态。需要过⼀阵⼦以确保服务端收</p><p>到⾃⼰的 ACK 报⽂之后才会进⼊ CLOSED 状态，<strong>服务端收到 ACK 报⽂之后，就处于关闭连接了</strong>，</p><p>处于 CLOSED 状态</p><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251220193809858.png" alt="image-20251220193809809"></p><h3 id="四次挥⼿原因"><a href="#四次挥⼿原因" class="headerlink" title="四次挥⼿原因"></a>四次挥⼿原因</h3><p>服务端在收到客⼾端断开连接 Fin 报⽂后，并不会⽴即关闭连接，⽽是先发送⼀个 ACK 包先告诉客</p><p>⼾端收到关闭连接的请求，只有当服务器的所有报⽂发送完毕之后，才发送 FIN 报⽂断开连接，因此</p><p>需要四次挥⼿</p>]]></content>
      
      
      <categories>
          
          <category> 计网知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>osi七层模型</title>
      <link href="/2025/10/21/%E8%AE%A1%E7%BD%91/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/10/21/%E8%AE%A1%E7%BD%91/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="osi七层模型"><a href="#osi七层模型" class="headerlink" title="osi七层模型"></a>osi七层模型</h2><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251220190812116.png" alt="image-20251220190803988"></p><p>1.2.1. <strong>应⽤层</strong></p><p>应⽤层位于 OSI 参考模型的第七层，其作⽤是<strong>通过应⽤程序间的交互来完成特定的⽹络应⽤</strong></p><p>该层协议定义了应⽤进程之间的交互规则，通过不同的应⽤层协议为不同的⽹络应⽤提供服务。例如</p><p>域名系统 DNS ，⽀持万维⽹应⽤的 HTTP 协议，电⼦邮件系统采⽤的 SMTP 协议等</p><p>在应⽤层交互的数据单元我们称之为报⽂</p><p>1.2.2. <strong>表⽰层</strong></p><p>表⽰层的作⽤是<strong>使通信的应⽤程序能够解释交换数据的含义</strong>，其位于 OSI 参考模型的第六层，向上为</p><p>应⽤层提供服务，向下接收来⾃会话层的服务</p><p>该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应⽤程序不必担⼼在各台计算机中表</p><p>⽰和存储的内部格式差异</p><p>1.2.3. <strong>会话层</strong></p><p><strong>会话层就是负责建⽴、管理和终⽌表⽰层实体之间的通信会话</strong></p><p>该层提供了数据交换的定界和同步功能，包括了建⽴检查点和恢复⽅案的⽅法</p><p>1.2.4. <strong>传输层</strong></p><p>传输层的主要任务是<strong>为两台主机进程之间的通信提供服务</strong>，<strong>处理数据包错误、数据包次序</strong>，以及其他</p><p>⼀些关键传输问题传输层向⾼层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的⼀层</p><p>其中，<strong>主要的传输层协议是 TCP 和 UDP</strong></p><p>1.2.5. <strong>⽹络层</strong></p><p><strong>两台计算机之间传送数据时其通信链路往往不⽌⼀条，所传输的信息甚⾄可能经过很多通信⼦⽹</strong></p><p><strong>⽹络层的主要任务就是选择合适的⽹间路由和交换节点，确保数据按时成功传送</strong></p><p>在发送数据时，⽹络层把传输层产⽣的报⽂或⽤⼾数据报封装成分组和包，向下传输到数据链路层</p><p>在⽹络层使⽤的协议是⽆连接的⽹际协议（Internet Protocol）和许多路由协议，因此我们通常把该</p><p>层简单地称为 IP 层</p><p>1.2.6. <strong>数据链路层</strong></p><p>数据链路层通常也叫做链路层，在物理层和⽹络层之间。<strong>两台主机之间的数据传输</strong>，总是在⼀段⼀段</p><p>的链路上传送的，这就需要使⽤专⻔的链路层协议</p><p>在两个相邻节点之间传送数据时，数据链路层将⽹络层交下来的 IP 数据报组装成帧，在两个相邻节</p><p>点间的链路上传送帧</p><p>每⼀帧的数据可以分成：报头 head 和数据 data 两部分:</p><p>• </p><p>head 标明数据发送者、接受者、数据类型，如 MAC地址</p><p>• </p><p>data 存储了计算机之间交互的数据</p><p>通过控制信息我们可以知道⼀个帧的起⽌⽐特位置，此外，也能使接收端检测出所收到的帧有⽆差</p><p>错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占⽤⽹络资源</p><p>1.2.7. <strong>物理层</strong></p><p>作为 OSI 参考模型中最低的⼀层，物理层的作⽤是<strong>实现计算机节点之间⽐特流的透明传送</strong></p><p>该层的主要任务是确定与传输媒体的接⼝的⼀些特性（机械特性、电⽓特性、功能特性，过程特性）</p><p>该层<strong>主要是和硬件有关</strong>，与软件关系不⼤</p>]]></content>
      
      
      <categories>
          
          <category> 计网知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商购物平台复盘</title>
      <link href="/2025/10/20/%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%95%86%E8%B4%AD%E7%89%A9%E5%B9%B3%E5%8F%B0/%E7%94%B5%E5%95%86%E8%B4%AD%E7%89%A9%E5%B9%B3%E5%8F%B0%E5%A4%8D%E7%9B%98/"/>
      <url>/2025/10/20/%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%95%86%E8%B4%AD%E7%89%A9%E5%B9%B3%E5%8F%B0/%E7%94%B5%E5%95%86%E8%B4%AD%E7%89%A9%E5%B9%B3%E5%8F%B0%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h2 id="电商购物平台复盘"><a href="#电商购物平台复盘" class="headerlink" title="电商购物平台复盘"></a>电商购物平台复盘</h2><p><strong>亮点1：商品模块：采用 “虚拟列表 + 分页加载” 方案，承载 10000 + 商品数据无卡顿；封装图片懒加载自</strong></p><p><strong>定义指令，有效减少页面初始加载的资源请求量，降低首屏渲染时间，优化大型页面的加载性能。</strong></p><p><strong>“虚拟列表 + 分页加载” 方案的实际应用</strong></p><ul><li>业务背景：生鲜商品品类繁多（水果、蔬菜、肉类等合计超 10000 种），传统列表渲染会一次性创建所有 DOM 元素，导致页面卡顿、滚动掉帧。</li><li>技术实现：<ul><li><strong>虚拟列表</strong>：使用<code>vue-virtual-scroller</code>库，只渲染可视区域内的商品卡片（约 10-15 个），滚动时动态计算可视范围并复用 DOM 元素。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;RecycleScroller</span><br><span class="line">    class=&quot;goods-list&quot;</span><br><span class="line">    :items=&quot;visibleGoods&quot;</span><br><span class="line">    :item-size=&quot;200&quot;  // 每个商品卡片的固定高度</span><br><span class="line">    @visible-items-changed=&quot;handleVisibleChange&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;template #default=&quot;&#123; item &#125;&quot;&gt;</span><br><span class="line">      &lt;GoodsCard :goods=&quot;item&quot; /&gt;  // 商品卡片组件</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/RecycleScroller&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ul><li><ul><li><strong>分页加载</strong>：配合后端接口实现分页，滚动到页面底部时触发加载下一页（页码 + 每页条数），同时将新数据追加到总数据池。</li></ul></li><li>效果：10000 + 商品数据下，DOM 节点数量从原来的 10000 + 减少到 30 个以内，滚动帧率稳定在 60fps，滑动时无卡顿感。</li></ul><p><strong>图片懒加载自定义指令的封装与应用</strong></p><ul><li><p>业务痛点：生鲜商品图片多且清晰（单张约 200-500KB），首屏若加载全部图片会产生大量请求，导致首屏加载缓慢。</p></li><li><p>实现方案：封装<code>v-lazy</code>自定义指令，基于<code>IntersectionObserver</code>API 监听图片是否进入视口，只加载可见区域图片。</p></li><li><pre><code>// 指令定义：directives/lazy.jsexport default &#123;  mounted(el, binding) &#123;    const observer = new IntersectionObserver((entries) =&gt; &#123;      entries.forEach(entry =&gt; &#123;        if (entry.isIntersecting) &#123;          // 图片进入视口时加载          el.src = binding.value  // 绑定的图片真实地址          observer.unobserve(el)  // 加载后停止监听        &#125;      &#125;)    &#125;)    observer.observe(el)  &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 应用场景：商品列表的缩略图、分类页的 banner 图均使用`v-lazy`指令，配合占位图（1KB 以内的灰色背景图）提升感知性能。 </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">**亮点二： 基于 Pinia 实现 “状态 - 视图 - 操作” 解耦，拆分 8 个业务模块，通过订阅机制实现跨模块数据联**</span><br><span class="line"></span><br><span class="line">**动，购物车与订单数据同步误差率降至 0**</span><br><span class="line"></span><br><span class="line">1. **状态 - 视图 - 操作解耦的实现**</span><br><span class="line"></span><br><span class="line">   - **状态层**：用 Pinia 定义独立的 store（如 cartStore、orderStore），只负责数据存储和核心计算（例如 cartStore 中定义商品总数、总价的 getter）</span><br><span class="line">   - **视图层**：组件只通过 store 获取数据和调用方法（如购物车组件通过 cartStore.goodsList 渲染列表，点击删除按钮调用 cartStore.removeItem ()）</span><br><span class="line">   - **操作层**：所有数据修改逻辑封装在 store 的 actions 中（如添加商品时的库存校验、价格计算等）</span><br><span class="line"></span><br><span class="line">2. **8 个业务模块的拆分**按电商业务域拆分出：用户模块（userStore）、商品模块（goodsStore）、购物车模块（cartStore）、订单模块（orderStore）、地址模块（addressStore）、收藏模块（collectStore）、优惠券模块（couponStore）、全局设置模块（appStore）。每个模块只管理自身相关数据，例如 cartStore 仅维护购物车商品、选中状态等数据。</span><br><span class="line"></span><br><span class="line">3. **跨模块数据联动的实际应用**通过 Pinia 的订阅机制（$subscribe）实现模块间通信：</span><br><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">   // orderStore中订阅cartStore的变化</span><br><span class="line">   cartStore.$subscribe((mutation, state) =&gt; &#123;</span><br><span class="line">     // 当购物车商品变化时，自动更新订单确认页的商品列表和总金额</span><br><span class="line">     if (mutation.type === &#x27;cart/addItem&#x27;) &#123;</span><br><span class="line">       this.syncOrderGoods(state.goodsList)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure> 1. 实际业务场景：用户在购物车修改商品数量后，订单确认页会实时更新对应商品的数量和总价，无需手动刷新。 2. **购物车与订单数据同步误差率降至 0 的效果**未优化前，由于购物车和订单数据分散在组件中，常出现 “购物车已修改但订单页未更新” 的问题（误差率约 8%）。通过 Pinia 的集中管理和订阅机制：    - 所有数据变更只有唯一入口（store 的 actions）    - 关联模块自动同步更新    - 配合本地持久化，解决页面刷新导致的数据不一致            最终实现从购物车到订单提交的全流程数据零误差，用户提交订单时不会出现 “商品已下架但仍能下单” 等异常情况。</code></pre></li></ul><p><strong>亮点三：用户模块：用 vee-validate 实现表单校验，配合路由守卫实现 “未登录跳转拦截”，登录页安全性测试通过率 100%</strong> </p><p><strong>vee-validate 表单校验的实际应用</strong></p><ul><li><p>针对登录页的手机号和密码字段，使用 vee-validate 定义了严格的校验规则：</p></li><li><pre><code>// 手机号校验：必须为11位数字且符合手机号规则defineRule(&#39;phone&#39;, (value) =&gt; &#123;  if (!value) return &#39;请输入手机号&#39;  if (!/^1[3-9]\d&#123;9&#125;$/.test(value)) return &#39;请输入正确的手机号&#39;  return true&#125;)// 密码校验：8-20位，包含数字和字母defineRule(&#39;password&#39;, (value) =&gt; &#123;  if (!value) return &#39;请输入密码&#39;  if (value.length &lt; 8 || value.length &gt; 20) return &#39;密码长度为8-20位&#39;  if (!/[0-9]/.test(value) || !/[a-zA-Z]/.test(value)) return &#39;密码需包含数字和字母&#39;&#125;)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**路由守卫实现 “未登录跳转拦截”**</span><br><span class="line"></span><br><span class="line">通过 Vue Router 的全局前置守卫，限制未登录用户访问需要权限的页面（如个人中心、订单页、结算页）：</span><br><span class="line"></span><br></pre></td></tr></table></figure>// 路由守卫配置router.beforeEach((to, from, next) =&gt; &#123;  const isLogin = userStore.isLogin // 从Pinia获取登录状态  // 需要登录的路由在meta中标记requireAuth: true  if (to.meta.requireAuth &amp;&amp; !isLogin) &#123;    // 未登录时跳转到登录页，并记录当前页面路径（登录后可跳转回来）    next(&#123; path: &#39;/login&#39;, query: &#123; redirect: to.fullPath &#125; &#125;)  &#125; else &#123;    next()  &#125;&#125;)</code></pre><ul><li>实际效果：用户点击 “去结算” 按钮时，若未登录会自动跳转到登录页，登录成功后再返回结算页，既保证了权限安全，又不影响用户操作流程。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue的生命周期</title>
      <link href="/2025/09/17/vue/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2025/09/17/vue/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="vue的生命周期"><a href="#vue的生命周期" class="headerlink" title="vue的生命周期"></a>vue的生命周期</h2><p>Vue2 生命周期可分为 4 大阶段，共 8 个核心钩子，执行顺序固定：</p><table><thead><tr><th>阶段</th><th>核心钩子（执行顺序）</th><th>说明</th></tr></thead><tbody><tr><td>初始化阶段</td><td>beforeCreate → created</td><td>实例创建，数据 &#x2F; 方法初始化</td></tr><tr><td>挂载阶段</td><td>beforeMount → mounted</td><td>实例挂载到 DOM 节点</td></tr><tr><td>更新阶段</td><td>beforeUpdate → updated</td><td>数据更新，DOM 重新渲染</td></tr><tr><td>销毁阶段</td><td>beforeDestroy → destroyed</td><td>实例销毁，清理资源</td></tr></tbody></table><h4 id="1-初始化阶段（实例创建）"><a href="#1-初始化阶段（实例创建）" class="headerlink" title="1. 初始化阶段（实例创建）"></a>1. 初始化阶段（实例创建）</h4><h5 id="（1）beforeCreate（创建前）"><a href="#（1）beforeCreate（创建前）" class="headerlink" title="（1）beforeCreate（创建前）"></a>（1）beforeCreate（创建前）</h5><ul><li><strong>执行时机</strong>：Vue 实例刚被创建，<code>data</code>、<code>methods</code>、<code>props</code> 等都未初始化，<code>el</code> 也未绑定。</li><li><strong>this 指向</strong>：已指向实例，但无法访问 <code>data</code>&#x2F;<code>methods</code>。</li><li><strong>使用场景</strong>：仅能做一些无依赖的初始化（如加载动画开启）。</li></ul><h5 id="（2）created（创建完成）"><a href="#（2）created（创建完成）" class="headerlink" title="（2）created（创建完成）"></a>（2）created（创建完成）</h5><ul><li><strong>执行时机</strong>：<code>data</code>、<code>methods</code>、<code>props</code> 已初始化完成，可访问，但 DOM 未生成（<code>$el</code> 不存在）。</li><li><strong>核心能力</strong>：可执行数据请求、初始化数据、监听事件等。</li><li><strong>注意</strong>：此时 DOM 未挂载，无法操作 DOM（如 <code>document.getElementById</code>）。</li><li><strong>使用场景</strong>：异步请求数据（无需等待 DOM）、初始化全局变量。</li></ul><h4 id="2-挂载阶段（DOM-渲染）"><a href="#2-挂载阶段（DOM-渲染）" class="headerlink" title="2. 挂载阶段（DOM 渲染）"></a>2. 挂载阶段（DOM 渲染）</h4><h5 id="（1）beforeMount（挂载前）"><a href="#（1）beforeMount（挂载前）" class="headerlink" title="（1）beforeMount（挂载前）"></a>（1）beforeMount（挂载前）</h5><ul><li><strong>执行时机</strong>：模板编译完成，即将挂载到 DOM 节点（<code>el</code> 已存在），但真实 DOM 未生成（<code>$el</code> 为虚拟 DOM）。</li><li><strong>核心能力</strong>：可最后修改数据（不会触发额外更新），仍无法操作真实 DOM。</li><li><strong>使用场景</strong>：挂载前的最后数据调整。</li></ul><h5 id="（2）mounted（挂载完成）"><a href="#（2）mounted（挂载完成）" class="headerlink" title="（2）mounted（挂载完成）"></a>（2）mounted（挂载完成）</h5><ul><li><strong>执行时机</strong>：实例挂载到真实 DOM 节点，<code>$el</code> 指向真实 DOM，DOM 可操作。</li><li><strong>核心能力</strong>：可操作 DOM（如初始化第三方插件：echarts、swiper）、执行依赖 DOM 的异步请求。</li><li><strong>注意</strong>：若有子组件，父组件 <code>mounted</code> 会在所有子组件 <code>mounted</code> 之后执行吗？❌ 父组件 <code>mounted</code> 先执行，子组件 <code>mounted</code> 后执行。</li><li><strong>使用场景</strong>：初始化 DOM 相关逻辑（如图表渲染、DOM 尺寸计算）。</li></ul><h4 id="3-更新阶段（数据变化）"><a href="#3-更新阶段（数据变化）" class="headerlink" title="3. 更新阶段（数据变化）"></a>3. 更新阶段（数据变化）</h4><h5 id="（1）beforeUpdate（更新前）"><a href="#（1）beforeUpdate（更新前）" class="headerlink" title="（1）beforeUpdate（更新前）"></a>（1）beforeUpdate（更新前）</h5><ul><li><strong>执行时机</strong>：数据发生变化，虚拟 DOM 重新渲染前触发。</li><li><strong>核心能力</strong>：可获取更新前的 DOM 状态，修改数据不会触发重复更新。</li><li><strong>使用场景</strong>：更新前记录 DOM 状态（如滚动位置）。</li></ul><h5 id="（2）updated（更新完成）"><a href="#（2）updated（更新完成）" class="headerlink" title="（2）updated（更新完成）"></a>（2）updated（更新完成）</h5><ul><li><strong>执行时机</strong>：虚拟 DOM 重新渲染并更新真实 DOM 后触发。</li><li><strong>核心能力</strong>：可获取更新后的 DOM 状态，操作最新 DOM。</li><li><strong>注意</strong>：避免在 <code>updated</code> 中修改数据（会触发无限循环更新）。</li><li><strong>使用场景</strong>：更新后同步 DOM 状态（如重新计算图表尺寸）。</li></ul><h4 id="4-销毁阶段（实例销毁）"><a href="#4-销毁阶段（实例销毁）" class="headerlink" title="4. 销毁阶段（实例销毁）"></a>4. 销毁阶段（实例销毁）</h4><h5 id="（1）beforeDestroy（销毁前）"><a href="#（1）beforeDestroy（销毁前）" class="headerlink" title="（1）beforeDestroy（销毁前）"></a>（1）beforeDestroy（销毁前）</h5><ul><li><strong>执行时机</strong>：实例销毁前触发，实例仍完全可用（<code>data</code>&#x2F;<code>methods</code>&#x2F;DOM 都可访问）。</li><li><strong>核心能力</strong>：清理资源（如取消定时器、解绑自定义事件、销毁第三方插件实例）。</li><li><strong>使用场景</strong>：防止内存泄漏（如 <code>clearInterval(timer)</code>）。</li></ul><h5 id="（2）destroyed（销毁完成）"><a href="#（2）destroyed（销毁完成）" class="headerlink" title="（2）destroyed（销毁完成）"></a>（2）destroyed（销毁完成）</h5><ul><li><strong>执行时机</strong>：实例已销毁，所有指令、事件监听、子组件都已解绑 &#x2F; 销毁。</li><li><strong>注意</strong>：此时操作实例无意义，<code>this</code> 仍存在但已失去响应式能力。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 组件间通信</title>
      <link href="/2025/09/15/vue/Vue%20%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2025/09/15/vue/Vue%20%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-组件间通信"><a href="#Vue-组件间通信" class="headerlink" title="Vue 组件间通信"></a>Vue 组件间通信</h2><h3 id="1-组件间通信的概念"><a href="#1-组件间通信的概念" class="headerlink" title="1. 组件间通信的概念"></a>1. 组件间通信的概念</h3><p>指 Vue 项目中不同组件（如父子组件、兄弟组件、跨层级组件）之间传递数据、事件或状态的机制，是组件化开发中实现功能协同的基础。</p><h3 id="2-组件间通信解决了什么问题"><a href="#2-组件间通信解决了什么问题" class="headerlink" title="2. 组件间通信解决了什么问题"></a>2. 组件间通信解决了什么问题</h3><ul><li>实现组件间的数据共享（如父子组件传递用户信息）；</li><li>完成组件间的行为联动（如子组件触发父组件的弹窗）；</li><li>解耦组件逻辑，让单个组件更独立、可复用。</li></ul><h3 id="3-组件间通信的分类"><a href="#3-组件间通信的分类" class="headerlink" title="3. 组件间通信的分类"></a>3. 组件间通信的分类</h3><p>按组件关系可分为三类：</p><ul><li><strong>父子组件通信</strong>：最常见的通信场景（如父传子、子传父）；</li><li><strong>兄弟组件通信</strong>：同一父组件下的子组件之间通信；</li><li><strong>跨层级 &#x2F; 任意组件通信</strong>：非直接嵌套的组件（如爷孙组件、无关联组件）之间通信。</li></ul><h3 id="4-组件间通信的方案（Vue2-常用）"><a href="#4-组件间通信的方案（Vue2-常用）" class="headerlink" title="4. 组件间通信的方案（Vue2 常用）"></a>4. 组件间通信的方案（Vue2 常用）</h3><table><thead><tr><th>通信场景</th><th>方案</th><th>说明</th></tr></thead><tbody><tr><td>父→子</td><td>props</td><td>父组件通过属性传递数据，子组件用<code>props</code>接收</td></tr><tr><td>子→父</td><td>$emit + 自定义事件</td><td>子组件触发<code>this.$emit(&#39;事件名&#39;, 数据)</code>，父组件通过<code>@事件名</code>监听</td></tr><tr><td>父子 &#x2F; 跨层级</td><td>$parent &#x2F; $children</td><td>直接访问父 &#x2F; 子组件实例（不推荐，耦合性高）</td></tr><tr><td>跨层级</td><td>$attrs &#x2F; $listeners</td><td>传递未被<code>props</code>接收的属性 &#x2F; 事件，配合<code>v-bind=&quot;$attrs&quot;</code>&#x2F;<code>v-on=&quot;$listeners&quot;</code>透传</td></tr><tr><td>跨层级 &#x2F; 任意组件</td><td>Vuex</td><td>全局状态管理库，统一存储和修改数据</td></tr><tr><td>任意组件</td><td>事件总线（EventBus）</td><td>基于 Vue 实例的<code>$on</code>&#x2F;<code>$emit</code>实现（Vue2 中需自行创建，如<code>new Vue()</code>）</td></tr><tr><td>跨层级</td><td>provide &#x2F; inject</td><td>父组件<code>provide</code>提供数据，后代组件<code>inject</code>注入（适用于深度嵌套场景）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 常用修饰符</title>
      <link href="/2025/09/14/vue/Vue%20%E5%B8%B8%E7%94%A8%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
      <url>/2025/09/14/vue/Vue%20%E5%B8%B8%E7%94%A8%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-常用修饰符"><a href="#Vue-常用修饰符" class="headerlink" title="Vue 常用修饰符"></a>Vue 常用修饰符</h2><h3 id="一、事件修饰符"><a href="#一、事件修饰符" class="headerlink" title="一、事件修饰符"></a>一、事件修饰符</h3><table><thead><tr><th>修饰符</th><th>是什么</th><th>功能</th><th>应用场景</th></tr></thead><tbody><tr><td><code>.stop</code></td><td>阻止事件冒泡的修饰符</td><td>阻止当前事件向父元素冒泡</td><td>子元素点击事件不影响父元素</td></tr><tr><td><code>.prevent</code></td><td>阻止默认行为的修饰符</td><td>阻止标签的默认行为（如 a 标签跳转、表单提交）</td><td>自定义表单提交逻辑</td></tr><tr><td><code>.once</code></td><td>事件仅触发一次的修饰符</td><td>事件绑定后仅执行一次，之后自动解绑</td><td>按钮点击后仅响应一次（如提交）</td></tr><tr><td><code>.self</code></td><td>仅自身触发的修饰符</td><td>仅当事件触发在当前元素本身时才执行</td><td>避免父元素冒泡事件触发自身</td></tr><tr><td><code>.capture</code></td><td>事件捕获阶段触发的修饰符</td><td>事件在捕获阶段（而非冒泡阶段）执行</td><td>需要优先处理父元素事件的场景</td></tr></tbody></table><h3 id="二、按键修饰符"><a href="#二、按键修饰符" class="headerlink" title="二、按键修饰符"></a>二、按键修饰符</h3><table><thead><tr><th>修饰符</th><th>是什么</th><th>功能</th><th>应用场景</th></tr></thead><tbody><tr><td><code>.enter</code></td><td>监听回车键的修饰符</td><td>仅当按下回车键时触发事件</td><td>输入框按回车提交内容</td></tr><tr><td><code>.tab</code></td><td>监听 Tab 键的修饰符</td><td>仅当按下 Tab 键时触发事件</td><td>表单输入框切换焦点</td></tr><tr><td><code>.delete</code></td><td>监听删除 &#x2F; 退格键的修饰符</td><td>仅当按下删除 &#x2F; 退格键时触发事件</td><td>输入框内容删除时的逻辑处理</td></tr><tr><td><code>.esc</code></td><td>监听 ESC 键的修饰符</td><td>仅当按下 ESC 键时触发事件</td><td>关闭弹窗、取消输入</td></tr></tbody></table><h3 id="三、表单修饰符"><a href="#三、表单修饰符" class="headerlink" title="三、表单修饰符"></a>三、表单修饰符</h3><table><thead><tr><th>修饰符</th><th>是什么</th><th>功能</th><th>应用场景</th></tr></thead><tbody><tr><td><code>.lazy</code></td><td>懒同步的修饰符</td><td>将<code>v-model</code>的同步时机从<code>input</code>改为<code>change</code></td><td>减少输入过程中频繁的数据更新</td></tr><tr><td><code>.number</code></td><td>转为数字的修饰符</td><td>将输入内容自动转为 Number 类型（非数字则保留字符串）</td><td>表单中数字类型的输入框</td></tr><tr><td><code>.trim</code></td><td>去除首尾空格的修饰符</td><td>自动去除输入内容的首尾空格</td><td>用户名、手</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>var、let、const之间的区别</title>
      <link href="/2025/09/13/vue/var%E3%80%81let%E3%80%81const%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/09/13/vue/var%E3%80%81let%E3%80%81const%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="var、let、const之间的区别"><a href="#var、let、const之间的区别" class="headerlink" title="var、let、const之间的区别"></a>var、let、const之间的区别</h2><p>var 、 let 、 const 三者区别可以围绕下⾯五点展开：• </p><p>变量提升</p><p>• var 声明的变量存在变量提升，即变量可以在声明之前调⽤，值为 undefined</p><p>let 和 const 不存在变量提升，即它们所声明的变量⼀定要在声明后使⽤，否则报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// var</span><br><span class="line">console.log(a) // undefined</span><br><span class="line">var a = 10</span><br><span class="line">// let</span><br><span class="line">console.log(b) // Cannot access &#x27;b&#x27; before initialization</span><br><span class="line">let b = 10</span><br><span class="line">// const</span><br><span class="line">console.log(c) // Cannot access &#x27;c&#x27; before initialization</span><br><span class="line">const c = 10</span><br></pre></td></tr></table></figure><p>暂时性死区</p><p>• var 不存在暂时性死区</p><p>let 和 const 存在暂时性死区，只有等到声明变量的那⼀⾏代码出现，才可以获取和使⽤该变量</p><p>块级作⽤域</p><p>var 不存在块级作⽤域let 和 const 存在块级作⽤域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 // var</span><br><span class="line">2 &#123;</span><br><span class="line">3 var a = 20</span><br><span class="line">4 &#125;</span><br><span class="line">5 console.log(a) // 20</span><br><span class="line">6 // let</span><br><span class="line">7 &#123;</span><br><span class="line">8 let b = 20</span><br><span class="line">9 &#125;</span><br><span class="line">10 console.log(b) // Uncaught ReferenceError: b is not defined</span><br><span class="line">11 // const</span><br><span class="line">12 &#123;</span><br><span class="line">13 const c = 20</span><br><span class="line">14 &#125;</span><br><span class="line">15 console.log(c) // Uncaught ReferenceError: c is not defined</span><br></pre></td></tr></table></figure><p>• </p><p>重复声明</p><p>• var 允许重复声明变量</p><p>let 和 const 在同⼀作⽤域不允许重复声明变量</p><p>修改声明的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 // var</span><br><span class="line">2 var a = 10</span><br><span class="line">3 var a = 20 // 20</span><br><span class="line">4 // let</span><br><span class="line">5 let b = 10</span><br><span class="line">6 let b = 20 // Identifier &#x27;b&#x27; has already been declared</span><br><span class="line">7 // const</span><br><span class="line">8 const c = 10</span><br><span class="line">9 const c = 20 // Identifier &#x27;c&#x27; has already been declared</span><br></pre></td></tr></table></figure><p>• </p><p>使⽤</p><p>var 和 let 可以</p><p>const 声明⼀个只读的常量。⼀旦声明，常量的值就不能改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 // var</span><br><span class="line">2 var a = 10</span><br><span class="line">3 a = 20</span><br><span class="line">4 console.log(a) // 20</span><br><span class="line">5 //let</span><br><span class="line">6 let b = 10</span><br><span class="line">7 b = 20</span><br><span class="line">8 console.log(b) // 20</span><br><span class="line">9 // const</span><br><span class="line">10 const c = 10</span><br><span class="line">11 c = 20</span><br><span class="line">12 console.log(c) // Uncaught TypeError: Assignment to constant variable</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v-show 与 v-if</title>
      <link href="/2025/09/13/vue/v-show%20%E4%B8%8E%20v-if/"/>
      <url>/2025/09/13/vue/v-show%20%E4%B8%8E%20v-if/</url>
      
        <content type="html"><![CDATA[<h2 id="v-show-与-v-if"><a href="#v-show-与-v-if" class="headerlink" title="v-show 与 v-if"></a>v-show 与 v-if</h2><h3 id="1-v-show-与-v-if-的共同点"><a href="#1-v-show-与-v-if-的共同点" class="headerlink" title="1. v-show 与 v-if 的共同点"></a>1. v-show 与 v-if 的共同点</h3><p>二者都是 Vue 中用于<strong>控制 DOM 元素显示 &#x2F; 隐藏</strong>的指令，都可以根据表达式的布尔值决定元素是否展示。</p><h3 id="2-v-show-与-v-if-的区别"><a href="#2-v-show-与-v-if-的区别" class="headerlink" title="2. v-show 与 v-if 的区别"></a>2. v-show 与 v-if 的区别</h3><table><thead><tr><th>维度</th><th>v-show</th><th>v-if</th></tr></thead><tbody><tr><td>渲染方式</td><td>始终渲染 DOM，通过<code>display: none</code>控制隐藏</td><td>条件为<code>false</code>时，不渲染 DOM 到页面</td></tr><tr><td>切换开销</td><td>切换时仅修改 CSS，开销小</td><td>切换时会销毁 &#x2F; 重建 DOM，开销大</td></tr><tr><td>初始渲染开销</td><td>初始渲染需渲染 DOM，开销略大</td><td>条件为<code>false</code>时不渲染，初始开销小</td></tr><tr><td>支持场景</td><td>不能用于<code>&lt;template&gt;</code>标签</td><td>可以用于<code>&lt;template&gt;</code>标签（分组渲染）</td></tr></tbody></table><h3 id="3-v-show-与-v-if-的原理分析"><a href="#3-v-show-与-v-if-的原理分析" class="headerlink" title="3. v-show 与 v-if 的原理分析"></a>3. v-show 与 v-if 的原理分析</h3><ul><li><strong>v-show</strong>：编译后会给元素添加内联样式<code>display: [条件? &#39;block&#39; : &#39;none&#39;]</code>，DOM 元素始终存在于文档流中。</li><li><strong>v-if</strong>：编译时会根据条件生成条件渲染的代码块，条件为<code>false</code>时，对应的 DOM 节点不会被创建（或会被从 DOM 树中移除）。</li></ul><h3 id="4-v-show-与-v-if-的使用场景"><a href="#4-v-show-与-v-if-的使用场景" class="headerlink" title="4. v-show 与 v-if 的使用场景"></a>4. v-show 与 v-if 的使用场景</h3><ul><li><strong>v-show</strong>：适用于<strong>切换频繁</strong>的元素（如标签页内容、弹窗开关），利用低切换开销提升性能。</li><li><strong>v-if</strong>：适用于<strong>切换频率低</strong>、或<strong>初始条件为 false 且不需要渲染 DOM</strong>的场景（如权限控制的内容、页面初始化时不需要显示的模块），避免不必要的 DOM 渲染。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slot</title>
      <link href="/2025/09/13/vue/slot/"/>
      <url>/2025/09/13/vue/slot/</url>
      
        <content type="html"><![CDATA[<h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><h3 id="1-slot-是什么"><a href="#1-slot-是什么" class="headerlink" title="1. slot 是什么"></a>1. slot 是什么</h3><p>slot（插槽）是 Vue 组件中的<strong>内容分发机制</strong>，允许父组件向子组件的指定位置插入自定义内容，实现组件的 “模板复用 + 内容定制”，让组件更灵活通用。</p><h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h3><ul><li><strong>组件内容自定义</strong>：封装通用组件（如弹窗、卡片）时，让父组件自定义组件内部的部分内容（如弹窗的标题、卡片的主体）；</li><li><strong>组件结构扩展</strong>：复杂组件（如表格、导航栏）中，允许父组件插入自定义的列、菜单项；</li><li><strong>组件逻辑与视图分离</strong>：子组件负责逻辑 &#x2F; 布局，父组件负责具体视图内容的展示。</li></ul><h3 id="3-分类"><a href="#3-分类" class="headerlink" title="3. 分类"></a>3. 分类</h3><table><thead><tr><th>分类</th><th>说明</th></tr></thead><tbody><tr><td>匿名插槽</td><td>无名称的插槽，父组件插入的内容默认填充到该插槽（一个组件仅一个匿名插槽）</td></tr><tr><td>具名插槽</td><td>带名称的插槽（通过<code>name</code>属性标识），父组件可指定内容插入到对应名称的插槽</td></tr><tr><td>作用域插槽</td><td>子组件向父组件传递数据的插槽，父组件可接收子组件的数据并自定义渲染内容</td></tr></tbody></table><h3 id="4-原理分析"><a href="#4-原理分析" class="headerlink" title="4. 原理分析"></a>4. 原理分析</h3><p>slot 的本质是<strong>组件编译时的内容分发标记</strong>：</p><ul><li>子组件中<code>slot</code>标签会被标记为 “内容插入点”；</li><li>父组件中插入到子组件标签内的内容，会被编译为 “待分发内容”；</li><li>Vue 在渲染时，将 “待分发内容” 匹配到子组件对应的<code>slot</code>位置，完成内容注入。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node 中的 Stream</title>
      <link href="/2025/09/12/vue/Node%20%E4%B8%AD%E7%9A%84%20Stream/"/>
      <url>/2025/09/12/vue/Node%20%E4%B8%AD%E7%9A%84%20Stream/</url>
      
        <content type="html"><![CDATA[<h2 id="Node-中的-Stream"><a href="#Node-中的-Stream" class="headerlink" title="Node 中的 Stream"></a>Node 中的 Stream</h2><p>流（Stream），是⼀个数据传输⼿段，是端到端信息交换的⼀种⽅式，⽽且是有顺序的,是逐块读取数</p><p>据、处理内容，⽤于顺序读取输⼊或写⼊输出</p><p>Node.js 中很多对象都实现了流，总之它是会冒数据（以 Buffer 为单位）它的独特之处在于，它不像传统的程序那样⼀次将⼀个⽂件读⼊内存，⽽是逐块读取数据、处理其内</p><p>容，⽽不是将其全部保存在内存中</p><p>流可以分成三部分： source 、 dest 、 pipe</p><p>在 source 和 dest 之间有⼀个连接的管道 pipe ,它的基本语法是 source.pipe(dest) ，</p><p>source 和 dest 就是通过pipe连接，让数据从 source 流向了 dest </p><p>在 NodeJS ，⼏乎所有的地⽅都使⽤到了流的概念，分成四个种类：</p><p>• </p><p>可写流：可写⼊数据的流。例如 fs.createWriteStream() 可以使⽤流将数据写⼊⽂件</p><p>• </p><p>可读流： 可读取数据的流。例如fs.createReadStream() 可以从⽂件读取内容</p><p>• </p><p>双⼯流： 既可读⼜可写的流。例如 net.Socket</p><p>• </p><p>转换流： 可以在数据写⼊和读取时修改或转换数据的流。例如，在⽂件压缩操作中，可以向⽂件写</p><p>⼊压缩数据，并从⽂件中读取解压数据</p><p>在 NodeJS 中 HTTP 服务器模块中， request 是可读流， response 是可写流。还有 fs 模</p><p>块，能同时处理可读和可写⽂件流</p><p>可读流和可写流都是单向的，⽐较容易理解，⽽另外两个是双向的</p><p>stream 的应⽤场景主要就是处理 IO 操作，⽽ http 请求和⽂件操作都属于 IO 操作</p><p>试想⼀下，如果⼀次 IO 操作过⼤，硬件的开销就过⼤，⽽将此次⼤的 IO 操作进⾏分段操作，让数</p><p>据像⽔管⼀样流动，直到流动完成</p><p>常⻅的场景有：</p><p>• </p><p>get请求返回⽂件给客⼾端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const server = http.createServer(function (req, res) &#123;</span><br><span class="line">const method = req.method; // 获取请求⽅法</span><br><span class="line">if (method === &#x27;GET&#x27;) &#123; // get 请求</span><br><span class="line">const fileName = path.resolve(__dirname, &#x27;data.txt&#x27;);</span><br><span class="line">let stream = fs.createReadStream(fileName);</span><br><span class="line">stream.pipe(res); // 将 res 作为 stream 的 dest</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8000);</span><br></pre></td></tr></table></figure><p>• </p><p>⽂件操作</p><p>• </p><p>⼀些打包⼯具的底层操作</p>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node 中的 Buffer</title>
      <link href="/2025/09/11/vue/Node%20%E4%B8%AD%E7%9A%84%20Buffer/"/>
      <url>/2025/09/11/vue/Node%20%E4%B8%AD%E7%9A%84%20Buffer/</url>
      
        <content type="html"><![CDATA[<h2 id="Node-中的-Buffer"><a href="#Node-中的-Buffer" class="headerlink" title="Node 中的 Buffer"></a>Node 中的 Buffer</h2><p>在 Node 应⽤中，需要处理⽹络协议、操作数据库、处理图⽚、接收上传⽂件等，在⽹络流和⽂件的</p><p>操作中，要处理⼤量⼆进制数据，⽽ <strong>Buffer 就是在内存中开辟⼀⽚区域（初次初始化为8KB），⽤</strong></p><p><strong>来存放⼆进制数据</strong></p><p>在上述操作中都会存在数据流动，每个数据流动的过程中，都会有⼀个最⼩或最⼤数据量</p><p>如果数据到达的速度⽐进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，</p><p>如果数据到达的速度⽐进程消耗的数据慢，那么早先到达的数据需要等待⼀定量的数据到达之后才能</p><p>被处理</p><p>这⾥的等待区就指的缓冲区（Buffer），它是计算机中的⼀个⼩物理单位，通常位于计算机的 RAM</p><p>中</p><p>简单来讲， Nodejs 不能控制数据传输的速度和到达时间，只能决定何时发送数据，如果还没到发送</p><p>时间，则将数据放在 Buffer 中，即在 RAM 中，直⾄将它们发送完毕</p><p>Buffer 类在全局作⽤域中，⽆须 require 导⼊</p><p>创建 Buffer 的⽅法有很多种，我们讲讲下⾯的两种常⻅的形式：</p><p>• </p><p>Buffer.from()</p><p>• </p><p>Buffer.alloc()</p><p>3.2.1. Buffer.from()</p><p>const b1 &#x3D; Buffer.from(‘10’);</p><p>const b2 &#x3D; Buffer.from(‘10’, ‘utf8’);</p><p>const b3 &#x3D; Buffer.from([10]);</p><p>const b4 &#x3D; Buffer.from(b3);</p><p>console.log(b1, b2, b3, b4); <em>&#x2F;&#x2F; &lt;Buffer 31 30&gt; &lt;Buffer 31 30&gt; &lt;Buffer 0a&gt;</em></p><p><em>&lt;Buffer 0a&gt;</em></p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>3.2.2. Buffer.alloc()</p><p>const bAlloc1 &#x3D; Buffer.alloc(10); <em>&#x2F;&#x2F;</em> <em>创建⼀个⼤⼩为</em> <em>10</em> <em>个字节的缓冲区</em></p><p>const bAlloc2 &#x3D; Buffer.alloc(10, 1); <em>&#x2F;&#x2F;</em> <em>建⼀个⻓度为</em> <em>10</em> <em>的</em> *Buffer,*<em>其中全部填充了值</em></p><p><em>为</em></p><p>1</p><p>的字节</p><p>console.log(bAlloc1); <em>&#x2F;&#x2F; &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</em></p><p>console.log(bAlloc2); <em>&#x2F;&#x2F; &lt;Buffer 01 01 01 01 01 01 01 01 01 01&gt;</em></p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>在上⾯创建 buffer 后，则能够 toString 的形式进⾏交互，默认情况下采取 utf8 字符编码形</p><p>式，如下const buffer &#x3D; Buffer.from(“你好”);</p><p>console.log(buffer);</p><p><em>&#x2F;&#x2F; <Buffer e4 bd a0 e5 a5 bd></em></p><p>const str &#x3D; buffer.toString();</p><p>console.log(str);</p><p><em>&#x2F;&#x2F;</em> <em>你好</em></p><p>如果编码与解码不是相同的格式则会出现乱码的情况，如下：</p><p>const buffer &#x3D; Buffer.from(“你好”,”utf-8 “);</p><p>console.log(buffer);</p><p><em>&#x2F;&#x2F; <Buffer e4 bd a0 e5 a5 bd></em></p><p>const str &#x3D; buffer.toString(“ascii”);</p><p>console.log(str);</p><p><em>&#x2F;&#x2F; d&#x3D; e%&#x3D;</em></p><p>当设定的范围导致字符串被截断的时候，也会存在乱码情况，如下：</p><p>const buf &#x3D; Buffer.from(‘Node.js 技术栈’, ‘UTF-8’);</p><p>console.log(buf) <em>&#x2F;&#x2F; &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af</em></p><p><em>e6 a0 88&gt;</em></p><p>console.log(buf.length) <em>&#x2F;&#x2F; 17</em></p><p>console.log(buf.toString(‘UTF-8’, 0, 9)) <em>&#x2F;&#x2F; Node.js</em></p><p>console.log(buf.toString(‘UTF-8’, 0, 11)) <em>&#x2F;&#x2F; Node.js</em> <em>技</em></p><p>所⽀持的字符集有如下：</p><p>• </p><p>ascii：仅⽀持 7 位 ASCII 数据，如果设置去掉⾼位的话，这种编码是⾮常快的</p><p>• </p><p>utf8：多字节编码的 Unicode 字符，许多⽹⻚和其他⽂档格式都使⽤ UTF-8</p><p>• </p><p>utf16le：2 或 4 个字节，⼩字节序编码的 Unicode 字符，⽀持代理对（U+10000⾄ U+10FFFF）</p><p>• </p><p>ucs2，utf16le 的别名</p><p>• </p><p>base64：Base64 编码</p><p>• </p><p>latin：⼀种把 Buffer 编码成⼀字节编码的字符串的⽅式</p><p>• </p><p>binary：latin1 的别名，</p><p>• </p><p>hex：将每个字节编码为两个⼗六进制字符</p>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 Promise</title>
      <link href="/2025/09/10/vue/ES6%E4%B8%ADPromise/"/>
      <url>/2025/09/10/vue/ES6%E4%B8%ADPromise/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6中-Promise"><a href="#ES6中-Promise" class="headerlink" title="ES6中 Promise"></a>ES6中 Promise</h1><p>在以往我们如果处理多层异步操作，我们往往会像下⾯那样编写我们的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 doSomething(function(result) &#123;</span><br><span class="line">2 doSomethingElse(result, function(newResult) &#123;</span><br><span class="line">3 doThirdThing(newResult, function(finalResult) &#123;</span><br><span class="line">4 console.log(&#x27;得到最终结果: &#x27; + finalResult);</span><br><span class="line">5 &#125;, failureCallback);</span><br><span class="line">6 &#125;, failureCallback);</span><br><span class="line">7 &#125;, failureCallback);</span><br></pre></td></tr></table></figure><p>promise 对象仅有三种状态</p><p>pending （进⾏中）</p><p>fulfilled （已成功）</p><p>rejected （已失败）</p><p>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪⼀种状态</p><p>⼀旦状态改变（从 pending 变为 fulfilled 和从 pending 变为 rejected ），就不会再</p><p>变，任何时候都可以得到这个结果</p><p><strong>实例⽅法</strong></p><p>then 是实例状态发⽣改变时的回调函数，第⼀个参数是 resolved 状态的回调函数，第⼆个参数</p><p>是 rejected 状态的回调函数</p><p><strong>then ⽅法返回的是⼀个新的 Promise 实例，也就是 promise 能链式书写的原因</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</span><br><span class="line">return json.post;</span><br><span class="line">&#125;).then(function(post) &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>catch()</strong> ⽅法是 .then(null, rejection) 或 .then(undefined, rejection) 的别</p><p>名，<strong>⽤于指定发⽣错误时的回调函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&#x27;/posts.json&#x27;).then(function(posts) &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">// 处理 getJSON 和 前⼀个回调函数运⾏时发⽣的错误</span><br><span class="line">console.log(&#x27;发⽣错误！&#x27;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>finally()</strong> ⽅法⽤于指定<strong>不管 Promise 对象最后状态如何，都会执⾏的操作</strong></p><h3 id="构造函数⽅法"><a href="#构造函数⽅法" class="headerlink" title="构造函数⽅法"></a>构造函数⽅法</h3><p>all()</p><p>Promise.all() ⽅法⽤于<strong>将多个 Promise 实例，包装成⼀个新的 Promise 实例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>接受⼀个数组（迭代对象）作为参数，数组成员都应为 Promise 实例</p><p>实例 p 的状态由 p1 、 p2 、 p3 决定，分为两种：</p><p><strong>只有 p1 、 p2 、 p3 的状态都变成 fulfilled</strong> ， <strong>p 的状态才会变成 fulfilled</strong> ，此时</p><p>p1 、 p2 、 p3 的<strong>返回值组成⼀个数组</strong>，传递给 p 的回调函数</p><p><strong>只要 p1 、 p2 、 p3 之中有⼀个被 rejected</strong> ， <strong>p 的状态就变成 rejected</strong> ，此时<strong>第⼀个被</strong></p><p><strong>reject 的实例的返回值</strong>，会传递给 p 的回调函数</p><p>注意，如果作为参数的 Promise 实例，<strong>⾃⼰定义了 catch ⽅法</strong>，那么它⼀旦被 rejected ，并</p><p><strong>不会触发 Promise.all() 的 catch</strong> ⽅法</p><p><strong>reject()</strong></p><p>Promise.reject(reason) ⽅法也会返回⼀个新的 Promise 实例，该实例的状态为 rejected</p>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6中数组新增扩展</title>
      <link href="/2025/09/09/vue/ES6%E4%B8%AD%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E4%BA%86%E6%89%A9%E5%B1%95/"/>
      <url>/2025/09/09/vue/ES6%E4%B8%AD%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E4%BA%86%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6中数组新增了扩展"><a href="#ES6中数组新增了扩展" class="headerlink" title="ES6中数组新增了扩展"></a>ES6中数组新增了扩展</h1><h3 id="扩展运算符的应⽤"><a href="#扩展运算符的应⽤" class="headerlink" title="扩展运算符的应⽤"></a>扩展运算符的应⽤</h3><p>ES6通过扩展元素符 … ，好⽐ rest 参数的逆运算，将⼀个数组转为⽤逗号分隔的参数序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 console.log(...[1, 2, 3])</span><br><span class="line">2 // 1 2 3</span><br><span class="line">3 console.log(1, ...[2, 3, 4], 5)</span><br><span class="line">4 // 1 2 3 4 5</span><br><span class="line">5 [...document.querySelectorAll(&#x27;div&#x27;)]</span><br><span class="line">6 // [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br></pre></td></tr></table></figure><p>主要⽤于函数调⽤的时候，<strong>将⼀个数组变为参数序列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 function push(array, ...items) &#123;</span><br><span class="line">2 array.push(...items);</span><br><span class="line">3 &#125;</span><br><span class="line">4 function add(x, y) &#123;</span><br><span class="line">5 return x + y;</span><br><span class="line">6 &#125;</span><br><span class="line">7 const numbers = [4, 38];</span><br><span class="line">8 add(...numbers) // 42</span><br></pre></td></tr></table></figure><p><strong>ES6 允许为函数的参数设置默认值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 function log(x, y = &#x27;World&#x27;) &#123;</span><br><span class="line">2 console.log(x, y);</span><br><span class="line">3 &#125;</span><br><span class="line">4 console.log(&#x27;Hello&#x27;) // Hello World</span><br><span class="line">5 console.log(&#x27;Hello&#x27;, &#x27;China&#x27;) // Hello China</span><br><span class="line">6 console.log(&#x27;Hello&#x27;, &#x27;&#x27;) // Hello</span><br></pre></td></tr></table></figure><p><strong>作⽤域</strong></p><p>⼀旦设置了参数的默认值，函数进⾏声明初始化时，参数会形成⼀个单独的作⽤域</p><p>等到初始化结束，这个作⽤域就会消失。这种语法⾏为，在不设置参数默认值时，是不会出现的</p><p>下⾯例⼦中， y&#x3D;x 会形成⼀个单独作⽤域， x 没有被定义，所以指向全局变量 x</p><p><strong>箭头函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f = v =&gt; v;</span><br><span class="line">// 等同于</span><br><span class="line">var f = function (v) &#123;</span><br><span class="line">return v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数，就使⽤⼀个圆括号代表参数部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt; 5;</span><br><span class="line">// 等同于</span><br><span class="line">var f = function () &#123; return 5 &#125;;</span><br><span class="line">var sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line">// 等同于</span><br><span class="line">var sum = function(num1, num2) &#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>super关键字</strong></p><p>this 关键字总是指向函数所在的当前对象，ES6 ⼜新增了另⼀个类似的关键字 super ，指向当前</p><p>对象的原型对象</p>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios</title>
      <link href="/2025/09/08/vue/axios/"/>
      <url>/2025/09/08/vue/axios/</url>
      
        <content type="html"><![CDATA[<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h3 id="1-axios-是什么"><a href="#1-axios-是什么" class="headerlink" title="1. axios 是什么"></a>1. axios 是什么</h3><p>axios 是一个基于 Promise 的<strong>HTTP 请求库</strong>，用于浏览器和 Node.js 环境中发送网络请求（如 GET、POST 等），是 Vue 项目中常用的接口请求工具，支持请求拦截、响应拦截、取消请求等功能。</p><h3 id="2-为什么要封装"><a href="#2-为什么要封装" class="headerlink" title="2. 为什么要封装"></a>2. 为什么要封装</h3><p>在 Vue 中封装 axios 主要是为了<strong>提升代码的复用性、可维护性与规范性</strong>，具体原因包括：</p><ul><li>统一配置：集中管理请求基地址、超时时间等公共配置；</li><li>统一拦截：全局处理请求头（如携带 Token）、响应错误（如登录失效、接口报错）；</li><li>简化调用：封装通用的请求方法（如<code>get</code>&#x2F;<code>post</code>），减少重复代码；</li><li>统一规范：约束接口请求的参数格式、响应处理逻辑。</li></ul><h3 id="3-如何封装（Vue2-中）"><a href="#3-如何封装（Vue2-中）" class="headerlink" title="3. 如何封装（Vue2 中）"></a>3. 如何封装（Vue2 中）</h3><p>以下是 Vue2 中 axios 的典型封装步骤：</p><h4 id="（1）创建-axios-实例并配置公共参数"><a href="#（1）创建-axios-实例并配置公共参数" class="headerlink" title="（1）创建 axios 实例并配置公共参数"></a>（1）创建 axios 实例并配置公共参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/utils/request.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios实例</span></span><br><span class="line"><span class="keyword">const</span> service = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: process.<span class="property">env</span>.<span class="property">VUE_APP_BASE_API</span>, <span class="comment">// 基地址（从环境变量读取）</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span> <span class="comment">// 超时时间</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="（2）添加请求拦截器（处理请求前逻辑）"><a href="#（2）添加请求拦截器（处理请求前逻辑）" class="headerlink" title="（2）添加请求拦截器（处理请求前逻辑）"></a>（2）添加请求拦截器（处理请求前逻辑）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 示例：添加Token到请求头</span></span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      config.<span class="property">headers</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;Bearer &#x27;</span> + token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理请求错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="（3）添加响应拦截器（处理响应后逻辑）"><a href="#（3）添加响应拦截器（处理响应后逻辑）" class="headerlink" title="（3）添加响应拦截器（处理响应后逻辑）"></a>（3）添加响应拦截器（处理响应后逻辑）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 示例：统一处理响应数据</span></span><br><span class="line">    <span class="keyword">const</span> res = response.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">code</span> !== <span class="number">200</span>) &#123; <span class="comment">// 假设接口约定code=200为成功</span></span><br><span class="line">      <span class="comment">// 处理业务错误（如提示错误信息）</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(res.<span class="property">msg</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(res.<span class="property">msg</span> || <span class="string">&#x27;请求失败&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理HTTP错误（如401登录失效）</span></span><br><span class="line">    <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">status</span> === <span class="number">401</span>) &#123;</span><br><span class="line">      <span class="comment">// 示例：跳转到登录页</span></span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;/login&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;接口请求错误：&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="（4）封装请求方法并导出"><a href="#（4）封装请求方法并导出" class="headerlink" title="（4）封装请求方法并导出"></a>（4）封装请求方法并导出</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装get请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">url, params</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">service</span>(&#123;</span><br><span class="line">    url,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    params</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装post请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">post</span> = (<span class="params">url, data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">service</span>(&#123;</span><br><span class="line">    url,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service;</span><br></pre></td></tr></table></figure><h4 id="（5）在-Vue-中使用"><a href="#（5）在-Vue-中使用" class="headerlink" title="（5）在 Vue 中使用"></a>（5）在 Vue 中使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件/接口文件中引入</span></span><br><span class="line"><span class="keyword">import</span> &#123; get, post &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line"><span class="title function_">get</span>(<span class="string">&#x27;/user/list&#x27;</span>, &#123; <span class="attr">page</span>: <span class="number">1</span> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户列表：&#x27;</span>, res.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向数据绑定</title>
      <link href="/2025/09/06/vue/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
      <url>/2025/09/06/vue/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><p>在 Vue2 中，双向数据绑定的实现核心是 <strong><code>Object.defineProperty</code> 数据劫持 + 发布 - 订阅模式</strong>，结合 <code>v-model</code> 指令完成视图与数据的双向联动。以下是 Vue2 双向绑定的具体原理与实现细节：</p><h3 id="一、Vue2-双向绑定的核心原理"><a href="#一、Vue2-双向绑定的核心原理" class="headerlink" title="一、Vue2 双向绑定的核心原理"></a>一、Vue2 双向绑定的核心原理</h3><p>Vue2 借助 <strong>3 个核心模块</strong> 实现双向绑定：</p><ol><li><strong>数据劫持（Observer）</strong>：通过 <code>Object.defineProperty</code> 对 <code>data</code> 中的属性进行劫持，监听属性的 <code>get</code>（读取）和 <code>set</code>（修改）操作；</li><li><strong>依赖收集（Dep）</strong>：在属性被读取时，收集依赖该属性的视图组件（订阅者）；</li><li><strong>发布 - 订阅（Watcher）</strong>：当属性被修改时，通知所有订阅者更新视图；同时监听视图的输入事件，反向修改数据。</li></ol><h3 id="二、Vue2-中-v-model-的实现"><a href="#二、Vue2-中-v-model-的实现" class="headerlink" title="二、Vue2 中 v-model 的实现"></a>二、Vue2 中 <code>v-model</code> 的实现</h3><p><code>v-model</code> 是 Vue2 双向绑定的语法糖，本质是<strong>绑定 <code>value</code> 属性 + 监听 <code>input</code> 事件</strong>，自动完成 “数据→视图” 和 “视图→数据” 的双向同步：</p><h4 id="示例（输入框双向绑定）："><a href="#示例（输入框双向绑定）：" class="headerlink" title="示例（输入框双向绑定）："></a>示例（输入框双向绑定）：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- v-model 等价于 :value + @input --&gt;</span><br><span class="line">  &lt;input v-model=&quot;message&quot; /&gt;</span><br><span class="line">  &lt;p&gt;当前输入：&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &quot;初始内容&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="等价于手动绑定："><a href="#等价于手动绑定：" class="headerlink" title="等价于手动绑定："></a>等价于手动绑定：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input </span><br><span class="line">    :value=&quot;message&quot; </span><br><span class="line">    @input=&quot;message = $event.target.value&quot; </span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;p&gt;当前输入：&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="三、Vue2-双向绑定的流程（以输入框为例）"><a href="#三、Vue2-双向绑定的流程（以输入框为例）" class="headerlink" title="三、Vue2 双向绑定的流程（以输入框为例）"></a>三、Vue2 双向绑定的流程（以输入框为例）</h3><ol><li><strong>初始化阶段</strong>：<ul><li>Vue 实例化时，<code>Observer</code> 会遍历 <code>data</code> 中的 <code>message</code>，通过 <code>Object.defineProperty</code> 为其添加 <code>get</code> 和 <code>set</code>；</li><li>视图渲染时，读取 <code>message</code> 触发 <code>get</code>，<code>Dep</code> 收集该视图对应的 <code>Watcher</code>（订阅者）。</li></ul></li><li><strong>数据→视图</strong>：<ul><li>当代码中修改 <code>this.message = &quot;新内容&quot;</code> 时，触发 <code>set</code> 方法；</li><li><code>Dep</code> 通知所有订阅的 <code>Watcher</code>，<code>Watcher</code> 触发视图重新渲染，输入框内容同步更新。</li></ul></li><li><strong>视图→数据</strong>：<ul><li>用户在输入框输入内容时，触发 <code>input</code> 事件；</li><li>事件回调中修改 <code>this.message = $event.target.value</code>，再次触发 <code>set</code>，完成数据同步。</li></ul></li></ol><h3 id="四、Vue2-双向绑定的局限性"><a href="#四、Vue2-双向绑定的局限性" class="headerlink" title="四、Vue2 双向绑定的局限性"></a>四、Vue2 双向绑定的局限性</h3><p>由于依赖 <code>Object.defineProperty</code>，存在以下限制：</p><ul><li>无法监听<strong>对象新增属性</strong>（需用 <code>Vue.set</code>）；</li><li>无法监听<strong>数组的下标修改 &#x2F; 长度修改</strong>（需用数组变异方法，如 <code>push</code>&#x2F;<code>splice</code>）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现jwt鉴权机制</title>
      <link href="/2025/09/05/vue/%E5%AE%9E%E7%8E%B0jwt%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/09/05/vue/%E5%AE%9E%E7%8E%B0jwt%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="实现jwt鉴权机制"><a href="#实现jwt鉴权机制" class="headerlink" title="实现jwt鉴权机制"></a>实现jwt鉴权机制</h2><p>JWT（JSON Web Token），本质就是⼀个字符串书写规范，如下图，作⽤是⽤来在⽤⼾和服务器之</p><p>间传递安全可靠的信息</p><p>在⽬前前后端分离的开发过程中，使⽤ token 鉴权机制⽤于⾝份验证是最常⻅的⽅案，流程如下：</p><p>• </p><p>服务器当验证⽤⼾账号和密码正确的时候，给⽤⼾颁发⼀个令牌，这个令牌作为后续⽤⼾访问⼀些</p><p>接⼝的凭证</p><p>• </p><p>后续访问会根据这个令牌判断⽤⼾时候有权限进⾏访问</p><p>Token ，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以 . 进⾏</p><p>拼接。其中头部和载荷都是以 JSON 格式存放数据，只是进⾏了编码13.1.1. header</p><p>每个JWT都会带有头部信息，这⾥主要声明使⽤的算法。声明算法的字段名为 alg ，同时还有⼀个</p><p>typ 的字段，默认 JWT 即可。以下⽰例中算法为HS256</p><p>1 { “alg”: “HS256”, “typ”: “JWT” }</p><p>因为JWT是字符串，所以我们还需要对以上内容进⾏Base64编码，编码后字符串如下：</p><p>1 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</p><p>13.1.2. payload载荷即消息体，这⾥会存放实际的内容，也就是 Token 的数据声明，例如⽤⼾的 id 和 name ，默</p><p>认情况下也会携带令牌的签发时间 iat ，通过还可以设置过期时间，如下：</p><p>{</p><p>“sub”: “1234567890”,</p><p>“name”: “John Doe”,</p><p>“iat”: 1516239022</p><p>}</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>同样进⾏Base64编码后，字符串如下：</p><p>1 eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ</p><p>13.1.3. Signature</p><p>签名是对头部和载荷内容进⾏签名，⼀般情况，设置⼀个 secretKey ，对前两个的结果进⾏</p><p>HMACSHA25 算法，公式如下：</p><p>1 Signature &#x3D; HMACSHA256(base64Url(header)+.+base64Url(payload),secretKey)</p><p>⼀旦前⾯两部分数据被篡改，只要服务器加密⽤的密钥没有泄露，得到的签名肯定和之前的签名不⼀</p><p>致</p><p>13.2. 如何实现</p><p>Token 的使⽤分成了两部分：</p><p>• </p><p>⽣成token：登录成功的时候，颁发token</p><p>• </p><p>验证token：访问某些资源或者接⼝时，验证token</p><p>13.2.1. ⽣成 token</p><p>借助第三⽅库 jsonwebtoken ，通过 jsonwebtoken 的 sign ⽅法⽣成⼀个 token ：</p><p>• </p><p>第⼀个参数指的是 Payload</p><p>• </p><p>第⼆个是秘钥，服务端特有</p><p>• </p><p>第三个参数是 option，可以定义 token 过期时间</p><p>1 const crypto &#x3D; require(“crypto”),2 jwt &#x3D; require(“jsonwebtoken”);</p><p>3 <em>&#x2F;&#x2F;</em> TODO:<em>使⽤数据库</em></p><p>4 <em>&#x2F;&#x2F;</em> <em>这⾥应该是⽤数据库存储，这⾥只是演⽰⽤</em></p><p>5 let userList &#x3D; [];</p><p>6 class UserController {</p><p>7 <em>&#x2F;&#x2F;</em> <em>⽤⼾登录</em></p><p>8 static async login(ctx) {</p><p>9 const data &#x3D; ctx.request.body;</p><p>10 if (!data.name || !data.password) {</p><p>11 return ctx.body &#x3D; {</p><p>12 code: “000002”,</p><p>13 message: “参数不合法”</p><p>14 }</p><p>15 }</p><p>16 const result &#x3D; userList.find(item &#x3D;&gt; item.name &#x3D;&#x3D;&#x3D; data.name &amp;&amp;</p><p>item.password &#x3D;&#x3D;&#x3D; crypto.createHash(‘md5’).update(data.password).digest(‘hex’))</p><p>17 if (result) {</p><p>18 <em>&#x2F;&#x2F;</em> <em>⽣成**token</em></p><p>19 const token &#x3D; jwt.sign(</p><p>20</p><p>21 {</p><p>22 name: result.name</p><p>23 },</p><p>24 “test_token”, <em>&#x2F;&#x2F; secret</em></p><p>25 { expiresIn: 60 * 60 } <em>&#x2F;&#x2F;</em> <em>过期时间：**60 * 60 s</em></p><p>26 );</p><p>27 return ctx.body &#x3D; {</p><p>28 code: “0”,</p><p>29 message: “登录成功”,</p><p>30 data: {</p><p>31 token</p><p>32 }</p><p>33 };</p><p>34 } else {</p><p>35 return ctx.body &#x3D; {</p><p>36 code: “000002”,</p><p>37 message: “⽤⼾名或密码错误”</p><p>38 };</p><p>39 }</p><p>40 }</p><p>41 }</p><p>42 module.exports &#x3D; UserController;</p><p>在前端接收到 token 后，⼀般情况会通过 localStorage 进⾏缓存，然后将 token 放到 HTTP</p><p>请求头 Authorization 中，关于 Authorization 的设置，前⾯要加上 Bearer ，注意后⾯带有</p><p>空格axios.interceptors.request.use(config &#x3D;&gt; {</p><p>const token &#x3D; localStorage.getItem(‘token’);</p><p>config.headers.common[‘Authorization’] &#x3D; ‘Bearer ‘ + token; <em>&#x2F;&#x2F;</em> <em>留意这⾥的</em></p><p><em>Authorization</em></p><p>return config;</p><p>})</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>13.2.2. 校验token</p><p>使⽤ koa-jwt 中间件进⾏验证，⽅式⽐较简单</p><p>&#x2F; 注意：放在路由前⾯</p><p>app.use(koajwt({</p><p>secret: ‘test_token’</p><p>}).unless({ <em>&#x2F;&#x2F;</em> <em>配置⽩名单</em></p><p>path: [&#x2F;/api/register&#x2F;, &#x2F;/api/login&#x2F;]</p><p>}))</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>• </p><p>secret 必须和 sign 时候保持⼀致</p><p>• </p><p>可以通过 unless 配置接⼝⽩名单，也就是哪些 URL 可以不⽤经过校验，像登陆&#x2F;注册都可以不⽤校</p><p>验</p><p>• </p><p>校验的中间件需要放在需要校验的路由前⾯，⽆法对前⾯的 URL 进⾏校验</p><p>获取 token ⽤⼾的信息⽅法如下：</p><p>router.get(‘&#x2F;api&#x2F;userInfo’,async (ctx,next) &#x3D;&gt;{</p><p>const authorization &#x3D; ctx.header.authorization <em>&#x2F;&#x2F;</em> <em>获取**jwt</em></p><p>const token &#x3D; authorization.replace(‘Beraer ‘,’’)</p><p>const result &#x3D; jwt.verify(token,’test_token’)</p><p>ctx.body &#x3D; result</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>注意：上述的 HMA256 加密算法为单秘钥的形式，⼀旦泄露后果⾮常的危险</p><p>在分布式系统中，每个⼦系统都要获取到秘钥，那么这个⼦系统根据该秘钥可以发布和验证令牌，但</p><p>有些服务器只需要验证令牌</p><p>这时候可以采⽤⾮对称加密，利⽤私钥发布令牌，公钥验证令牌，加密算法可以选择 RS256</p><p>13.3. 优缺点</p><p>优点：• </p><p>json具有通⽤性，所以可以跨语⾔</p><p>• </p><p>组成简单，字节占⽤⼩，便于传输</p><p>• </p><p>服务端⽆需保存会话信息，很容易进⾏⽔平扩展</p><p>• </p><p>⼀处⽣成，多处使⽤，可以在分布式系统中，解决单点登录问题</p><p>• </p><p>可防护CSRF攻击</p><p>缺点：</p><p>• </p><p>payload部分仅仅是进⾏简单编码，所以只能⽤于存储逻辑必需的⾮敏感信息</p><p>• </p><p>需要保护好加密密钥，⼀旦泄露后果不堪设想</p><p>• </p><p>为避免token被劫持，最好使⽤https协议</p>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块（Module）</title>
      <link href="/2025/09/04/vue/%E6%A8%A1%E5%9D%97%EF%BC%88Module%EF%BC%89/"/>
      <url>/2025/09/04/vue/%E6%A8%A1%E5%9D%97%EF%BC%88Module%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="模块（Module）"><a href="#模块（Module）" class="headerlink" title="模块（Module）"></a>模块（Module）</h2><p>，是能够单独命名并独⽴地完成⼀定功能的程序语句的集合（即<strong>程序代码和数据结</strong></p><p><strong>构的集合体</strong>）。</p><p>两个基本的特征：外部特征和内部特征</p><p><strong>外部特征</strong>是指<strong>模块跟外部环境联系的接⼝</strong>（即其他模块或程序调⽤该模块的⽅式，包括有输⼊输出</p><p>参数、引⽤的全局变量）和模块的功能</p><p><strong>内部特征</strong>是指模块的<strong>内部环境具有的特点</strong>（即该模块的局部数据和程序代码）</p><p>为什么需要模块化</p><p>• </p><p>代码抽象</p><p>• </p><p>代码封装</p><p>• </p><p>代码复⽤</p><p>• </p><p>依赖管理</p><p>如果没有模块化，我们代码会怎样？</p><p>• </p><p>变量和⽅法不容易维护，容易污染全局作⽤域</p><p>• </p><p>加载资源的⽅式通过script标签从上到下。</p><p>• </p><p>依赖的环境主观逻辑偏重，代码较多就会⽐较复杂。</p><p>• </p><p>⼤型项⽬资源难以维护，特别是多⼈合作的情况下，资源的引⼊会让⼈奔溃</p><p>ES6 模块内部⾃动采⽤了严格模式，这⾥就不展开严格模式的限制，毕竟这是 ES5 之前就已经规定</p><p>好</p><p>模块功能主要由两个命令构成：</p><p>• </p><p><strong>export ：⽤于规定模块的对外接⼝</strong></p><p>• </p><p><strong>import ：⽤于输⼊其他模块提供的功能</strong></p><p><strong>动态加载</strong></p>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题</title>
      <link href="/2025/09/03/vue/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2025/09/03/vue/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>跨域是指<strong>浏览器的同源策略限制</strong>：当前端页面的协议、域名、端口三者中任意一个与请求的后端接口不一致时，浏览器会阻止该请求，这一限制是为了保障网页安全。</p><ul><li>同源定义：协议（如<code>http/https</code>）、域名（如<code>a.com/b.com</code>）、端口（如<code>80/8080</code>）完全相同。</li><li>举例：Vue 项目（运行在<code>http://localhost:8080</code>）请求后端接口<code>http://api.example.com</code>，因域名不同会触发跨域。</li></ul><h3 id="2-Vue-中如何解决跨域"><a href="#2-Vue-中如何解决跨域" class="headerlink" title="2. Vue 中如何解决跨域"></a>2. Vue 中如何解决跨域</h3><p>Vue 项目中常用的跨域解决方案有以下 2 种：</p><h4 id="（1）开发环境：配置-Vue-脚手架的代理（vue-config-js）"><a href="#（1）开发环境：配置-Vue-脚手架的代理（vue-config-js）" class="headerlink" title="（1）开发环境：配置 Vue 脚手架的代理（vue.config.js）"></a>（1）开发环境：配置 Vue 脚手架的代理（<code>vue.config.js</code>）</h4><p>通过 webpack 的 devServer 代理，将前端请求转发到后端接口，避开浏览器同源限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123; <span class="comment">// 匹配以/api开头的请求</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://api.example.com&#x27;</span>, <span class="comment">// 后端接口地址</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 开启跨域（伪装请求来源为目标域名）</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125; <span class="comment">// 去掉请求路径中的/api前缀</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用时，前端请求<code>/api/user</code>会被代理到<code>http://api.example.com/user</code>。</p><h4 id="（2）生产环境：后端配置-CORS（跨域资源共享）"><a href="#（2）生产环境：后端配置-CORS（跨域资源共享）" class="headerlink" title="（2）生产环境：后端配置 CORS（跨域资源共享）"></a>（2）生产环境：后端配置 CORS（跨域资源共享）</h4><p>由后端在响应头中添加允许跨域的配置，常见的响应头包括：</p><ul><li><code>Access-Control-Allow-Origin: http://your-frontend-domain</code>（允许指定前端域名跨域）</li><li><code>Access-Control-Allow-Methods: GET,POST,PUT,DELETE</code>（允许的请求方法）</li><li><code>Access-Control-Allow-Headers: Content-Type</code>（允许的请求头）</li></ul>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Node.js 的理解</title>
      <link href="/2025/09/02/vue/%E5%AF%B9Node.js%20%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2025/09/02/vue/%E5%AF%B9Node.js%20%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="对Node-js-的理解"><a href="#对Node-js-的理解" class="headerlink" title="对Node.js 的理解"></a>对Node.js 的理解</h2><p>Node.js 是⼀个开源与跨平台的 JavaScript 运⾏时环境</p><p>在浏览器外运⾏ V8 JavaScript 引擎（Google Chrome 的内核），利⽤事件驱动、⾮阻塞和异步输⼊</p><p>输出模型等技术提⾼性能</p><p>可以理解为 <strong>Node.js 就是⼀个服务器端的、⾮阻塞式I&#x2F;O的、事件驱动的 JavaScript 运⾏环境</strong></p><p>Nodejs 采⽤了<strong>⾮阻塞型 I&#x2F;O 机制</strong>，在做 I&#x2F;O 操作的时候不会造成任何的阻塞，当完成之后，以时</p><p>间的形式通知执⾏操作</p><p>例如在执⾏了访问数据库的代码之后，将⽴即转⽽执⾏其后⾯的代码，把数据库返回结果的处理代码</p><p>放在回调函数中，从⽽提⾼了程序的执⾏效率</p><p><strong>事件驱动</strong>就是当进来⼀个新的请求的时，请求将会被压⼊⼀个事件队列中，然后通过⼀个循环来检测</p><p>队列中的事件状态变化，如果检测到有状态变化的事件，那么就执⾏该事件对应的处理代码，⼀般都</p><p>是回调函数</p><p>⽐如读取⼀个⽂件，⽂件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进⾏处理</p><h3 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h3><p>fs（filesystem），该模块提供本地⽂件的读写能⼒，基本上是 POSIX ⽂件操作命令的简单包装</p><p>可以说，所有与⽂件的操作都是通过 fs 核⼼模块实现</p><p>导⼊模块如下：</p><p>1 const fs &#x3D; require(‘fs’);</p><p>这个模块对所有⽂件系统操作提供异步（不具有 sync 后缀）和同步（具有 sync 后缀）两种操作</p><p>⽅式，⽽供开发者选择</p><p>2.1.1. ⽂件知识</p><p>在计算机中有关于⽂件的知识：</p><p>• </p><p>权限位 mode</p><p>• </p><p>标识位 flag</p><p>• </p><p>⽂件描述为 fd</p><p>2.1.2. 权限位 mode针对⽂件所有者、⽂件所属组、其他⽤⼾进⾏权限分配，其中类型⼜分成读、写和执⾏，具备权限位</p><p>4、2、1，不具备权限为0</p><p>如在 linux 查看⽂件权限位：</p><p>1 drwxr-xr-x 1 PandaShen 197121 0 Jun 28 14:41 core</p><p>2 -rw-r–r– 1 PandaShen 197121 293 Jun 23 17:44 index.md</p><p>在开头前⼗位中， d 为⽂件夹， - 为⽂件，后九位就代表当前⽤⼾、⽤⼾所属组和其他⽤⼾的权限</p><p>位，按每三位划分，分别代表读（r）、写（w）和执⾏（x），- 代表没有当前位对应的权限</p>]]></content>
      
      
      <categories>
          
          <category> vue框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回流和重绘</title>
      <link href="/2025/08/23/css/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/"/>
      <url>/2025/08/23/css/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/</url>
      
        <content type="html"><![CDATA[<h2 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h2><p>在 HTML 中，每个元素都可以理解成⼀个盒⼦，在浏览器解析过程中，会涉及到回流与重绘：</p><p>• </p><p>回流：布局引擎会根据各种样式<strong>计算每个盒⼦在⻚⾯上的⼤⼩与位置</strong></p><p>• </p><p>重绘：当<strong>计算好</strong>盒模型的位置、⼤⼩及其他属性后，浏览器<strong>根据每个盒⼦特性进⾏绘制</strong></p><p>在⻚⾯<strong>初始渲染</strong>阶段，<strong>回流不可避免的触发</strong>，可以理解成⻚⾯⼀开始是空⽩的元素，后⾯添加了新的</p><p>元素使⻚⾯布局发⽣改变</p><p>当我们<strong>对 DOM 的修改引发了 DOM ⼏何尺⼨的变化</strong>（⽐如<strong>修改元素的宽、⾼或隐藏元素等</strong>）时，浏</p><p>览器需要<strong>重新计算元素的⼏何属性</strong>，然后<strong>再将计算的结果绘制</strong>出来</p><p>当我们对 DOM 的修改导致了<strong>样式的变化</strong>（ color 或 background-color ），却并未影响其⼏何</p><p>属性时，浏览器不需重新计算元素的⼏何属性、直接为该元素绘制新的样式，这⾥就<strong>仅仅触发了重绘</strong></p><p><strong>回流触发时机</strong></p><p>回流这⼀阶段主要是计算节点的位置和⼏何信息，那么当⻚⾯布局和⼏何信息发⽣变化的时候，就需</p><p>要回流，如下⾯情况：</p><p>• </p><p>添加或删除可⻅的DOM元素</p><p>• </p><p>元素的位置发⽣变化</p><p>• </p><p>元素的尺⼨发⽣变化（包括外边距、内边框、边框⼤⼩、⾼度和宽度等）</p><p>• </p><p>内容发⽣变化，⽐如⽂本变化或图⽚被另⼀个不同尺⼨的图⽚所替代</p><p>• </p><p>⻚⾯⼀开始渲染的时候（这避免不了）</p><p>• </p><p>浏览器的窗⼝尺⼨变化（因为回流是根据视⼝的⼤⼩来计算元素的位置和⼤⼩的）</p><p>还有⼀些容易被忽略的操作：获取⼀些特定属性的值</p><p>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、</p><p>scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</p><p>这些属性有⼀个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进⾏回流</p><p>除此还包括 getComputedStyle ⽅法，原理是⼀样的</p><p><strong>重绘触发时机</strong></p><p>触发回流⼀定会触发重绘</p><p>可以把⻚⾯理解为⼀个⿊板，⿊板上有⼀朵画好的⼩花。现在我们要把这朵从左边移到了右边，那我</p><p>们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜⾊（重绘）</p><p>除此之外还有⼀些其他引起重绘⾏为：</p><p>• </p><p>颜⾊的修改</p><p>• </p><p>⽂本⽅向的修改</p><p>• </p><p>阴影的修改</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this对象</title>
      <link href="/2025/08/20/js/this%E5%AF%B9%E8%B1%A1/"/>
      <url>/2025/08/20/js/this%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h2><p>函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和⾮严格模式之间也</p><p>会有⼀些差别</p><p>在绝⼤多数情况下，函数的调⽤⽅式决定了 this 的值（<strong>运⾏时绑定</strong>）</p><p>this 关键字是函数运⾏时⾃动⽣成的⼀个内部对象，只能在函数内部使⽤，总指向调⽤它的对象</p><p>• </p><p>默认绑定</p><p>全局环境中定义 person 函数，内部使⽤ this 关键字</p><p>隐式绑定</p><p>函数还可以作为某个对象的⽅法调⽤，这时 this 就指这个上级对象</p><p>new绑定</p><p>•通过构建函数 new 关键字⽣成⼀个实例对象，此时 this 指向这个实例对象</p><p>显⽰绑定</p><p>apply()、call()、bind() 是函数的⼀个⽅法，作⽤是改变函数的调⽤对象。它的第⼀个参数就</p><p>表⽰改变后的调⽤这个函数的对象。因此，这时 this 指的就是这第⼀个参数</p><p><strong>bind、call、apply 区别？如何实现⼀个bind?</strong></p><p>apply 接受两个参数，第⼀个参数是 this 的指向，第⼆个参数是函数接受的参数，以数组的形式</p><p>传⼊</p><p>改变 this 指向后原函数会⽴即执⾏，且此⽅法只是临时改变 this 指向⼀次</p><p>call ⽅法的第⼀个参数也是 this 的指向，后⾯传⼊的是⼀个参数列表</p><p>跟 apply ⼀样，改变 this 指向后原函数会⽴即执⾏，且此⽅法只是临时改变 this 指向⼀次</p><p>bind改变 this 指向后不会⽴即执⾏，⽽是<strong>返回⼀个永久改变 this 指向的函数</strong></p><p>⼩结</p><p>从上⾯可以看到， apply 、 call 、 bind 三者的区别在于：</p><p>• </p><p>三者都可以改变函数的 this 对象指向</p><p>• </p><p>三者第⼀个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或</p><p>null ，则默认指向全局 window</p><p>• </p><p>三者都可以传参，但是 apply 是数组，⽽ call 是参数列表，且 apply 和 call 是⼀次性传⼊</p><p>参数，⽽ bind 可以分为多次传⼊</p><p>• </p><p>bind 是返回绑定this之后的函数， apply 、 call 则是⽴即执</p><h2 id="事件与事件流"><a href="#事件与事件流" class="headerlink" title="事件与事件流"></a>事件与事件流</h2><p>javascript 中的事件，可以理解就是<strong>在 HTML ⽂档或者浏览器中发⽣的⼀种交互操作</strong>，使得⽹⻚</p><p>具备互动性， 常⻅的有<strong>加载事件、⿏标事件、⾃定义事件等</strong></p><p>由于 DOM 是⼀个树结构，如果在⽗⼦节点绑定事件时候，当触发⼦节点的时候，就存在⼀个顺序问</p><p>题，这就涉及到了事件流的概念</p><p>事件流都会经历三个阶段：</p><p>• </p><p>事件捕获阶段(capture phase)</p><p>• </p><p>处于⽬标阶段(target phase)</p><p>• </p><p>事件冒泡阶段(bubbling phase</p><h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>事件代理，俗地来讲，就是把⼀个元素响应事件（ click 、 keydown ……）的函数委托到另⼀个元</p><p>素</p><p>前⾯讲到，事件流的都会经过三个阶段： 捕获阶段 -&gt; ⽬标阶段 -&gt; 冒泡阶段，⽽事件委托就是在冒泡</p><p>阶段完成</p><p>事件委托，会<strong>把⼀个或者⼀组元素的事件委托到它的⽗层或者更外层元素上</strong>，<strong>真正绑定事件的是外层</strong></p><p><strong>元素，⽽不是⽬标元素</strong></p><p>当事件响应到⽬标元素上时，会通过事件冒泡机制从⽽触发它的外层元素的绑定事件上，然后在外层</p><p>元素上去执⾏函数</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript本地存储</title>
      <link href="/2025/08/20/js/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
      <url>/2025/08/20/js/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Javascript本地存储"><a href="#Javascript本地存储" class="headerlink" title="Javascript本地存储"></a>Javascript本地存储</h2><p>javaScript 本地缓存的⽅法我们主要讲述以下四种：</p><p>• </p><p>cookie</p><p>• </p><p>Cookie ，类型为「⼩型⽂本⽂件」，指某些<strong>⽹站为了辨别⽤⼾⾝份⽽储存在⽤⼾本地终端上的数</strong></p><p><strong>据</strong>。是为了解决 HTTP ⽆状态导致的问题</p><p>作为⼀段⼀般不超过 4KB 的⼩型⽂本数据，它由⼀个名称（Name）、⼀个值（Value）和其它⼏个⽤</p><p>于控制 cookie 有效期、安全性、使⽤范围的可选属性组成</p><p>但是 <strong>cookie 在每次请求中都会被发送，如果不使⽤ HTTPS 并对其加密，其保存的信息很容易被窃</strong></p><p><strong>取，导致安全⻛险</strong>。举个例⼦，在⼀些使⽤ cookie 保持登录态的⽹站上，如果 cookie 被窃取，</p><p>他⼈很容易利⽤你的 cookie 来假扮成你登录⽹站</p><p>sessionStorage</p><p>sessionStorage 和 localStorage 使⽤⽅法基本⼀致，唯⼀不同的是⽣命周期，<strong>⼀旦⻚⾯</strong></p><p><strong>（会话）关闭， sessionStorage 将会删除数据</strong></p><p>localStorage</p><p>⽣命周期：<strong>持久化的本地存储</strong>，除⾮主动删除数据，否则数据是永远不会过期的</p><p>存储的信息在同⼀域中是共享的</p><p>当本⻚操作（新增、修改、删除）了 localStorage 的时候，本⻚⾯不会触发 storage 事件,</p><p>但是别的⻚⾯会触发 storage 事件。</p><p>关于 cookie 、 sessionStorage 、 localStorage 三者的<strong>区别主要如下</strong>：</p><p>• </p><p>存储⼤⼩： cookie 数据⼤⼩不能超过 4k ， sessionStorage 和 localStorage 虽然也有</p><p>存储⼤⼩的限制，但⽐ cookie ⼤得多，可以达到5M或更⼤</p><p>• </p><p>有效时间： <strong>localStorage 存储持久数据，浏览器关闭后数据不丢失除⾮主动删除数据</strong>；</p><p><strong>sessionStorage</strong> 数据在当前浏览器窗⼝关闭后<strong>⾃动删除</strong>； <strong>cookie 设置的 cookie 过期时</strong></p><p><strong>间之前⼀直有效</strong>，即使窗⼝或浏览器关闭• </p><p>数据与服务器之间的交互⽅式， cookie 的数据会⾃动的传递到服务器，服务器端也可以写</p><p>cookie 到客⼾端； sessionStorage 和 localStorage 不会⾃动把数据发给服务器，仅</p><p>在本地保存</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js基本类型与数据结构</title>
      <link href="/2025/08/20/js/js%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2025/08/20/js/js%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="基本类型主要为以下6种："><a href="#基本类型主要为以下6种：" class="headerlink" title="基本类型主要为以下6种："></a>基本类型主要为以下6种：</h2><p>Number</p><p>String</p><p>Boolean</p><p>Undefined</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Undefined 类型只有⼀个值，就是特殊值 undefined 。当使⽤ var 或 let 声明了变量但没</span><br><span class="line"></span><br><span class="line">有初始化时，就相当于给变量赋予了 undefined 值</span><br></pre></td></tr></table></figure><p>null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Null 类型同样只有⼀个值，即特殊值 null</span><br><span class="line"></span><br><span class="line">逻辑上讲， null 值表⽰⼀个空对象指针，这也是给 typeof 传⼀个 null 会返回 &quot;object&quot; 的原</span><br><span class="line"></span><br><span class="line">因</span><br></pre></td></tr></table></figure><p>undefined 值是由 null 值派⽣⽽来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(null == undefined); // true</span><br></pre></td></tr></table></figure><p>symbol</p><h2 id="引⽤类型"><a href="#引⽤类型" class="headerlink" title="引⽤类型"></a>引⽤类型</h2><p>复杂类型统称为 Object ，我们这⾥主要讲述下⾯三种：</p><p>Object</p><p>Array</p><p>JavaScript 数组是⼀组有序的数据，但跟其他语⾔不同的是，数组中每个槽位可以存储任意类型</p><p>的数据。并且，数组也是动态⼤⼩的，会随着数据添加⽽⾃动增⻓</p><p>Fuction</p><p>函数实际上是对象，每个函数都是 Function 类型的实例，⽽ Function 也有属性和⽅法，跟其</p><p>他引⽤类型⼀样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">• 箭头函数</span><br><span class="line">let sum = (num1, num2) =&gt; &#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了上述说的三种之外，还包括 Date 、 RegExp 、 Map 、 Set 等……</p><h2 id="js数据结构"><a href="#js数据结构" class="headerlink" title="js数据结构"></a>js数据结构</h2><ol><li><p>数组（Array）</p></li><li><p>栈（Stack）</p></li><li><p>队列（Queue）</p></li><li><p>链表（Linked List）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">链表也是⼀种列表，已经设计了数组，为什么还需要链表呢？</span><br><span class="line">JavaScript中数组的主要问题时，它们被实现成了对象，</span><br><span class="line">与其他语⾔（⽐如C++和Java）的数组相对，效率很低。</span><br><span class="line">如果你发现数组在实际使⽤时很慢，就可以考虑使⽤链表来代替它。</span><br><span class="line">使⽤条件：</span><br><span class="line">链表⼏乎可以⽤在任何可以使⽤⼀维数组的情况中。</span><br><span class="line">如果需要随机访问，数组仍然是更好的选择。</span><br></pre></td></tr></table></figure></li><li><p>字典</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字典是⼀种以键-值对存储数据的数据结构，js中的Object类就是以字典的形式设计的。JavaScript可</span><br><span class="line">以通过实现字典类，让这种字典类型的对象使⽤起来更加简单，字典可以实现对象拥有的常⻅功能，</span><br><span class="line">并相应拓展⾃⼰想要的功能，⽽对象在JavaScript编写中随处可⻅，所以字典的作⽤也异常明显了。</span><br></pre></td></tr></table></figure></li><li><p>散列表（Hash table）</p><p>特点是在散列表上插⼊、删除和取⽤数据都⾮常快</p></li><li><p>树（Tree）</p></li><li><p>图（Graph）</p></li><li><p>堆（Heap）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM常⻅的操作</title>
      <link href="/2025/08/20/js/DOM%E5%B8%B8%E2%BB%85%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/08/20/js/DOM%E5%B8%B8%E2%BB%85%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="DOM常⻅的操作"><a href="#DOM常⻅的操作" class="headerlink" title="DOM常⻅的操作"></a>DOM常⻅的操作</h2><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251205202238805.png" alt="image-20251205202230928"></p><p>⽂档对象模型 (DOM) 是 HTML 和 XML ⽂档的编程接⼝</p><p>创建节点</p><p>createElement创建新元素，接受⼀个参数，即要创建元素的标签名</p><p>createTextNode创建⼀个⽂本节点</p><p>createDocumentFragment⽤来创建⼀个⽂档碎⽚，它表⽰⼀种轻量级的⽂档，主要是⽤来存储临时节点，然后把⽂档碎⽚的内</p><p>容⼀次性添加到 DOM 中</p><p>createAttribute创建属性节点，可以是⾃定义属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const dataAttribute = document.createAttribute(&#x27;custom&#x27;);</span><br><span class="line"> consle.log(dataAttribute);</span><br></pre></td></tr></table></figure><p>查询节点</p><p>返回⼀个包含节点⼦树内所有与之相匹配的 Element 节点列表，如果没有相匹配的，则返回⼀个空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 document.getElementById(&#x27;id属性值&#x27;);返回拥有指定id的对象的引⽤</span><br><span class="line">2 document.getElementsByClassName(&#x27;class属性值&#x27;);返回拥有指定class的对象集合</span><br><span class="line">3 document.getElementsByTagName(&#x27;标签名&#x27;);返回拥有指定标签名的对象集合</span><br><span class="line">4 document.getElementsByName(&#x27;name属性值&#x27;); 返回拥有指定名称的对象结合</span><br><span class="line">5 document/element.querySelector(&#x27;CSS选择器&#x27;); 仅返回第⼀个匹配的元素</span><br><span class="line">6 document/element.querySelectorAll(&#x27;CSS选择器&#x27;); 返回所有匹配的元素</span><br><span class="line">7 document.documentElement; 获取⻚⾯中的HTML标签</span><br><span class="line">8 document.body; 获取⻚⾯中的BODY标签</span><br><span class="line">9 document.all[&#x27;&#x27;]; 获取⻚⾯中的所有元素节点的对象集合型</span><br></pre></td></tr></table></figure><p>节点列表</p><p>更新节点</p><p>添加节点</p><p>appendChild把⼀个⼦节点添加到⽗节点的最后⼀个⼦节点</p><p>删除节点</p><h2 id="BOM-Browser-Object-Model"><a href="#BOM-Browser-Object-Model" class="headerlink" title="BOM (Browser Object Model)"></a>BOM (Browser Object Model)</h2><p>浏览器对象模型，提供了独⽴于内容与浏览器窗⼝进⾏交互的对象</p><p>其作⽤就是<strong>跟浏览器做⼀些交互效果</strong>,⽐如如何进⾏⻚⾯的后退，前进，刷新，浏览器的窗⼝发⽣变</p><p>化，滚动条的滚动，以及获取客⼾的⼀些信息如：浏览器品牌版本，屏幕分辨率</p><p>浏览器的全部内容可以看成 DOM ，整个浏览器可以看成 BOM 。</p><h2 id="和-区别"><a href="#和-区别" class="headerlink" title="&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别"></a>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别</h2><p><strong>等于操作符</strong></p><p>等于操作符⽤两个等于号（ &#x3D;&#x3D; ）表⽰，如果操作数相等，则会返回 true</p><p>前⾯⽂章，我们提到在JavaScript中存在<strong>隐式转换</strong>。<strong>等于操作符（&#x3D;&#x3D;）在⽐较中会先进⾏类型转换</strong>，</p><p>再确定操作数是否相等</p><p>遵循以下规则：</p><p>如果任⼀操作数是布尔值，则将其转换为数值再⽐较是否相等</p><p>如果⼀个操作数是字符串，另⼀个操作数是数值，则尝试将字符串转换为数值，再⽐较是否相等</p><p>如果⼀个操作数是对象，另⼀个操作数不是，则调⽤对象的 valueOf()⽅法取得其原始值，再根据前⾯</p><p>的规则进⾏⽐较</p><p>null和undefined相等</p><p>如果有任⼀操作数是 NaN ，则相等操作符返回 false</p><p>如果两个操作数都是对象，则⽐较它们是不是同⼀个对象。如果两个操作数都指向同⼀个对象，则相</p><p>等操作符返回true</p><p>下⾯进⼀步做个⼩结：</p><p>● 两个都为简单类型，字符串和布尔值都会转换成数值，再⽐较</p><p>● 简单类型与引⽤类型⽐较，对象转化成其原始类型的值，再⽐较</p><p>● 两个都为引⽤类型，则⽐较它们是否指向同⼀个对象</p><p>● <strong>null 和 undefined 相等</strong></p><p>● 存在 NaN 则返回 false</p><p><strong>全等操作符</strong></p><p>全等操作符由 3 个等于号（ &#x3D;&#x3D;&#x3D; ）表⽰，只有两个操作数<strong>在不转换的前提下相等才返回 true</strong>。即类型</p><p>相同，值也需相同</p><p>undefined 和 null 与⾃⾝严格相等</p><p>5.3区别</p><p>相等操作符（&#x3D;&#x3D;）会做类型转换，再进⾏值的⽐较，全等运算符不会做类型转换</p><p>null 和 undefined ⽐较，相等操作符（&#x3D;&#x3D;）为true，全等为false</p><h2 id="typeof-与-instanceof-区别"><a href="#typeof-与-instanceof-区别" class="headerlink" title="typeof 与 instanceof 区别"></a>typeof 与 instanceof 区别</h2><p>typeof与instanceof都是判断数据类型的⽅法，区别如下：</p><p>● typeof会返回⼀个变量的基本类型，instanceof返回的是⼀个布尔值</p><p>● instanceof 可以准确地判断复杂引⽤数据类型，但是不能正确判断基础数据类型</p><p>● ⽽typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引⽤数据类型中，除了</p><p>function 类型以外，其他的也⽆法判断</p><p>可以看到，上述两种⽅法都有弊端，并不能满⾜所有场景的需求</p><p>如果需要通⽤检测数据类型，可以采⽤Object.prototype.toString，调⽤该⽅法，统⼀返回格</p><p>式“[object Xxx]”的字符串</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async与await</title>
      <link href="/2025/08/20/js/async%E4%B8%8Eawait/"/>
      <url>/2025/08/20/js/async%E4%B8%8Eawait/</url>
      
        <content type="html"><![CDATA[<h2 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h2><p>async 是异步的意思， await 则可以理解为 async wait 。所以可以理解 async 就是⽤来声</p><p>明⼀个异步⽅法，⽽ await 是⽤来等待异步⽅法执⾏</p><p>21.3.1. async</p><p>async 函数返回⼀个 promise 对象，下⾯两种⽅法是等效的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 function f() &#123;</span><br><span class="line"></span><br><span class="line">2 return Promise.resolve(&#x27;TEST&#x27;);</span><br><span class="line"></span><br><span class="line">3 &#125;</span><br><span class="line"></span><br><span class="line">4 *// asyncF is equivalent to f!*</span><br><span class="line"></span><br><span class="line">5 async function asyncF() &#123;</span><br><span class="line"></span><br><span class="line">6 return &#x27;TEST&#x27;;</span><br><span class="line"></span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure><p>21.3.2. await正常情况下， await 命令后⾯是⼀个 Promise 对象，返回该对象的结果。如果不是 Promise 对</p><p>象，就直接返回对应的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 async function f()&#123;</span><br><span class="line"></span><br><span class="line">2 *//* *等同于*</span><br><span class="line"></span><br><span class="line">3 *// return 123*</span><br><span class="line"></span><br><span class="line">4 return await 123</span><br><span class="line"></span><br><span class="line">5 &#125;</span><br><span class="line"></span><br><span class="line">6 f().then(v =&gt; console.log(v)) *// 123*</span><br></pre></td></tr></table></figure><p>不管 await 后⾯跟着的是什么， await 都会阻塞后⾯的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 async function fn1 ()&#123;</span><br><span class="line"></span><br><span class="line">2 console.log(1)</span><br><span class="line"></span><br><span class="line">3 await fn2()</span><br><span class="line"></span><br><span class="line">4 console.log(2) *//* *阻塞*</span><br><span class="line"></span><br><span class="line">5 &#125;</span><br><span class="line"></span><br><span class="line">6 async function fn2 ()&#123;</span><br><span class="line"></span><br><span class="line">7 console.log(&#x27;fn2&#x27;)</span><br><span class="line"></span><br><span class="line">8 &#125;</span><br><span class="line"></span><br><span class="line">9 fn1()</span><br><span class="line"></span><br><span class="line">10 console.log(3)</span><br></pre></td></tr></table></figure><p>上⾯的例⼦中， await 会阻塞下⾯的代码（即加⼊微任务队列），先执⾏ async 外⾯的同步代</p><p>码，同步代码执⾏完，再回到 async 函数中，再执⾏之前阻塞的代码</p><p>所以上述输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ， fn2 ， 3 ， 2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1 async function async1() &#123;</span><br><span class="line">2 console.log(&#x27;async1 start&#x27;)</span><br><span class="line">3 await async2()</span><br><span class="line">4 console.log(&#x27;async1 end&#x27;)</span><br><span class="line">5 &#125;</span><br><span class="line">6 async function async2() &#123;</span><br><span class="line">7 console.log(&#x27;async2&#x27;)</span><br><span class="line">8 &#125;</span><br><span class="line">9 console.log(&#x27;script start&#x27;)</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">console.log(&#x27;settimeout&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">async1()</span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">console.log(&#x27;promise1&#x27;)</span><br><span class="line">resolve()</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">console.log(&#x27;promise2&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br></pre></td></tr></table></figure><p>分析过程：</p><ol><li>执⾏整段代码，遇到 console.log(‘script start’) 直接打印结果，输出 script</li><li>s遇 t到 ar定 t时器了，它是宏任务，先放着不执⾏</li><li>遇到 async1() ，执⾏ async1 函数，先打印 async1 start ，下⾯遇到 await 怎么办？</li></ol><p>先执⾏ async2 ，打印 async2 ，然后阻塞下⾯代码（即加⼊微任务列表），跳出去执⾏同步</p><p>代码 </p><p>4. </p><p>跳到 new Promise 这⾥，直接执⾏，打印 promise1 ，下⾯遇到 .then() ，它是微任</p><p>务，放到微任务列表等待执⾏</p><ol start="5"><li>最后⼀⾏直接打印 script end ，现在同步代码执⾏完了，开始执⾏微任务，即 await 下⾯的</li></ol><p>代码，打印 async1 end</p><ol start="6"><li>继续执⾏下⼀个微任务，即执⾏ then 的回调，打印 promise2</li><li>上⼀个宏任务所有事都做完了，开始下⼀个宏任务，就是定时器，打印 settimeout</li></ol><p>所以最后的结果是： script start 、 async1 start 、 async2 、 promise1 、 script</p><p>end 、 async1 end 、 promise2 、 settimeout</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax原理</title>
      <link href="/2025/08/20/js/ajax%E5%8E%9F%E7%90%86/"/>
      <url>/2025/08/20/js/ajax%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="ajax原理"><a href="#ajax原理" class="headerlink" title="ajax原理"></a>ajax原理</h2><p>AJAX 全称(Async Javascript and XML)</p><p>即<strong>异步的 JavaScript 和 XML</strong> ，是⼀种创建交互式⽹⻚应⽤的⽹⻚开发技术，可以在<strong>不重新加载整</strong></p><p><strong>个⽹⻚的情况下，与服务器交换数据，并且更新部分⽹⻚</strong></p><p>Ajax 的原理简单来说<strong>通过 XmlHttpRequest 对象来向服务器发异步请求</strong>，从服务器获得数据，然</p><p>后⽤ JavaScript 来操作 DOM ⽽更新⻚⾯</p><p>实现 Ajax 异步交互需要服务器逻辑进⾏配合，需要完成以下步骤：</p><p>• </p><p>创建 Ajax 的核⼼对象 XMLHttpRequest 对象</p><p>• </p><p>通过 XMLHttpRequest 对象的 open() ⽅法与服务端建⽴连接</p><p>• </p><p>构建请求所需的数据内容，并通过 XMLHttpRequest 对象的 send() ⽅法发送给服务器端</p><p>• </p><p>通过 XMLHttpRequest 对象提供的 onreadystatechange 事件监听服务器端你的通信状</p><p>• 态接受并处理服务端向客⼾端响应的数据结果</p><p>• </p><p>将处理结果更新到 HTML ⻚⾯中</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的常⽤⽅法</title>
      <link href="/2025/08/20/js/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E2%BD%A4%E2%BD%85%E6%B3%95/"/>
      <url>/2025/08/20/js/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E2%BD%A4%E2%BD%85%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数组的常⽤⽅法"><a href="#数组的常⽤⽅法" class="headerlink" title="数组的常⽤⽅法"></a>数组的常⽤⽅法</h2><p>下⾯前三种是对原数组产⽣影响的<strong>增添</strong>⽅法，第四种则不会对原数组产⽣影响</p><p>push()push() ⽅法接收任意数量的参数，并将它们<strong>添加到数组末尾</strong>，返回数组的最新⻓度</p><p>unshift()unshift()在<strong>数组开头添加</strong>任意多个值，然后返回新的数组⻓度</p><p>splice()传⼊三个参数，分别是开始位置、0（要删除的元素数量）、插⼊的元素，返回空数组</p><p>concat()创建⼀个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，</p><p>不会影响原始数组</p><p>下⾯三种<strong>删除</strong>都会影响原数组，最后⼀项不影响原数组：</p><p>pop()⽅法⽤于<strong>删除数组的最后⼀项</strong>，同时减少数组的 length 值，返回被删除的项</p><p>shift()⽅法⽤于<strong>删除数组的第⼀项</strong>，同时减少数组的 length 值，返回被删除的项</p><p>splice()传⼊两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组</p><p>slice()</p><h3 id="转换⽅法"><a href="#转换⽅法" class="headerlink" title="转换⽅法"></a>转换⽅法</h3><p>join() ⽅法接收⼀个参数，即字符串分隔符，返回包含所有项的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">alert(colors.join(&quot;,&quot;)); // red,green,blue</span><br><span class="line">alert(colors.join(&quot;||&quot;)); // red||green||blue</span><br></pre></td></tr></table></figure><h2 id="迭代⽅法"><a href="#迭代⽅法" class="headerlink" title="迭代⽅法"></a>迭代⽅法</h2><p>常⽤来迭代数组的⽅法（都不改变原数组）有如下：</p><p>some()</p><p>对数组每⼀项都运⾏传⼊的测试函数，如果⾄少有1个元素返回 true ，则这个⽅法返回 true</p><p>every()</p><p>对数组每⼀项都运⾏传⼊的测试函数，如果所有元素都返回 true ，则这个⽅法返回 true</p><p>forEach()</p><p>对数组每⼀项都运⾏传⼊的函数，没有返回值</p><p>filter()</p><p>对数组每⼀项都运⾏传⼊的函数，函数返回 true 的项会组成数组之后返回</p><p>map()</p><p>对数组每⼀项都运⾏传⼊的函数，返回由每次函数调⽤的结果构成的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line">let mapResult = numbers.map((item, index, array) =&gt; item * 2);</span><br><span class="line">console.log(mapResult) // 2,4,6,8,10,8,6,4,2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖和节流</title>
      <link href="/2025/08/20/js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>/2025/08/20/js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>本质上是<strong>优化⾼频率执⾏代码的⼀种⼿段</strong></p><p>如：浏览器的 resize 、 scroll 、 keypress 、 mousemove 等事件在触发时，会<strong>不断地调⽤</strong></p><p><strong>绑定在事件上的回调函数</strong>，极⼤地浪费资源，降低前端性能</p><p>为了优化体验，需要对这类事件进⾏调⽤次数的限制，对此我们就可以采⽤ 防抖（debounce） 和 节</p><p>流（throttle） 的⽅式来减少调⽤频率</p><p>节流: <strong>n 秒内只运⾏⼀次</strong>，若在 n 秒内重复触发，只有⼀次⽣效</p><p>• 将时间戳写法的特性与定时器写法的特性相结合，实现⼀个更加精确的节流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 function throttled(fn, delay) &#123;</span><br><span class="line">2 let timer = null</span><br><span class="line">3 let starttime = Date.now()</span><br><span class="line">4 return function () &#123;</span><br><span class="line">5 let curTime = Date.now() // 当前时间</span><br><span class="line">6 let remaining = delay - (curTime - starttime) // 从上⼀次到现在，还剩下多</span><br><span class="line">少多余时间</span><br><span class="line">7 let context = this</span><br><span class="line">8 let args = arguments</span><br><span class="line">9 clearTimeout(timer)</span><br><span class="line">10 if (remaining &lt;= 0) &#123;</span><br><span class="line">11 fn.apply(context, args)</span><br><span class="line">12 starttime = Date.now()</span><br><span class="line">13 &#125; else &#123;</span><br><span class="line">14 timer = setTimeout(fn, remaining);</span><br><span class="line">15 &#125;</span><br><span class="line">16 &#125;</span><br><span class="line">17 &#125;</span><br></pre></td></tr></table></figure><p>防抖: <strong>n 秒后在执⾏该事件</strong>，<strong>若在 n 秒内被重复触发，则重新计时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1 function debounce(func, wait, immediate) &#123;</span><br><span class="line">2 let timeout;</span><br><span class="line">3 return function () &#123;</span><br><span class="line">4 let context = this;</span><br><span class="line">5 let args = arguments;</span><br><span class="line">6 if (timeout) clearTimeout(timeout); // timeout 不为null</span><br><span class="line">7 if (immediate) &#123;</span><br><span class="line">8 let callNow = !timeout; // 第⼀次会⽴即执⾏，以后只有事件执⾏后才会再次触</span><br><span class="line">发</span><br><span class="line">9 timeout = setTimeout(function () &#123;</span><br><span class="line">10 timeout = null;</span><br><span class="line">11 &#125;, wait)</span><br><span class="line">12 if (callNow) &#123;</span><br><span class="line">13 func.apply(context, args)</span><br><span class="line">14 &#125;</span><br><span class="line">15 &#125;</span><br><span class="line">16 else &#123;</span><br><span class="line">17 timeout = setTimeout(function () &#123;</span><br><span class="line">18 func.apply(context, args)</span><br><span class="line">19 &#125;, wait);</span><br><span class="line">20 &#125;</span><br><span class="line">21 &#125;</span><br><span class="line">22 &#125;</span><br></pre></td></tr></table></figure><p>相同点：</p><p>都可以通过使⽤ setTimeout 实现</p><p>⽬的都是，降低回调执⾏频率。节省计算资源</p><p>不同点：</p><p>函数<strong>防抖</strong>，在⼀段连续操作结束后，处理回调，利⽤ <strong>clearTimeout 和 setTimeout</strong> 实现。</p><p>函数节流，在⼀段连续操作中，每⼀段时间只执⾏⼀次，频率较⾼的事件中使⽤来提⾼性能</p><p>函数<strong>防抖关注⼀定时间连续触发的事件</strong>，<strong>只在最后执⾏⼀次</strong>，⽽函数节流⼀段时间内只执⾏⼀次</p><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251207160025262.png" alt="image-20251207160016854"></p><p><strong>防抖</strong>在连续的事件，只需触发⼀次回调的场景有：</p><p>• </p><p>搜索框搜索输⼊。只需⽤⼾最后⼀次输⼊完，再发送请求</p><p>• </p><p>⼿机号、邮箱验证输⼊检测</p><p>• </p><p>窗⼝⼤⼩ resize 。只需窗⼝调整完成后，计算窗⼝⼤⼩。防⽌重复渲染。</p><p><strong>节流</strong>在间隔⼀段时间执⾏⼀次回调的场景有：</p><p>• </p><p>滚动加载，加载更多或滚到底部监听</p><p>• </p><p>搜索框，搜索联想功能</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2025/08/20/js/%E9%97%AD%E5%8C%85/"/>
      <url>/2025/08/20/js/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>⼀个函数和对其周围状态（lexical environment，词法环境）的引⽤捆绑在⼀起（或者说函数被引⽤</p><p>包围），这样的组合就是闭包（closure）</p><p>也就是说，闭包让你可以在⼀个内层函数中访问到其外层函数的作⽤域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function init() &#123;</span><br><span class="line">var name = &quot;Mozilla&quot;; // name 是⼀个被 init 创建的局部变量</span><br><span class="line">function displayName() &#123; // displayName() 是内部函数，⼀个闭包</span><br><span class="line">alert(name); // 使⽤了⽗函数中声明的变量</span><br><span class="line">&#125;</span><br><span class="line">displayName();</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br></pre></td></tr></table></figure><p>任何闭包的使⽤场景都离不开这两点：</p><p>•</p><p>创建私有变量</p><p>• </p><p>延⻓变量的⽣命周期</p><p>⼀般函数的词法环境在函数返回后就被销毁，但是<strong>闭包会保存对创建时所在词法环境的引⽤</strong>，即便<strong>创</strong></p><p><strong>建时所在的执⾏上下⽂被销毁</strong>，但<strong>创建时所在词法环境依然存在</strong>，以达到延⻓变量的⽣命周期的⽬的</p><p>例如计数器、延迟调⽤、回调等闭包的应⽤，其核⼼思想还是创建私有变量和延⻓变量的⽣命周期</p><h2 id="Javascript中如何实现函数缓存"><a href="#Javascript中如何实现函数缓存" class="headerlink" title="Javascript中如何实现函数缓存"></a>Javascript中如何实现函数缓存</h2><p>函数缓存，就是将函数运算过的结果进⾏缓存</p><p>本质上就是⽤空间（缓存存储）换时间（计算过程）</p><p>常⽤于缓存数据计算结果和缓存对象</p><p><strong>实现函数缓存主要依靠闭包、柯⾥化、⾼阶函数</strong></p><h2 id="JavaScript字符串的常⽤⽅法有哪些？"><a href="#JavaScript字符串的常⽤⽅法有哪些？" class="headerlink" title="JavaScript字符串的常⽤⽅法有哪些？"></a>JavaScript字符串的常⽤⽅法有哪些？</h2><p>concat⽤于将⼀个或多个字符串拼接成⼀个新字符串</p><p>这⾥的删的意思并不是说删除原字符串的内容，⽽是创建字符串的⼀个副本，再进⾏操作</p><p>常⻅的有：</p><p>slice()</p><p>substr()</p><p>substring()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let stringValue = &quot;hello world&quot;;</span><br><span class="line">console.log(stringValue.slice(3)); // &quot;lo world&quot;</span><br><span class="line">console.log(stringValue.substring(3)); // &quot;lo world&quot;</span><br><span class="line">console.log(stringValue.substr(3)); // &quot;lo world&quot;</span><br><span class="line">console.log(stringValue.slice(3, 7)); // &quot;lo w&quot;</span><br><span class="line">console.log(stringValue.substring(3,7)); // &quot;lo w&quot;</span><br><span class="line">console.log(stringValue.substr(3, 7)); // &quot;lo worl</span><br></pre></td></tr></table></figure><p>这⾥改的意思也不是改变原字符串，⽽是创建字符串的⼀个副本，再进⾏操作</p><p>常⻅的有：</p><p>trim()、trimLeft()、trimRight()</p><p>删除前、后或前后所有空格符，再返回新的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let stringValue = &quot; hello world &quot;;</span><br><span class="line">let trimmedStringValue = stringValue.trim();</span><br><span class="line">console.log(stringValue); // &quot; hello world &quot;</span><br><span class="line">console.log(trimmedStringValue); // &quot;hello world</span><br></pre></td></tr></table></figure><p>repeat()</p><p>padStart()、padEnd()</p><p>toLowerCase()、 toUpperCase()</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>em/px/rem/vh/vw区别</title>
      <link href="/2025/08/15/css/em,px,rem,vhvw%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/08/15/css/em,px,rem,vhvw%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="em-px-rem-vh-vw区别"><a href="#em-px-rem-vh-vw区别" class="headerlink" title="em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别"></a>em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别</h2><p>传统的项⽬开发中，我们只会⽤到 px 、 % 、 em 这⼏个单位，它可以适⽤于⼤部分的项⽬开发，且</p><p>拥有⽐较良好的兼容性</p><p>从 CSS3 开始，浏览器对计量单位的⽀持⼜提升到了另外⼀个境界，新增了 rem 、 vh 、 vw 、</p><p>vm 等⼀些新的计量单位</p><p>利⽤这些新的单位开发出⽐较良好的响应式⻚⾯，适应多种不同分辨率的终端，包括移动设备等</p><p> 单位</p><p>在 css 单位中，可以分为⻓度单位、绝对单位，如下表所指⽰</p><p>这⾥我们主要讲述px、em、rem、vh、vw</p><p> <strong>px</strong>，表⽰像素，所谓像素就是呈现在我们显⽰器上的⼀个个⼩点，每个像素点都是⼤⼩等同的，所以</p><p>像素为计量单位被分在了绝对⻓度单位中</p><p>有些⼈会把 px 认为是相对⻓度，原因在于在移动端中存在设备像素⽐， <strong>px 实际显⽰的⼤⼩是不确</strong></p><p><strong>定的</strong></p><p>这⾥之所以认为 px 为绝对单位，在于 px 的⼤⼩和元素的其他属性⽆关</p><p>16.2.2. em</p><p><strong>em是相对⻓度单位</strong>。相对于当前对象内⽂本的字体尺⼨。如当前对⾏内⽂本的字体尺⼨未被⼈为设</p><p>置，则相对于浏览器的默认字体尺⼨（ <strong>1em &#x3D; 16px</strong> ）</p><p>为了简化 font-size 的换算，我们需要在 css 中的 body 选择器中声明 <strong>font-size &#x3D;</strong></p><p><strong>62.5% ，这就使 em 值变为 16px*62.5% &#x3D; 10px</strong></p><p>这样 12px &#x3D; 1.2em , 10px &#x3D; 1em , 也就是说只需要将你的原来的 px 数值除以 10，然后换上</p><p>em 作为单位就⾏了</p><p>特点：</p><p>• </p><p>em 的值并不是固定的</p><p>• </p><p>em 会继承⽗级元素的字体⼤⼩</p><p>• </p><p>em 是相对⻓度单位。<strong>相对于当前对象内⽂本的字体尺⼨</strong>。如当前对⾏内⽂本的字体尺⼨未被⼈为</p><p>设置，则相对于浏览器的默认字体尺⼨</p><p>• </p><p>任意浏览器的默认字体⾼都是 16px</p><p><strong>rem</strong>，<strong>相对单位，相对的只是HTML根元素 font-size 的值</strong></p><p>同理，如果想要简化 font-size 的转化，我们可以在根元素 html 中加⼊ font-size: 62.5%</p><p>1 html {font-size: 62.5%; } <em>&#x2F;</em>* <em>公式**16px*62.5%&#x3D;10px *&#x2F;</em></p><p>这样⻚⾯中1rem&#x3D;10px、1.2rem&#x3D;12px、1.4rem&#x3D;14px、1.6rem&#x3D;16px;使得视觉、使⽤、书写都得到</p><p>了极⼤的帮助</p><p>特点：</p><p>• </p><p>rem单位可谓集相对⼤⼩和绝对⼤⼩的优点于⼀⾝</p><p>• </p><p><strong>和em不同的是rem总是相对于根元素，⽽不像em⼀样使⽤级联的⽅式来计算尺⼨</strong></p><p> vh、vw</p><p>vw ，就是根据窗⼝的宽度，分成100等份，100vw就表⽰满宽，50vw就表⽰⼀半宽。（vw 始终是针</p><p>对窗⼝的宽），同理， vh 则为窗⼝的⾼度</p><p>这⾥的窗⼝分成⼏种情况：</p><p>• </p><p>在桌⾯端，指的是浏览器的可视区域</p><p>• </p><p>移动端指的就是布局视⼝</p><p>像 vw 、 vh ，⽐较容易混淆的⼀个单位是 % ，不过百分⽐宽泛的讲是相对于⽗元素：</p><p>• </p><p>对于普通定位元素就是我们理解的⽗元素</p><p>• </p><p>对于position: absolute;的元素是相对于已定位的⽗元素</p><p>• </p><p>对于position: fixed;的元素是相对于 ViewPort（可视窗⼝）</p><p>16.3. 总结</p><p>px：绝对单位，⻚⾯按精确像素展⽰</p><p>em：相对单位，<strong>基准点为⽗节点字体的⼤⼩</strong>，如果⾃⾝定义了 font-size 按⾃⾝来计算，整个⻚</p><p>⾯内 1em 不是⼀个固定的值</p><p>rem：相对单位，可理解为 root em , 相<strong>对根节点 html 的字体⼤⼩来计算</strong></p><p><strong>vh、vw：主要⽤于⻚⾯视⼝⼤⼩布局，在⻚⾯布局上更加⽅便简单</strong></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备像素、css像素、设备独⽴像素、dpr、ppi 之间的区别</title>
      <link href="/2025/08/13/css/%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E3%80%81css%E5%83%8F%E7%B4%A0%E3%80%81%E8%AE%BE%E5%A4%87%E7%8B%AC%E2%BD%B4%E5%83%8F%E7%B4%A0%E3%80%81dpr%E3%80%81ppi%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/08/13/css/%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E3%80%81css%E5%83%8F%E7%B4%A0%E3%80%81%E8%AE%BE%E5%A4%87%E7%8B%AC%E2%BD%B4%E5%83%8F%E7%B4%A0%E3%80%81dpr%E3%80%81ppi%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="设备像素、css像素、设备独⽴像素、dpr、ppi-之间的区别"><a href="#设备像素、css像素、设备独⽴像素、dpr、ppi-之间的区别" class="headerlink" title="设备像素、css像素、设备独⽴像素、dpr、ppi 之间的区别"></a>设备像素、css像素、设备独⽴像素、dpr、ppi 之间的区别</h2><p>在 css 中我们通常使⽤px作为单位，在PC浏览器中 css 的1个像素都是对应着电脑屏幕的1个物理像</p><p>素</p><p>这会造成⼀种错觉，我们会认为 css 中的像素就是设备的物理像素但实际情况却并⾮如此， css 中的像素只是⼀个抽象的单位，在不同的设备或不同的环境中， css</p><p>中的1px所代表的设备物理像素是不同的</p><p>当我们做移动端开发时，同为1px的设置，在不同分辨率的移动设备上显⽰效果却有很⼤差异</p><p>这背后就涉及了css像素、设备像素、设备独⽴像素、dpr、ppi的概念</p><p>介绍</p><p> <strong>CSS像素</strong></p><p>CSS像素（css pixel, px）: 适⽤于web编程，在 CSS 中以 px 为后缀，是⼀个⻓度单位</p><p>在 CSS 规范中，⻓度单位可以分为两类，绝对单位以及相对单位</p><p>px是⼀个相对单位，相对的是设备像素（device pixel）</p><p>⼀般情况，⻚⾯缩放⽐为1，1个CSS像素等于1个设备独⽴像素</p><p>CSS 像素⼜具有两个⽅⾯的相对性：</p><p>• </p><p>在同⼀个设备上，每1个 CSS 像素所代表的设备像素是可以变化的（⽐如调整屏幕的分辨率）</p><p>• </p><p>在不同的设备之间，每1个 CSS 像素所代表的设备像素是可以变化的（⽐如两个不同型号的⼿机）</p><p>在⻚⾯进⾏缩放操作也会 引起 css 中 px 的变化，假设⻚⾯放⼤⼀倍，原来的 1px 的东西变成 2px，</p><p>在实际宽度不变的情况下1px 变得跟原来的 2px 的⻓度（⻓宽）⼀样了（元素会占据更多的设备像</p><p>素）</p><p>假设原来需要 320px 才能填满的宽度现在只需要 160px</p><p>px会受到下⾯的因素的影响⽽变化：</p><p>• </p><p>每英⼨像素（PPI）</p><p>• </p><p>设备像素⽐（DPR）</p><p> <strong>设备像素</strong></p><p>设备像素（device pixels），⼜称为物理像素</p><p>指设备能控制显⽰的最⼩物理单位，不⼀定是⼀个⼩正⽅形区块，也没有标准的宽⾼，只是⽤于显⽰</p><p>丰富⾊彩的⼀个“点”⽽已</p><p>可以参考公园⾥的景观变⾊彩灯，⼀个彩灯(物理像素)由红、蓝、绿⼩灯组成，三盏⼩灯不同的亮度混</p><p>合出各种⾊彩图⽚ 加载失败</p><p>从屏幕在⼯⼚⽣产出的那天起，它上⾯设备像素点就固定不变了，单位为 pt</p><p> <strong>设备独⽴像素</strong></p><p>设备独⽴像素（Device Independent Pixel）：与设备⽆关的逻辑像素，代表可以通过程序控制使⽤的</p><p>虚拟像素，是⼀个总体概念，包括了CSS像素</p><p>在 javaScript 中可以通过 window.screen.width&#x2F; window.screen.height 查看</p><p>⽐如我们会说“电脑屏幕在 2560x1600分辨率下不适合玩游戏，我们把它调为 1440x900”，这⾥</p><p>的“分辨率”（⾮严谨说法）指的就是设备独⽴像素</p><p>⼀个设备独⽴像素⾥可能包含1个或者多个物理像素点，包含的越多则屏幕看起来越清晰</p><p>⾄于为什么出现设备独⽴像素这种虚拟像素单位概念，下⾯举个例⼦：</p><p>iPhone 3GS 和 iPhone 4&#x2F;4s 的尺⼨都是 3.5 ⼨，但 iPhone 3GS 的分辨率是 320x480，iPhone 4&#x2F;4s</p><p>的分辨率是 640x960</p><p>这意味着，iPhone 3GS 有 320 个物理像素，iPhone 4&#x2F;4s 有 640 个物理像素</p><p>如果我们按照真实的物理像素进⾏布局，⽐如说我们按照 320 物理像素进⾏布局，到了 640 物理像素</p><p>的⼿机上就会有⼀半的空⽩，为了避免这种问题，就产⽣了虚拟像素单位</p><p>我们统⼀ iPhone 3GS 和 iPhone 4&#x2F;4s 都是 320 个虚拟像素，只是在 iPhone 3GS 上，最终 1 个虚拟像</p><p>素换算成 1 个物理像素，在 iphone 4s 中，1 个虚拟像素最终换算成 2 个物理像素</p><p>⾄于 1 个虚拟像素被换算成⼏个物理像素，这个数值我们称之为设备像素⽐，也就是下⾯介绍的 dpr</p><p><strong>dpr</strong></p><p>dpr（device pixel ratio），设备像素⽐，代表设备独⽴像素到设备像素的转换关系，在</p><p>JavaScript 中可以通过 window.devicePixelRatio 获取</p><p>计算公式如下：图⽚ 加载失败</p><p>当设备像素⽐为1:1时，使⽤1（1×1）个设备像素显⽰1个CSS像素</p><p>当设备像素⽐为2:1时，使⽤4（2×2）个设备像素显⽰1个CSS像素</p><p>当设备像素⽐为3:1时，使⽤9（3×3）个设备像素显⽰1个CSS像素</p><p>如下图所⽰：</p><p>图⽚ 加载失败</p><p>当 dpr 为3，那么 1px 的 CSS 像素宽度对应 3px 的物理像素的宽度，1px的 CSS 像素⾼度对应</p><p>3px 的物理像素⾼度</p><p><strong>ppi</strong></p><p>ppi （pixel per inch），每英⼨像素，表⽰每英⼨所包含的像素点数⽬，更确切的说法应该是像素密</p><p>度。数值越⾼，说明屏幕能以更⾼密度显⽰图像</p><p>计算公式如下：</p><p>图⽚ 加载失败</p><p> <strong>总结</strong></p><p><strong>⽆缩放情况下，1个CSS像素等于1个设备独⽴像素</strong></p><p>设备像素由屏幕⽣产之后就不发⽣改变，⽽设备独⽴像素是⼀个虚拟单位会发⽣改变PC端中，1个设备独⽴像素 &#x3D; 1个设备像素 （在100%，未缩放的情况下）</p><p><strong>在移动端中，标准屏幕（160ppi）下 1个设备独⽴像素 &#x3D; 1个设备像素</strong></p><p><strong>设备像素⽐（dpr） &#x3D; 设备像素 &#x2F; 设备独⽴像素</strong></p><p><strong>每英⼨像素（ppi），值越⼤，图像越清晰</strong></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现两栏布局 右侧⾃适应 三栏布局中间⾃适应</title>
      <link href="/2025/08/08/css/%E5%AE%9E%E7%8E%B0%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%20%E5%8F%B3%E4%BE%A7%E2%BE%83%E9%80%82%E5%BA%94%20%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E4%B8%AD%E9%97%B4%E2%BE%83%E9%80%82%E5%BA%94/"/>
      <url>/2025/08/08/css/%E5%AE%9E%E7%8E%B0%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%20%E5%8F%B3%E4%BE%A7%E2%BE%83%E9%80%82%E5%BA%94%20%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E4%B8%AD%E9%97%B4%E2%BE%83%E9%80%82%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h2 id="实现两栏布局-右侧⾃适应-三栏布局中间⾃适应"><a href="#实现两栏布局-右侧⾃适应-三栏布局中间⾃适应" class="headerlink" title="实现两栏布局 右侧⾃适应 三栏布局中间⾃适应"></a>实现两栏布局 右侧⾃适应 三栏布局中间⾃适应</h2><h3 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h3><p>两栏布局实现效果就是将<strong>⻚⾯分割成左右宽度不等的两列，宽度较⼩的列设置为固定宽度，剩余宽度</strong></p><p><strong>由另⼀列撑满</strong>，</p><p>⽐如 Ant Design ⽂档，蓝⾊区域为主要内容布局容器，侧边栏为次要内容布局容器</p><p>这⾥称宽度较⼩的列⽗元素为次要布局容器，宽度较⼤的列⽗元素为主要布局容器</p><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251207200831390.png" alt="image-20251207200831325"></p><p><strong>flex弹性布局</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">&lt;div class=&quot;left&quot;&gt;左边&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;right&quot;&gt;右边&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><p>三栏布局按照左中右的顺序进⾏排列，通常中间列最宽，左右两列次之</p><p>⼤家最常⻅的就是 github</p><p><strong>. 使⽤flex实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.wrap &#123;</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line">.left,</span><br><span class="line">.right,</span><br><span class="line">.middle &#123;</span><br><span class="line">height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">width: 200px;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">background: coral;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">width: 120px;</span><br><span class="line">background: lightblue;</span><br><span class="line">&#125;</span><br><span class="line">.middle &#123;</span><br><span class="line">background: #555;</span><br><span class="line">width: 100%;</span><br><span class="line">margin: 0 20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">&lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;middle&quot;&gt;中间&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局和grid布局</title>
      <link href="/2025/08/07/css/flex%E5%B8%83%E5%B1%80%E5%92%8Cgrid%E5%B8%83%E5%B1%80/"/>
      <url>/2025/08/07/css/flex%E5%B8%83%E5%B1%80%E5%92%8Cgrid%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="flex布局和grid布局"><a href="#flex布局和grid布局" class="headerlink" title="flex布局和grid布局"></a>flex布局和grid布局</h2><h3 id="Flex-布局（弹性布局）"><a href="#Flex-布局（弹性布局）" class="headerlink" title="Flex 布局（弹性布局）"></a>Flex 布局（弹性布局）</h3><p>Flex 是<strong>一维布局模型</strong>（仅针对「行」或「列」单一维度），核心解决「行内 &#x2F; 列内元素的空间分配、对齐」问题，适合线性布局（如两栏 &#x2F; 多栏、导航栏、居中对齐等）。</p><ul><li><p>核心特点</p><p>：</p><ol><li>以「主轴（默认水平）+ 交叉轴」为核心，元素沿主轴排列；</li><li>侧重「剩余空间分配」（如 <code>flex:1</code> 自动占满剩余宽度）；</li><li>适配性强，适合响应式线性布局（如两栏、均分列表）。</li></ol></li><li><p><strong>典型场景</strong>：导航栏、两栏 &#x2F; 多栏自适应、元素垂直居中、流式布局。</p></li></ul><h3 id="Grid-布局（网格布局）"><a href="#Grid-布局（网格布局）" class="headerlink" title="Grid 布局（网格布局）"></a>Grid 布局（网格布局）</h3><p>Grid 是<strong>二维布局模型</strong>（同时控制「行 + 列」），核心解决「多行列的网格分区」问题，适合复杂的二维布局（如卡片网格、表单布局、页面整体框架）。</p><ul><li><p>核心特点</p><p>：</p><ol><li>把容器划分为「行 + 列」的网格，元素可占据任意单元格（跨行列）；</li><li>支持精确控制行列尺寸（固定 &#x2F; 比例 &#x2F; 自动），如 <code>grid-template-columns: 100px 1fr 2fr</code>；</li><li>布局更精准，适合复杂二维分区。</li></ol></li><li><p><strong>典型场景</strong>：页面整体框架（头部 &#x2F; 侧边 &#x2F; 主体 &#x2F; 底部）、商品卡片网格、表单多列布局。</p></li></ul><h3 id="核心区别"><a href="#核心区别" class="headerlink" title="核心区别"></a>核心区别</h3><table><thead><tr><th>维度</th><th>Flex 布局</th><th>Grid 布局</th></tr></thead><tbody><tr><td>布局维度</td><td>一维（行 &#x2F; 列二选一）</td><td>二维（行 + 列同时控制）</td></tr><tr><td>设计思路</td><td>「内容驱动」，适配内容</td><td>「容器驱动」，先划网格再填内容</td></tr><tr><td>适用场景</td><td>线性布局（如两栏、导航）</td><td>复杂二维布局（如网格、页面框架）</td></tr></tbody></table><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><ul><li>做「一行 &#x2F; 一列」的线性布局（如两栏自适应）→ 用 Flex，简洁高效；</li><li>做「多行多列」的网格布局（如 3 行 2 列卡片）→ 用 Grid，精准可控。</li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中隐藏⻚⾯元素</title>
      <link href="/2025/08/05/css/css%E4%B8%AD%E9%9A%90%E8%97%8F%E2%BB%9A%E2%BE%AF%E5%85%83%E7%B4%A0/"/>
      <url>/2025/08/05/css/css%E4%B8%AD%E9%9A%90%E8%97%8F%E2%BB%9A%E2%BE%AF%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="css中隐藏⻚⾯元素"><a href="#css中隐藏⻚⾯元素" class="headerlink" title="css中隐藏⻚⾯元素"></a>css中隐藏⻚⾯元素</h2><p>通过 css 实现隐藏元素⽅法有如下：</p><p>• </p><p>display:none</p><p>将元素设置为 display:none 后，元素在⻚⾯上将彻底消失</p><p>元素本⾝占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘</p><p>消失后，⾃⾝绑定的事件不会触发，也不会有过渡效果</p><p>特点：<strong>元素不可⻅</strong>，<strong>不占据空间</strong>，<strong>⽆法响应点击事件</strong></p><p>• </p><p>visibility:hidden</p><p>从⻚⾯上仅仅是隐藏该元素，<strong>DOM结果均会存在，只是当时在⼀个不可⻅的状态</strong>，<strong>不会触发重排</strong>，但</p><p>是会触发重绘</p><p>特点：元素不可⻅，<strong>占据⻚⾯空间</strong>，<strong>⽆法响应点击事件</strong></p><p>• </p><p>opacity:0</p><p>opacity 属性表⽰元素的透明度，将元素的透明度设置为0</p><p>• </p><p>设置height、width模型属性为0</p><p>将元素的 margin ， border ， padding ， height 和 width 等影响元素盒模型的属性设置成</p><p>0，<strong>如果元素内有⼦元素或内容，还应该设置其 overflow:hidden 来隐藏其⼦元素</strong></p><p>特点：元素不可⻅，<strong>不占据⻚⾯空间</strong>，<strong>⽆法响应点击事件</strong></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元素⽔平垂直居中的⽅法</title>
      <link href="/2025/08/05/css/%E5%85%83%E7%B4%A0%E2%BD%94%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
      <url>/2025/08/05/css/%E5%85%83%E7%B4%A0%E2%BD%94%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="元素⽔平垂直居中的⽅法"><a href="#元素⽔平垂直居中的⽅法" class="headerlink" title="元素⽔平垂直居中的⽅法"></a>元素⽔平垂直居中的⽅法</h2><p>实现元素⽔平垂直居中的⽅式：</p><p>• </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.father&#123;</span><br><span class="line">width:500px;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4 height:300px;</span><br><span class="line">5 border:1px solid #0a3b98;</span><br><span class="line">6 position: relative;</span><br><span class="line">7 &#125;</span><br><span class="line">8 .son&#123;</span><br><span class="line">9 width:100px;</span><br><span class="line">10 height:40px;</span><br><span class="line">11 background: #f0a238;</span><br><span class="line">12 position: absolute;</span><br><span class="line">13 top:0;</span><br><span class="line">14 left:0;</span><br><span class="line">15 right:0;</span><br><span class="line">16 bottom:0;</span><br><span class="line">17 margin:auto;</span><br><span class="line">18 &#125;</span><br><span class="line">19 &lt;/style&gt;</span><br><span class="line">20 &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">21 &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;</span><br><span class="line">22 &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>利⽤定位+margin:auto</p><p><strong>⽗级设置为相对定位，⼦级绝对定位</strong> ，并且<strong>四个定位属性top,left,right,bottom的值都设置了0</strong>，那么这时候如果⼦级没有设</p><p>置宽⾼，则会被拉开到和⽗级⼀样宽⾼</p><p>这⾥⼦元素设置了宽⾼，所以宽⾼会按照我们的设置来显⽰，但是实际上⼦级的虚拟占位已经撑满了</p><p>整个⽗级，这时候<strong>再给它⼀个 margin：auto</strong> 它就可以上下左右都居中了</p><p>• </p><p>table布局</p><p>设置<strong>⽗元素为 display:table-cell</strong> ，<strong>⼦元素设置 display: inline-block</strong> 。利⽤</p><p><strong>vertical 和 text-align</strong> 可以让所有的<strong>⾏内块级元素⽔平垂直居中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;style&gt;</span><br><span class="line">2 .father &#123;</span><br><span class="line">3 display: table-cell;</span><br><span class="line">4 width: 200px;</span><br><span class="line">5 height: 200px;</span><br><span class="line">6 background: skyblue;</span><br><span class="line">7 vertical-align: middle;</span><br><span class="line">8 text-align: center;</span><br><span class="line">9 &#125;</span><br><span class="line">10 .son &#123;</span><br><span class="line">11 display: inline-block;</span><br><span class="line">12 width: 100px;</span><br><span class="line">13 height: 100px;</span><br><span class="line">14 background: red;</span><br><span class="line">15 &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">&lt;div class=&quot;son&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>• </p><p>flex布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.father &#123;</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 200px;</span><br><span class="line">background: skyblue;</span><br><span class="line">&#125;</span><br><span class="line">.son &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">background: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">&lt;div class=&quot;son&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这⾥可以简单看看 flex 布局的关键属性作⽤：</p><p><strong>display: flex</strong>时，表⽰该容器内部的元素将按照flex进⾏布局</p><p><strong>align-items: center</strong>表⽰这些元素将相对于本容器⽔平居中</p><p><strong>justify-content: center</strong>也是同样的道理垂直居中</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盒⼦模型</title>
      <link href="/2025/08/02/css/%E7%9B%92%E2%BC%A6%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/08/02/css/%E7%9B%92%E2%BC%A6%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="盒⼦模型"><a href="#盒⼦模型" class="headerlink" title="盒⼦模型"></a>盒⼦模型</h2><p>当对⼀个⽂档进⾏布局（layout）的时候，浏览器的渲染引擎会根据标准之⼀的 CSS 基础框盒模型</p><p>（CSS basic box model），将所有元素表⽰为⼀个个矩形的盒⼦（box）</p><p>⼀个盒⼦由四个部分组成： content 、 padding 、 border 、 margin</p><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251207184335421.png" alt="image-20251207184335339"></p><p>从上图可以看到：</p><p>• </p><p>盒⼦总宽度 &#x3D; width + padding + border + margin;</p><p>• </p><p>盒⼦总⾼度 &#x3D; height + padding + border + margin</p><p>也就是， width&#x2F;height 只是内容⾼度，不包含 padding 和 border 值</p><p>所以上⾯问题中，设置 width 为200px，但由于存在 padding ，但实际上盒⼦的宽度有240px</p><p><strong>IE 怪异盒⼦模型</strong></p><p>• </p><p>盒⼦总宽度 &#x3D; width + margin;</p><p>• </p><p>盒⼦总⾼度 &#x3D; height + margin;</p><p>也就是， width&#x2F;height 包含了 padding 和 border 值</p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>在⻚⾯布局的时候，经常出现以下情况：</p><p>这个元素⾼度怎么没了？</p><p>这两栏布局怎么没法⾃适应？</p><p>这两个元素的间距怎么有点奇怪的样⼦？</p><p>原因是<strong>元素之间相互的影响</strong>，导致了意料之外的情况，这⾥就涉及到 BFC 概念</p><p><strong>BFC （Block Formatting Context）</strong>，即块级格式化上下⽂，它是⻚⾯中的⼀块渲染区域，并且有⼀</p><p>套属于⾃⼰的渲染规则：</p><p>• </p><p>内部的盒⼦会在<strong>垂直⽅向上⼀个接⼀个的放置</strong></p><p>• </p><p>对于同⼀个BFC的俩个相邻的盒⼦的<strong>margin会发⽣重叠</strong>，与⽅向⽆关。</p><p>• </p><p>每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此</p><p>• </p><p>BFC的区域不会与float的元素区域重叠</p><p>• </p><p>计算BFC的⾼度时，浮动⼦元素也参与计算</p><p>• </p><p>BFC就是<strong>⻚⾯上的⼀个隔离的独⽴容器</strong>，容器⾥⾯的⼦元素不会影响到外⾯的元素，反之亦然</p><p>BFC ⽬的是形成⼀个相对于外界完全独⽴的空间，让内部的⼦元素不会影响到外部的元素</p><p>利⽤ BFC 的特性，我们将 BFC 应⽤在以下场景：</p><p><strong>防⽌margin重叠（塌陷）</strong></p><p>可以在 p 外⾯包裹⼀层容器，并<strong>触发这个容器⽣成⼀个 BFC</strong> ，那么<strong>两个 p 就不属于同⼀个 BFC</strong> ，</p><p>则不会出现 margin 重叠</p><p><strong>清除内部浮动</strong></p><p><strong>⾃适应多栏布局</strong></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理（Dynamic Proxy）</title>
      <link href="/2025/07/10/java%E5%9F%BA%E7%A1%80/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88Dynamic%20Proxy%EF%BC%89/"/>
      <url>/2025/07/10/java%E5%9F%BA%E7%A1%80/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88Dynamic%20Proxy%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-动态代理（Dynamic-Proxy）"><a href="#Java-动态代理（Dynamic-Proxy）" class="headerlink" title="Java 动态代理（Dynamic Proxy）"></a>Java 动态代理（Dynamic Proxy）</h1><h2 id="一、什么是动态代理"><a href="#一、什么是动态代理" class="headerlink" title="一、什么是动态代理"></a>一、什么是动态代理</h2><p>Java 动态代理是一种在运行时创建代理类并处理方法调用的机制，它不需要事先写好代理类，而是通过反射 API 动态生成代理对象。</p><p>它常用于以下场景：</p><ul><li>日志记录</li><li>权限控制</li><li>性能监控</li><li>Spring AOP 实现原理</li></ul><hr><h2 id="二、JDK-动态代理原理"><a href="#二、JDK-动态代理原理" class="headerlink" title="二、JDK 动态代理原理"></a>二、JDK 动态代理原理</h2><p>JDK 动态代理主要依赖两个核心类&#x2F;接口：</p><ul><li><code>java.lang.reflect.Proxy</code></li><li><code>java.lang.reflect.InvocationHandler</code></li></ul><p>JDK 动态代理要求被代理的类 <strong>必须实现接口</strong>。</p><hr><h2 id="三、使用步骤"><a href="#三、使用步骤" class="headerlink" title="三、使用步骤"></a>三、使用步骤</h2><h3 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1. 定义接口"></a>1. 定义接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑public interface UserService &#123;</span><br><span class="line">    void login(String username);</span><br><span class="line">    void logout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-实现该接口的类（目标类）"><a href="#2-实现该接口的类（目标类）" class="headerlink" title="2. 实现该接口的类（目标类）"></a>2. 实现该接口的类（目标类）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void login(String username) &#123;</span><br><span class="line">        System.out.println(username + &quot; 登录了系统&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void logout() &#123;</span><br><span class="line">        System.out.println(&quot;用户退出系统&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-实现-InvocationHandler-接口"><a href="#3-实现-InvocationHandler-接口" class="headerlink" title="3. 实现 InvocationHandler 接口"></a>3. 实现 InvocationHandler 接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class LogHandler implements InvocationHandler &#123;</span><br><span class="line">    private final Object target;</span><br><span class="line"></span><br><span class="line">    public LogHandler(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;[日志] 调用方法：&quot; + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args); // 反射调用目标方法</span><br><span class="line">        System.out.println(&quot;[日志] 方法调用结束：&quot; + method.getName());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-生成代理对象并调用方法"><a href="#4-生成代理对象并调用方法" class="headerlink" title="4. 生成代理对象并调用方法"></a>4. 生成代理对象并调用方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService target = new UserServiceImpl();</span><br><span class="line">        InvocationHandler handler = new LogHandler(target);</span><br><span class="line"></span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(), // 必须是接口类型</span><br><span class="line">            handler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        proxy.login(&quot;张三&quot;);</span><br><span class="line">        proxy.logout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、运行结果"><a href="#四、运行结果" class="headerlink" title="四、运行结果"></a>四、运行结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">css复制编辑[日志] 调用方法：login</span><br><span class="line">张三 登录了系统</span><br><span class="line">[日志] 方法调用结束：login</span><br><span class="line">[日志] 调用方法：logout</span><br><span class="line">用户退出系统</span><br><span class="line">[日志] 方法调用结束：logout</span><br></pre></td></tr></table></figure><hr><h2 id="五、JDK-动态代理的限制"><a href="#五、JDK-动态代理的限制" class="headerlink" title="五、JDK 动态代理的限制"></a>五、JDK 动态代理的限制</h2><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>灵活，无需编写代理类</td><td>只能代理接口，不能代理类</td></tr><tr><td>支持运行时增强行为</td><td>运行时使用反射，性能略下降</td></tr><tr><td>应用于 AOP、RPC、事务等场景</td><td></td></tr></tbody></table><hr><h2 id="六、CGLIB-动态代理（补充）"><a href="#六、CGLIB-动态代理（补充）" class="headerlink" title="六、CGLIB 动态代理（补充）"></a>六、CGLIB 动态代理（补充）</h2><p>如果目标类没有接口，可以使用 CGLIB，它基于继承生成代理类。Spring 在默认配置下也使用它来代理非接口类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑Enhancer enhancer = new Enhancer();</span><br><span class="line">enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;[CGLIB日志] 调用方法：&quot; + method.getName());</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(&quot;[CGLIB日志] 方法调用结束：&quot; + method.getName());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">UserServiceImpl proxy = (UserServiceImpl) enhancer.create();</span><br><span class="line">proxy.login(&quot;李四&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>CGLIB 需要额外依赖库（如 <code>cglib-nodep</code>）</p></blockquote><hr><h2 id="七、动态代理的应用场景总结"><a href="#七、动态代理的应用场景总结" class="headerlink" title="七、动态代理的应用场景总结"></a>七、动态代理的应用场景总结</h2><ul><li>AOP（面向切面编程）</li><li>日志拦截器</li><li>安全控制</li><li>缓存管理</li><li>RPC 调用封装</li><li>数据库事务处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射机制（Reflection）</title>
      <link href="/2025/07/09/java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%88Reflection%EF%BC%89/"/>
      <url>/2025/07/09/java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%88Reflection%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-反射机制（Reflection）"><a href="#Java-反射机制（Reflection）" class="headerlink" title="Java 反射机制（Reflection）"></a>Java 反射机制（Reflection）</h1><h2 id="一、什么是反射"><a href="#一、什么是反射" class="headerlink" title="一、什么是反射"></a>一、什么是反射</h2><p><strong>反射（Reflection）</strong> 是 Java 提供的一种机制，它允许程序在运行时动态获取类的信息（方法、属性、构造方法等）以及操作对象本身。</p><p>通过反射可以：</p><ul><li>在运行时获取类的完整结构</li><li>动态创建对象</li><li>动态调用方法、访问字段</li><li>实现解耦、插件式开发、框架封装等</li></ul><p>反射是实现诸如 <strong>Spring、MyBatis、Junit、Tomcat、IDEA 插件系统</strong> 的核心技术之一。</p><hr><h2 id="二、反射的核心类"><a href="#二、反射的核心类" class="headerlink" title="二、反射的核心类"></a>二、反射的核心类</h2><p>反射主要在 <code>java.lang.reflect</code> 和 <code>java.lang.Class</code> 包中，主要类包括：</p><table><thead><tr><th>类&#x2F;接口</th><th>功能说明</th></tr></thead><tbody><tr><td><code>Class&lt;?&gt;</code></td><td>表示类或接口的字节码对象</td></tr><tr><td><code>Field</code></td><td>表示类中的成员变量</td></tr><tr><td><code>Method</code></td><td>表示类中的方法</td></tr><tr><td><code>Constructor</code></td><td>表示类的构造方法</td></tr><tr><td><code>Modifier</code></td><td>表示修饰符工具类</td></tr></tbody></table><hr><h2 id="三、反射的基本操作"><a href="#三、反射的基本操作" class="headerlink" title="三、反射的基本操作"></a>三、反射的基本操作</h2><h3 id="1-获取类的-Class-对象（3种方式）"><a href="#1-获取类的-Class-对象（3种方式）" class="headerlink" title="1. 获取类的 Class 对象（3种方式）"></a>1. 获取类的 Class 对象（3种方式）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑// 方式一：通过类名.class</span><br><span class="line">Class&lt;?&gt; clazz1 = String.class;</span><br><span class="line"></span><br><span class="line">// 方式二：通过对象的 getClass()</span><br><span class="line">String s = &quot;hello&quot;;</span><br><span class="line">Class&lt;?&gt; clazz2 = s.getClass();</span><br><span class="line"></span><br><span class="line">// 方式三：通过 Class.forName()</span><br><span class="line">Class&lt;?&gt; clazz3 = Class.forName(&quot;java.lang.String&quot;);</span><br></pre></td></tr></table></figure><h3 id="2-创建对象"><a href="#2-创建对象" class="headerlink" title="2. 创建对象"></a>2. 创建对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line"></span><br><span class="line">// 调用无参构造方法</span><br><span class="line">Object obj = clazz.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure><h3 id="3-获取并调用构造方法"><a href="#3-获取并调用构造方法" class="headerlink" title="3. 获取并调用构造方法"></a>3. 获取并调用构造方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class);</span><br><span class="line">Object strObj = constructor.newInstance(&quot;Hello&quot;);</span><br><span class="line">System.out.println(strObj); // 输出 Hello</span><br></pre></td></tr></table></figure><h3 id="4-获取方法并调用"><a href="#4-获取方法并调用" class="headerlink" title="4. 获取方法并调用"></a>4. 获取方法并调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑Method method = clazz.getMethod(&quot;length&quot;);</span><br><span class="line">int length = (int) method.invoke(&quot;Reflection&quot;);</span><br><span class="line">System.out.println(length); // 输出 10</span><br></pre></td></tr></table></figure><h3 id="5-获取成员变量并访问"><a href="#5-获取成员变量并访问" class="headerlink" title="5. 获取成员变量并访问"></a>5. 获取成员变量并访问</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑public class Person &#123;</span><br><span class="line">    private String name = &quot;张三&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; clazz = Person.class;</span><br><span class="line">Object person = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">Field field = clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">field.setAccessible(true); // 打破 private 限制</span><br><span class="line">Object value = field.get(person);</span><br><span class="line">System.out.println(value); // 输出 张三</span><br></pre></td></tr></table></figure><hr><h2 id="四、完整示例"><a href="#四、完整示例" class="headerlink" title="四、完整示例"></a>四、完整示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">        this.name = &quot;默认姓名&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(String msg) &#123;</span><br><span class="line">        System.out.println(name + &quot; 说：&quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">java复制编辑public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(&quot;Person&quot;);</span><br><span class="line"></span><br><span class="line">        Object obj = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        Field nameField = clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        nameField.setAccessible(true);</span><br><span class="line">        nameField.set(obj, &quot;李四&quot;);</span><br><span class="line"></span><br><span class="line">        Method method = clazz.getMethod(&quot;sayHello&quot;, String.class);</span><br><span class="line">        method.invoke(obj, &quot;你好，反射&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制编辑</span><br><span class="line">李四 说：你好，反射</span><br></pre></td></tr></table></figure><hr><h2 id="五、反射的优缺点"><a href="#五、反射的优缺点" class="headerlink" title="五、反射的优缺点"></a>五、反射的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>灵活：允许在运行时操作对象</li><li>解耦：可用于工厂模式、框架自动装配</li><li>强大：能访问私有成员、动态调用</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>性能较低：反射调用本质是方法分发 + 安全检查</li><li>安全性弱：能访问和修改 private 属性可能导致安全问题</li><li>可读性差：代码不直观，难以调试</li></ul><hr><h2 id="六、反射在实际开发中的应用"><a href="#六、反射在实际开发中的应用" class="headerlink" title="六、反射在实际开发中的应用"></a>六、反射在实际开发中的应用</h2><table><thead><tr><th>应用场景</th><th>示例</th></tr></thead><tbody><tr><td>框架自动注入</td><td>Spring IOC、DI</td></tr><tr><td>AOP 方法增强</td><td>Spring AOP</td></tr><tr><td>JDBC 封装</td><td>MyBatis 动态 SQL 映射</td></tr><tr><td>配置文件驱动类加载</td><td>SPI 插件机制</td></tr><tr><td>单元测试调用私有方法</td><td>JUnit、Mockito</td></tr><tr><td>序列化&#x2F;反序列化</td><td>Jackson、FastJSON</td></tr></tbody></table><hr><h2 id="七、Class-对象详解"><a href="#七、Class-对象详解" class="headerlink" title="七、Class 对象详解"></a>七、Class 对象详解</h2><p>每个 <code>.class</code> 文件在 JVM 中会被加载为唯一的 <code>Class</code> 实例对象，常见用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"></span><br><span class="line">System.out.println(clazz.getName());         // 全类名</span><br><span class="line">System.out.println(clazz.getSimpleName());   // 简类名</span><br><span class="line">System.out.println(clazz.getPackage());      // 包信息</span><br><span class="line">System.out.println(clazz.getSuperclass());   // 父类</span><br><span class="line">System.out.println(clazz.getInterfaces());   // 接口</span><br></pre></td></tr></table></figure><hr><h2 id="八、注意事项"><a href="#八、注意事项" class="headerlink" title="八、注意事项"></a>八、注意事项</h2><ul><li>反射可访问私有成员，但必须显式设置 <code>setAccessible(true)</code></li><li>建议避免在性能敏感场景频繁使用反射</li><li><code>Class.forName()</code> 会触发类的初始化（执行静态代码块）</li><li>Java 9+ 中对反射访问做了封装限制（需打开模块）</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 线程池（Thread Pool）</title>
      <link href="/2025/07/08/java%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88Thread%20Pool%EF%BC%89/"/>
      <url>/2025/07/08/java%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88Thread%20Pool%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-线程池（Thread-Pool）"><a href="#Java-线程池（Thread-Pool）" class="headerlink" title="Java 线程池（Thread Pool）"></a>Java 线程池（Thread Pool）</h1><h2 id="一、什么是线程池"><a href="#一、什么是线程池" class="headerlink" title="一、什么是线程池"></a>一、什么是线程池</h2><p><strong>线程池</strong> 是一种线程管理机制，用于提前创建并复用固定数量的线程，以避免频繁地创建&#x2F;销毁线程带来的资源开销。</p><p>主要优势包括：</p><ul><li>降低资源消耗（复用线程）</li><li>提高响应速度（任务提交后可立即执行）</li><li>方便管理线程（线程数可控，支持超时、拒绝策略等）</li></ul><hr><h2 id="二、线程池的核心类：Executor-和-ThreadPoolExecutor"><a href="#二、线程池的核心类：Executor-和-ThreadPoolExecutor" class="headerlink" title="二、线程池的核心类：Executor 和 ThreadPoolExecutor"></a>二、线程池的核心类：<code>Executor</code> 和 <code>ThreadPoolExecutor</code></h2><p>Java 中的线程池定义在 <code>java.util.concurrent</code> 包下，主要接口和类包括：</p><table><thead><tr><th>接口&#x2F;类名</th><th>说明</th></tr></thead><tbody><tr><td><code>Executor</code></td><td>线程池顶层接口，定义任务执行方法</td></tr><tr><td><code>ExecutorService</code></td><td>扩展接口，支持任务返回值、关闭池</td></tr><tr><td><code>ThreadPoolExecutor</code></td><td>线程池的核心实现类</td></tr><tr><td><code>Executors</code></td><td>工厂类，用于创建常见线程池</td></tr><tr><td><code>Future</code></td><td>代表异步任务结果</td></tr></tbody></table><hr><h2 id="三、使用线程池的三种方式"><a href="#三、使用线程池的三种方式" class="headerlink" title="三、使用线程池的三种方式"></a>三、使用线程池的三种方式</h2><h3 id="1-使用-Executors-工厂类（不推荐用于生产）"><a href="#1-使用-Executors-工厂类（不推荐用于生产）" class="headerlink" title="1. 使用 Executors 工厂类（不推荐用于生产）"></a>1. 使用 <code>Executors</code> 工厂类（不推荐用于生产）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑ExecutorService pool = Executors.newFixedThreadPool(5);</span><br><span class="line"></span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; 执行任务&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure><p><code>Executors</code> 提供的几种线程池：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>newFixedThreadPool(n)</code></td><td>固定大小线程池</td></tr><tr><td><code>newCachedThreadPool()</code></td><td>可自动扩容线程池（适合短任务）</td></tr><tr><td><code>newSingleThreadExecutor()</code></td><td>单线程池</td></tr><tr><td><code>newScheduledThreadPool(n)</code></td><td>定时&#x2F;周期性任务线程池</td></tr></tbody></table><blockquote><p>说明：<code>Executors</code> 默认使用 <strong>无界队列</strong>（如 LinkedBlockingQueue），在任务过多时容易导致内存溢出。<strong>推荐手动使用 ThreadPoolExecutor</strong>。</p></blockquote><hr><h3 id="2-手动创建-ThreadPoolExecutor（推荐）"><a href="#2-手动创建-ThreadPoolExecutor（推荐）" class="headerlink" title="2. 手动创建 ThreadPoolExecutor（推荐）"></a>2. 手动创建 <code>ThreadPoolExecutor</code>（推荐）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑ExecutorService pool = new ThreadPoolExecutor(</span><br><span class="line">    2,                      // corePoolSize 核心线程数</span><br><span class="line">    5,                      // maximumPoolSize 最大线程数</span><br><span class="line">    60L,                    // keepAliveTime 空闲线程最大存活时间</span><br><span class="line">    TimeUnit.SECONDS,       // 时间单位</span><br><span class="line">    new ArrayBlockingQueue&lt;&gt;(10), // 等待队列（有界）</span><br><span class="line">    Executors.defaultThreadFactory(), // 线程工厂</span><br><span class="line">    new ThreadPoolExecutor.AbortPolicy() // 拒绝策略</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h2 id="四、线程池任务执行流程"><a href="#四、线程池任务执行流程" class="headerlink" title="四、线程池任务执行流程"></a>四、线程池任务执行流程</h2><ol><li>任务提交给线程池</li><li>如果线程数 &lt; corePoolSize，创建新线程执行任务</li><li>如果线程数 ≥ corePoolSize，任务放入队列等待</li><li>如果队列已满且线程数 &lt; maximumPoolSize，创建新线程执行任务</li><li>如果队列已满且线程数达到最大，触发<strong>拒绝策略</strong></li></ol><hr><h2 id="五、拒绝策略（RejectedExecutionHandler）"><a href="#五、拒绝策略（RejectedExecutionHandler）" class="headerlink" title="五、拒绝策略（RejectedExecutionHandler）"></a>五、拒绝策略（RejectedExecutionHandler）</h2><p>当线程池和队列都满了时，线程池会调用 <strong>拒绝策略</strong>：</p><table><thead><tr><th>策略类</th><th>描述</th></tr></thead><tbody><tr><td><code>AbortPolicy</code>（默认）</td><td>抛出 <code>RejectedExecutionException</code></td></tr><tr><td><code>CallerRunsPolicy</code></td><td>由提交任务的线程（主线程）执行该任务</td></tr><tr><td><code>DiscardPolicy</code></td><td>直接丢弃任务</td></tr><tr><td><code>DiscardOldestPolicy</code></td><td>丢弃队列中最早的任务，尝试执行当前任务</td></tr></tbody></table><hr><h2 id="六、线程池常用方法"><a href="#六、线程池常用方法" class="headerlink" title="六、线程池常用方法"></a>六、线程池常用方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑Future&lt;String&gt; future = pool.submit(() -&gt; &#123;</span><br><span class="line">    return &quot;任务执行结果&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(future.get()); // 获取返回值（阻塞）</span><br><span class="line">java复制编辑pool.shutdown();           // 平滑关闭线程池</span><br><span class="line">pool.shutdownNow();        // 立即关闭线程池（中断正在执行的线程）</span><br></pre></td></tr></table></figure><hr><h2 id="七、线程池参数调优建议"><a href="#七、线程池参数调优建议" class="headerlink" title="七、线程池参数调优建议"></a>七、线程池参数调优建议</h2><table><thead><tr><th>参数</th><th>调优建议</th></tr></thead><tbody><tr><td>corePoolSize</td><td>根据 CPU 核数和任务类型（I&#x2F;O密集 or 计算密集）</td></tr><tr><td>maximumPoolSize</td><td>通常是 core 数的 1.5 ~ 2 倍</td></tr><tr><td>队列类型</td><td>推荐使用有界队列（如 ArrayBlockingQueue）</td></tr><tr><td>拒绝策略</td><td>根据业务场景选择（如降级、记录日志）</td></tr><tr><td>keepAliveTime</td><td>非核心线程空闲存活时间</td></tr></tbody></table><hr><h2 id="八、实际开发中的应用场景"><a href="#八、实际开发中的应用场景" class="headerlink" title="八、实际开发中的应用场景"></a>八、实际开发中的应用场景</h2><ul><li>Web 服务器处理请求（如 Tomcat 使用线程池处理 Servlet 请求）</li><li>数据库连接池底层使用线程池管理连接</li><li>消息处理系统（异步处理消息队列中的任务）</li><li>定时任务调度（使用 <code>ScheduledExecutorService</code>）</li></ul><hr><h2 id="九、示例：批量执行任务并收集返回值"><a href="#九、示例：批量执行任务并收集返回值" class="headerlink" title="九、示例：批量执行任务并收集返回值"></a>九、示例：批量执行任务并收集返回值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑ExecutorService pool = Executors.newFixedThreadPool(3);</span><br><span class="line"></span><br><span class="line">List&lt;Future&lt;Integer&gt;&gt; futures = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    int num = i;</span><br><span class="line">    futures.add(pool.submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        return num * num;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (Future&lt;Integer&gt; f : futures) &#123;</span><br><span class="line">    System.out.println(&quot;结果：&quot; + f.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure><hr><h2 id="十、补充：线程池监控与可视化"><a href="#十、补充：线程池监控与可视化" class="headerlink" title="十、补充：线程池监控与可视化"></a>十、补充：线程池监控与可视化</h2><p>可以通过以下方式监控线程池运行状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑ThreadPoolExecutor pool = (ThreadPoolExecutor) Executors.newFixedThreadPool(3);</span><br><span class="line"></span><br><span class="line">System.out.println(pool.getPoolSize());         // 当前线程池大小</span><br><span class="line">System.out.println(pool.getActiveCount());      // 活跃线程数</span><br><span class="line">System.out.println(pool.getQueue().size());     // 队列长度</span><br><span class="line">System.out.println(pool.getCompletedTaskCount());// 完成任务数</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O流与I/O框架</title>
      <link href="/2025/07/07/java%E5%9F%BA%E7%A1%80/IO%E6%B5%81%E4%B8%8EIO%E6%A1%86%E6%9E%B6/"/>
      <url>/2025/07/07/java%E5%9F%BA%E7%A1%80/IO%E6%B5%81%E4%B8%8EIO%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="I-O流与I-O框架全面总结"><a href="#I-O流与I-O框架全面总结" class="headerlink" title="I&#x2F;O流与I&#x2F;O框架全面总结"></a>I&#x2F;O流与I&#x2F;O框架全面总结</h1><h2 id="一、Java-I-O流基础"><a href="#一、Java-I-O流基础" class="headerlink" title="一、Java I&#x2F;O流基础"></a>一、Java I&#x2F;O流基础</h2><h3 id="1-I-O流分类"><a href="#1-I-O流分类" class="headerlink" title="1. I&#x2F;O流分类"></a>1. I&#x2F;O流分类</h3><h4 id="按数据流向"><a href="#按数据流向" class="headerlink" title="按数据流向"></a>按数据流向</h4><ul><li><strong>输入流</strong>：从数据源读取数据（InputStream&#x2F;Reader）</li><li><strong>输出流</strong>：向目标写入数据（OutputStream&#x2F;Writer）</li></ul><h4 id="按数据类型"><a href="#按数据类型" class="headerlink" title="按数据类型"></a>按数据类型</h4><ul><li><strong>字节流</strong>：以字节为单位（8位），处理二进制数据<ul><li>InputStream&#x2F;OutputStream</li></ul></li><li><strong>字符流</strong>：以字符为单位（16位），处理文本数据<ul><li>Reader&#x2F;Writer</li></ul></li></ul><h4 id="按功能"><a href="#按功能" class="headerlink" title="按功能"></a>按功能</h4><ul><li><strong>节点流</strong>：直接操作数据源&#x2F;目标的流</li><li><strong>处理流</strong>：对现有流进行包装，提供增强功能</li></ul><h3 id="2-核心类体系"><a href="#2-核心类体系" class="headerlink" title="2. 核心类体系"></a>2. 核心类体系</h3><h4 id="字节流体系"><a href="#字节流体系" class="headerlink" title="字节流体系"></a>字节流体系</h4><p>text</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">InputStream (抽象类)</span><br><span class="line">├─ FileInputStream (文件输入)</span><br><span class="line">├─ ByteArrayInputStream (内存数组输入)</span><br><span class="line">├─ FilterInputStream (装饰器父类)</span><br><span class="line">│  ├─ BufferedInputStream (缓冲流)</span><br><span class="line">│  ├─ DataInputStream (基本数据类型读取)</span><br><span class="line">└─ ObjectInputStream (对象反序列化)</span><br><span class="line"></span><br><span class="line">OutputStream (抽象类)</span><br><span class="line">├─ FileOutputStream (文件输出)</span><br><span class="line">├─ ByteArrayOutputStream (内存数组输出)</span><br><span class="line">├─ FilterOutputStream (装饰器父类)</span><br><span class="line">│  ├─ BufferedOutputStream (缓冲流)</span><br><span class="line">│  ├─ DataOutputStream (基本数据类型写入)</span><br><span class="line">└─ ObjectOutputStream (对象序列化)</span><br></pre></td></tr></table></figure><h4 id="字符流体系"><a href="#字符流体系" class="headerlink" title="字符流体系"></a>字符流体系</h4><p>text</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Reader (抽象类)</span><br><span class="line">├─ InputStreamReader (字节到字符桥接)</span><br><span class="line">│  └─ FileReader (文件字符输入)</span><br><span class="line">├─ BufferedReader (缓冲字符输入)</span><br><span class="line">├─ CharArrayReader (字符数组输入)</span><br><span class="line">└─ StringReader (字符串输入)</span><br><span class="line"></span><br><span class="line">Writer (抽象类)</span><br><span class="line">├─ OutputStreamWriter (字符到字节桥接)</span><br><span class="line">│  └─ FileWriter (文件字符输出)</span><br><span class="line">├─ BufferedWriter (缓冲字符输出)</span><br><span class="line">├─ CharArrayWriter (字符数组输出)</span><br><span class="line">└─ StringWriter (字符串输出)</span><br></pre></td></tr></table></figure><h2 id="二、常用I-O流详解"><a href="#二、常用I-O流详解" class="headerlink" title="二、常用I&#x2F;O流详解"></a>二、常用I&#x2F;O流详解</h2><h3 id="1-文件操作流"><a href="#1-文件操作流" class="headerlink" title="1. 文件操作流"></a>1. 文件操作流</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 字节流文件复制</span><br><span class="line">try (FileInputStream fis = new FileInputStream(&quot;source.txt&quot;);</span><br><span class="line">     FileOutputStream fos = new FileOutputStream(&quot;target.txt&quot;)) &#123;</span><br><span class="line">    byte[] buffer = new byte[1024];</span><br><span class="line">    int len;</span><br><span class="line">    while ((len = fis.read(buffer)) != -1) &#123;</span><br><span class="line">        fos.write(buffer, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 字符流文件读取</span><br><span class="line">try (BufferedReader br = new BufferedReader(new FileReader(&quot;file.txt&quot;))) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    while ((line = br.readLine()) != null) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-缓冲流（提升性能）"><a href="#2-缓冲流（提升性能）" class="headerlink" title="2. 缓冲流（提升性能）"></a>2. 缓冲流（提升性能）</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用缓冲流提升复制效率</span><br><span class="line">try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;source.jpg&quot;));</span><br><span class="line">     BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;target.jpg&quot;))) &#123;</span><br><span class="line">    byte[] buffer = new byte[8192];  // 8KB缓冲区</span><br><span class="line">    int len;</span><br><span class="line">    while ((len = bis.read(buffer)) != -1) &#123;</span><br><span class="line">        bos.write(buffer, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-对象序列化流"><a href="#3-对象序列化流" class="headerlink" title="3. 对象序列化流"></a>3. 对象序列化流</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 对象序列化</span><br><span class="line">class Person implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private transient int age;  // transient修饰的字段不会被序列化</span><br><span class="line">    </span><br><span class="line">    // 构造方法、getter/setter...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 序列化对象到文件</span><br><span class="line">try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.dat&quot;))) &#123;</span><br><span class="line">    oos.writeObject(new Person(&quot;张三&quot;, 25));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 反序列化</span><br><span class="line">try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;person.dat&quot;))) &#123;</span><br><span class="line">    Person p = (Person) ois.readObject();</span><br><span class="line">    System.out.println(p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、NIO（New-I-O）"><a href="#三、NIO（New-I-O）" class="headerlink" title="三、NIO（New I&#x2F;O）"></a>三、NIO（New I&#x2F;O）</h2><h3 id="1-NIO核心组件"><a href="#1-NIO核心组件" class="headerlink" title="1. NIO核心组件"></a>1. NIO核心组件</h3><ul><li><strong>Channel</strong>：双向数据传输通道<ul><li>FileChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul></li><li><strong>Buffer</strong>：数据容器<ul><li>ByteBuffer</li><li>CharBuffer</li><li>IntBuffer</li></ul></li><li><strong>Selector</strong>：多路复用器</li></ul><h3 id="2-NIO示例"><a href="#2-NIO示例" class="headerlink" title="2. NIO示例"></a>2. NIO示例</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 使用FileChannel复制文件</span><br><span class="line">try (FileChannel src = FileChannel.open(Paths.get(&quot;source.txt&quot;), StandardOpenOption.READ);</span><br><span class="line">     FileChannel dest = FileChannel.open(Paths.get(&quot;target.txt&quot;), </span><br><span class="line">          StandardOpenOption.WRITE, StandardOpenOption.CREATE)) &#123;</span><br><span class="line">    src.transferTo(0, src.size(), dest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用Buffer读写</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">try (FileChannel channel = FileChannel.open(Paths.get(&quot;data.txt&quot;), StandardOpenOption.READ)) &#123;</span><br><span class="line">    while (channel.read(buffer) &gt; 0) &#123;</span><br><span class="line">        buffer.flip();  // 切换为读模式</span><br><span class="line">        while (buffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.print((char) buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.clear();  // 清空缓冲区，准备再次写入</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、常用I-O框架"><a href="#四、常用I-O框架" class="headerlink" title="四、常用I&#x2F;O框架"></a>四、常用I&#x2F;O框架</h2><h3 id="1-Apache-Commons-IO"><a href="#1-Apache-Commons-IO" class="headerlink" title="1. Apache Commons IO"></a>1. Apache Commons IO</h3><p><strong>核心功能</strong>：</p><ul><li>FileUtils：文件操作工具类</li><li>IOUtils：流操作工具类</li><li>FilenameUtils：文件名处理工具</li></ul><p><strong>示例代码</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 复制文件</span><br><span class="line">File srcFile = new File(&quot;source.txt&quot;);</span><br><span class="line">File destFile = new File(&quot;target.txt&quot;);</span><br><span class="line">FileUtils.copyFile(srcFile, destFile);</span><br><span class="line"></span><br><span class="line">// 读取文件内容为字符串</span><br><span class="line">String content = FileUtils.readFileToString(new File(&quot;data.txt&quot;), &quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">// 逐行读取</span><br><span class="line">List&lt;String&gt; lines = FileUtils.readLines(new File(&quot;log.txt&quot;), &quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure><h3 id="2-Google-Guava"><a href="#2-Google-Guava" class="headerlink" title="2. Google Guava"></a>2. Google Guava</h3><p><strong>核心功能</strong>：</p><ul><li>Files：文件操作工具</li><li>CharStreams&#x2F;ByteStreams：流工具</li><li>Resources：资源读取工具</li></ul><p><strong>示例代码</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 读取文件所有行</span><br><span class="line">List&lt;String&gt; lines = Files.readLines(new File(&quot;data.txt&quot;), Charsets.UTF_8);</span><br><span class="line"></span><br><span class="line">// 复制文件</span><br><span class="line">File src = new File(&quot;source.jpg&quot;);</span><br><span class="line">File dest = new File(&quot;target.jpg&quot;);</span><br><span class="line">Files.copy(src, dest);</span><br><span class="line"></span><br><span class="line">// 读取资源文件</span><br><span class="line">URL url = Resources.getResource(&quot;config.properties&quot;);</span><br><span class="line">String text = Resources.toString(url, Charsets.UTF_8);</span><br></pre></td></tr></table></figure><h3 id="3-Java-7-Files工具类"><a href="#3-Java-7-Files工具类" class="headerlink" title="3. Java 7+ Files工具类"></a>3. Java 7+ Files工具类</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 读取所有行</span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(Paths.get(&quot;data.txt&quot;));</span><br><span class="line"></span><br><span class="line">// 写入文件</span><br><span class="line">Files.write(Paths.get(&quot;output.txt&quot;), &quot;Hello World&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">// 复制文件</span><br><span class="line">Files.copy(Paths.get(&quot;source.txt&quot;), Paths.get(&quot;target.txt&quot;));</span><br><span class="line"></span><br><span class="line">// 遍历目录</span><br><span class="line">Files.walk(Paths.get(&quot;/path/to/dir&quot;))</span><br><span class="line">     .filter(Files::isRegularFile)</span><br><span class="line">     .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="五、性能优化建议"><a href="#五、性能优化建议" class="headerlink" title="五、性能优化建议"></a>五、性能优化建议</h2><ol><li><strong>使用缓冲流</strong>：减少物理I&#x2F;O操作次数</li><li><strong>合理设置缓冲区大小</strong>：通常8KB-32KB为宜</li><li><strong>及时关闭资源</strong>：使用try-with-resources</li><li><strong>NIO处理大文件</strong>：对于大文件操作，NIO性能更优</li><li><strong>选择合适流类型</strong>：文本数据用字符流，二进制数据用字节流</li><li><strong>批量操作</strong>：尽量批量读写而非单字节&#x2F;字符操作</li></ol><h2 id="六、常见应用场景"><a href="#六、常见应用场景" class="headerlink" title="六、常见应用场景"></a>六、常见应用场景</h2><ol><li><strong>文件操作</strong>：读写、复制、移动、删除</li><li><strong>网络通信</strong>：Socket数据传输</li><li><strong>数据持久化</strong>：对象序列化&#x2F;反序列化</li><li><strong>日志处理</strong>：日志文件读写</li><li><strong>配置文件</strong>：properties&#x2F;xml&#x2F;json等配置读取</li><li><strong>资源加载</strong>：类路径资源读取</li></ol><p>掌握这些I&#x2F;O流和框架的知识点，可以显著提升程序性能和开发效率</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常和泛型</title>
      <link href="/2025/07/06/java%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8%E5%92%8C%E6%B3%9B%E5%9E%8B/"/>
      <url>/2025/07/06/java%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8%E5%92%8C%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="异常和泛型知识点总结"><a href="#异常和泛型知识点总结" class="headerlink" title="异常和泛型知识点总结"></a>异常和泛型知识点总结</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h3><ul><li>异常是程序运行时发生的不正常情况，会中断正常的指令流</li><li>Java中所有异常都继承自<code>Throwable</code>类，分为<code>Error</code>和<code>Exception</code>两大类</li></ul><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><ol><li><strong>Error</strong>：严重错误，程序无法处理（如内存溢出）</li><li><strong>Exception</strong>：<ul><li>检查异常（Checked Exception）：必须处理（如IOException）</li><li>非检查异常（Unchecked Exception&#x2F;RuntimeException）：可选择性处理（如NullPointerException）</li></ul></li></ol><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><ol><li><p><strong>try-catch-finally</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 可能抛出异常的代码</span><br><span class="line">&#125; catch (ExceptionType1 e) &#123;</span><br><span class="line">    // 处理特定异常</span><br><span class="line">&#125; catch (ExceptionType2 e) &#123;</span><br><span class="line">    // 处理另一种异常</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 无论是否发生异常都会执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>throws</strong>：声明方法可能抛出的异常</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void method() throws IOException &#123;</span><br><span class="line">    // 方法代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>throw</strong>：主动抛出异常</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new Exception(&quot;错误信息&quot;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul><li>继承Exception或RuntimeException创建自定义异常类</li><li>通常提供构造方法传递错误信息</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型概念"><a href="#泛型概念" class="headerlink" title="泛型概念"></a>泛型概念</h3><ul><li>参数化类型，将类型作为参数</li><li>提高代码复用性和类型安全性</li></ul><h3 id="泛型使用"><a href="#泛型使用" class="headerlink" title="泛型使用"></a>泛型使用</h3><ol><li><p><strong>泛型类</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">    private T t;</span><br><span class="line">    public void set(T t) &#123; this.t = t; &#125;</span><br><span class="line">    public T get() &#123; return t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>泛型方法</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; void printArray(T[] array) &#123;</span><br><span class="line">    for (T element : array) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>泛型接口</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><ol><li><strong>无界通配符</strong>：<code>&lt;?&gt;</code> 表示未知类型</li><li><strong>上界通配符</strong>：<code>&lt;? extends T&gt;</code> 表示T或T的子类</li><li><strong>下界通配符</strong>：<code>&lt;? super T&gt;</code> 表示T或T的父类</li></ol><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><ul><li>Java泛型在编译时进行类型检查，运行时擦除类型信息</li><li>编译器在必要时插入类型转换代码</li></ul><h3 id="泛型限制"><a href="#泛型限制" class="headerlink" title="泛型限制"></a>泛型限制</h3><ul><li>不能使用基本类型作为类型参数</li><li>不能创建泛型数组</li><li>不能实例化类型参数</li><li>不能使用instanceof检查泛型类型</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名内部类与Lambda表达式</title>
      <link href="/2025/07/05/java%E5%9F%BA%E7%A1%80/Stream%E6%B5%81/"/>
      <url>/2025/07/05/java%E5%9F%BA%E7%A1%80/Stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Stream流知识点总结"><a href="#Stream流知识点总结" class="headerlink" title="Stream流知识点总结"></a>Stream流知识点总结</h1><p>Steam流是Java 8引入的一个强大的API，用于处理集合数据的函数式编程方式。以下是关于Steam流的主要知识点总结：</p><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><ul><li><strong>Stream</strong>：不是数据结构，而是对数据源(集合、数组等)的高级抽象，用于高效处理大量数据</li><li><strong>特点</strong>：<ul><li>不存储数据(只是数据源的视图)</li><li>不修改源数据(操作会产生新Stream)</li><li>惰性执行(终端操作时才执行)</li><li>可消费性(Stream只能被消费一次)</li></ul></li></ul><h2 id="2-创建Stream的方式"><a href="#2-创建Stream的方式" class="headerlink" title="2. 创建Stream的方式"></a>2. 创建Stream的方式</h2><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 从集合创建</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">// 从数组创建</span><br><span class="line">String[] array = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(array);</span><br><span class="line"></span><br><span class="line">// 使用Stream.of()</span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line"></span><br><span class="line">// 创建无限流</span><br><span class="line">Stream&lt;Integer&gt; infiniteStream = Stream.iterate(0, n -&gt; n + 2); // 无限流</span><br><span class="line">Stream&lt;Double&gt; randomStream = Stream.generate(Math::random); // 无限随机数流</span><br></pre></td></tr></table></figure><h2 id="3-中间操作-Intermediate-Operations"><a href="#3-中间操作-Intermediate-Operations" class="headerlink" title="3. 中间操作(Intermediate Operations)"></a>3. 中间操作(Intermediate Operations)</h2><ul><li>**filter(Predicate)**：过滤元素</li><li>**map(Function)**：转换元素</li><li>**flatMap(Function)**：扁平化流(将流中的每个值转换为另一个流)</li><li>**distinct()**：去重</li><li>**sorted()**：排序</li><li>**limit(long)**：限制元素数量</li><li>**skip(long)**：跳过前N个元素</li><li>**peek(Consumer)**：查看流中元素(主要用于调试)</li></ul><h2 id="4-终端操作-Terminal-Operations"><a href="#4-终端操作-Terminal-Operations" class="headerlink" title="4. 终端操作(Terminal Operations)"></a>4. 终端操作(Terminal Operations)</h2><ul><li>**forEach(Consumer)**：遍历每个元素</li><li>**count()**：计数</li><li>**collect(Collector)**：将流转换为集合或其他形式</li><li>**reduce(BinaryOperator)**：归约操作</li><li>**min(Comparator)&#x2F;max(Comparator)**：查找最小&#x2F;最大值</li><li>**anyMatch(Predicate)&#x2F;allMatch(Predicate)&#x2F;noneMatch(Predicate)**：匹配检查</li><li>**findFirst()&#x2F;findAny()**：查找元素</li></ul><h2 id="5-收集器-Collectors"><a href="#5-收集器-Collectors" class="headerlink" title="5. 收集器(Collectors)"></a>5. 收集器(Collectors)</h2><p>常用Collectors方法：</p><ul><li>**toList()&#x2F;toSet()&#x2F;toCollection()**：转换为集合</li><li>**joining()**：连接字符串</li><li>**summingInt()&#x2F;averagingInt()**：求和&#x2F;平均值</li><li>**groupingBy()**：分组</li><li>**partitioningBy()**：分区</li><li>**counting()**：计数</li></ul><h2 id="6-并行流-Parallel-Stream"><a href="#6-并行流-Parallel-Stream" class="headerlink" title="6. 并行流(Parallel Stream)"></a>6. 并行流(Parallel Stream)</h2><ul><li>使用<code>parallelStream()</code>或<code>stream().parallel()</code>创建并行流</li><li>适用于大数据量且无状态的操作</li><li>注意线程安全问题</li></ul><h2 id="7-使用示例"><a href="#7-使用示例" class="headerlink" title="7. 使用示例"></a>7. 使用示例</h2><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 示例1: 过滤和映射</span><br><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;);</span><br><span class="line">List&lt;String&gt; result = names.stream()</span><br><span class="line">    .filter(name -&gt; name.length() &gt; 3)</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">// 示例2: 分组</span><br><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; groupByNameLength = names.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(String::length));</span><br><span class="line"></span><br><span class="line">// 示例3: 归约</span><br><span class="line">Optional&lt;Integer&gt; totalLength = names.stream()</span><br><span class="line">    .map(String::length)</span><br><span class="line">    .reduce(Integer::sum);</span><br></pre></td></tr></table></figure><h2 id="8-注意事项"><a href="#8-注意事项" class="headerlink" title="8. 注意事项"></a>8. 注意事项</h2><ol><li>Stream操作是延迟执行的，只有终端操作才会触发实际计算</li><li>Stream只能被消费一次，再次使用会抛出IllegalStateException</li><li>避免在流操作中修改源数据</li><li>对于简单操作，传统循环可能比Stream更高效</li></ol><p>Stream API极大地简化了集合操作，使代码更简洁、易读，特别适合复杂的数据处理场景。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架概述</title>
      <link href="/2025/07/04/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/"/>
      <url>/2025/07/04/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="集合框架概述"><a href="#集合框架概述" class="headerlink" title="集合框架概述"></a>集合框架概述</h2><p>Java集合框架(Java Collections Framework)是一组用来存储和操作数据的类和接口，位于java.util包中。它提供了高效的数据结构和算法，简化了程序员的工作。</p><h2 id="集合框架主要接口"><a href="#集合框架主要接口" class="headerlink" title="集合框架主要接口"></a>集合框架主要接口</h2><h3 id="1-Collection接口-根接口"><a href="#1-Collection接口-根接口" class="headerlink" title="1. Collection接口 (根接口)"></a>1. Collection接口 (根接口)</h3><ul><li><strong>List</strong>：有序集合，元素可重复</li><li><strong>Set</strong>：无序集合，元素不可重复</li><li><strong>Queue</strong>：队列，先进先出(FIFO)</li></ul><h3 id="2-Map接口-独立于Collection"><a href="#2-Map接口-独立于Collection" class="headerlink" title="2. Map接口 (独立于Collection)"></a>2. Map接口 (独立于Collection)</h3><ul><li>键值对存储结构</li></ul><h2 id="主要实现类"><a href="#主要实现类" class="headerlink" title="主要实现类"></a>主要实现类</h2><h3 id="List接口实现类"><a href="#List接口实现类" class="headerlink" title="List接口实现类"></a>List接口实现类</h3><ol><li><strong>ArrayList</strong><ul><li>基于动态数组实现</li><li>随机访问快(O(1))，插入删除慢(O(n))</li><li>线程不安全</li></ul></li><li><strong>LinkedList</strong><ul><li>基于双向链表实现</li><li>插入删除快(O(1))，随机访问慢(O(n))</li><li>实现了Deque接口，可用作队列或栈</li></ul></li><li><strong>Vector</strong><ul><li>类似ArrayList，但线程安全</li><li>性能较差，已被ArrayList取代</li></ul></li><li><strong>Stack</strong> (继承自Vector)<ul><li>后进先出(LIFO)的栈结构</li></ul></li></ol><h3 id="Set接口实现类"><a href="#Set接口实现类" class="headerlink" title="Set接口实现类"></a>Set接口实现类</h3><ol><li><strong>HashSet</strong><ul><li>基于HashMap实现</li><li>无序，允许null元素</li><li>添加、删除、查找时间复杂度O(1)</li></ul></li><li><strong>LinkedHashSet</strong><ul><li>继承HashSet，维护插入顺序</li><li>性能略低于HashSet</li></ul></li><li><strong>TreeSet</strong><ul><li>基于TreeMap实现(红黑树)</li><li>元素按自然顺序或Comparator排序</li><li>添加、删除、查找时间复杂度O(log n)</li></ul></li></ol><h3 id="Queue接口实现类"><a href="#Queue接口实现类" class="headerlink" title="Queue接口实现类"></a>Queue接口实现类</h3><ol><li><strong>PriorityQueue</strong><ul><li>基于优先级堆实现</li><li>元素按自然顺序或Comparator排序</li></ul></li><li><strong>ArrayDeque</strong><ul><li>基于可调整大小的数组实现</li><li>可用作栈或队列</li></ul></li></ol><h3 id="Map接口实现类"><a href="#Map接口实现类" class="headerlink" title="Map接口实现类"></a>Map接口实现类</h3><ol><li><strong>HashMap</strong><ul><li>基于哈希表实现(数组+链表+红黑树)</li><li>允许null键和null值</li><li>无序，线程不安全</li></ul></li><li><strong>LinkedHashMap</strong><ul><li>继承HashMap，维护插入顺序或访问顺序</li><li>性能略低于HashMap</li></ul></li><li><strong>TreeMap</strong><ul><li>基于红黑树实现</li><li>键按自然顺序或Comparator排序</li></ul></li><li><strong>Hashtable</strong><ul><li>类似HashMap，但线程安全</li><li>不允许null键和null值</li><li>已被ConcurrentHashMap取代</li></ul></li><li><strong>ConcurrentHashMap</strong><ul><li>线程安全的HashMap</li><li>采用分段锁技术，性能优于Hashtable</li></ul></li></ol><h2 id="集合工具类Collections"><a href="#集合工具类Collections" class="headerlink" title="集合工具类Collections"></a>集合工具类Collections</h2><p>提供了一系列静态方法用于操作集合：</p><ul><li><code>sort()</code>：排序</li><li><code>shuffle()</code>：随机打乱</li><li><code>reverse()</code>：反转</li><li><code>synchronizedXxx()</code>：返回线程安全的集合</li><li><code>unmodifiableXxx()</code>：返回不可修改的集合</li></ul><h2 id="集合遍历方式"><a href="#集合遍历方式" class="headerlink" title="集合遍历方式"></a>集合遍历方式</h2><ol><li><p><strong>for循环</strong> (适用于List)</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0; i&lt;list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>增强for循环</strong></p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>迭代器Iterator</strong></p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">while(it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ListIterator</strong> (仅List可用，可双向遍历)</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;String&gt; lit = list.listIterator();</span><br><span class="line">while(lit.hasNext()) &#123;</span><br><span class="line">    System.out.println(lit.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>forEach()方法</strong> (Java8+)</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(item -&gt; System.out.println(item));</span><br></pre></td></tr></table></figure></li></ol><h2 id="集合选择原则"><a href="#集合选择原则" class="headerlink" title="集合选择原则"></a>集合选择原则</h2><ol><li>需要唯一性 → Set</li><li>需要有序 → List</li><li>需要键值对 → Map</li><li>需要快速访问 → ArrayList&#x2F;HashMap</li><li>需要频繁插入删除 → LinkedList</li><li>需要排序 → TreeSet&#x2F;TreeMap</li><li>需要线程安全 → ConcurrentHashMap&#x2F;Collections.synchronizedXxx()</li></ol><h2 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8+新特性"></a>Java8+新特性</h2><ol><li><p><strong>Stream API</strong>：函数式操作集合</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(s -&gt; s.startsWith(&quot;A&quot;)).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p><strong>默认方法</strong>：如List的sort()方法</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Comparator.naturalOrder());</span><br></pre></td></tr></table></figure></li><li><p><strong>不可变集合</strong>：Java9引入的工厂方法</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; immutableList = List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br></pre></td></tr></table></figure></li></ol><p>掌握集合框架对于Java开发至关重要，合理选择集合类型可以显著提高程序性能和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名内部类与Lambda表达式</title>
      <link href="/2025/07/03/java%E5%9F%BA%E7%A1%80/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/07/03/java%E5%9F%BA%E7%A1%80/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="匿名内部类与Lambda表达式知识点总结"><a href="#匿名内部类与Lambda表达式知识点总结" class="headerlink" title="匿名内部类与Lambda表达式知识点总结"></a>匿名内部类与Lambda表达式知识点总结</h1><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>匿名内部类是没有名字的内部类</li><li>用于快速创建某个类或接口的子类&#x2F;实现类的实例</li><li>适合只使用一次的类实现</li></ul><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new 父类构造器(参数列表) | 实现接口() &#123;</span><br><span class="line">    // 匿名内部类的类体部分</span><br><span class="line">    方法重写/实现</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>必须继承一个父类或实现一个接口</li><li>只能创建一个实例</li><li>没有构造方法（但可以有实例初始化块）</li><li>可以访问外部类的成员，包括私有成员</li><li>如果访问局部变量，该变量必须是final或事实上final的</li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>事件监听器</li><li>线程实现</li><li>需要快速实现某个接口或抽象类</li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>Java 8引入的函数式编程特性</li><li>用于简化函数式接口的实现</li><li>本质是一个匿名函数</li></ul><h3 id="语法结构-1"><a href="#语法结构-1" class="headerlink" title="语法结构"></a>语法结构</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>只能用于函数式接口（只有一个抽象方法的接口）</li><li>类型可以自动推断</li><li>可以访问外部final或事实上final的局部变量</li><li>简洁明了，减少样板代码</li></ol><h3 id="常见函数式接口"><a href="#常见函数式接口" class="headerlink" title="常见函数式接口"></a>常见函数式接口</h3><ul><li><code>Runnable</code> -&gt; <code>() -&gt; &#123;...&#125;</code></li><li><code>Consumer&lt;T&gt;</code> -&gt; <code>(T t) -&gt; &#123;...&#125;</code></li><li><code>Supplier&lt;T&gt;</code> -&gt; <code>() -&gt; &#123;...&#125;</code></li><li><code>Function&lt;T,R&gt;</code> -&gt; <code>(T t) -&gt; &#123;... return R;&#125;</code></li><li><code>Predicate&lt;T&gt;</code> -&gt; <code>(T t) -&gt; &#123;... return boolean;&#125;</code></li></ul><h2 id="匿名内部类-vs-Lambda表达式"><a href="#匿名内部类-vs-Lambda表达式" class="headerlink" title="匿名内部类 vs Lambda表达式"></a>匿名内部类 vs Lambda表达式</h2><table><thead><tr><th align="left">特性</th><th align="left">匿名内部类</th><th align="left">Lambda表达式</th></tr></thead><tbody><tr><td align="left">语法复杂度</td><td align="left">较复杂</td><td align="left">简洁</td></tr><tr><td align="left">使用场景</td><td align="left">任何类&#x2F;接口</td><td align="left">仅函数式接口</td></tr><tr><td align="left">this关键字</td><td align="left">指向匿名内部类本身</td><td align="left">指向外部类</td></tr><tr><td align="left">编译后</td><td align="left">生成单独的.class文件</td><td align="left">不生成.class文件，使用invokedynamic</td></tr><tr><td align="left">访问外部变量</td><td align="left">必须final或事实上final</td><td align="left">必须final或事实上final</td></tr><tr><td align="left">多重方法</td><td align="left">可以</td><td align="left">不可以</td></tr></tbody></table><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="匿名内部类示例"><a href="#匿名内部类示例" class="headerlink" title="匿名内部类示例"></a>匿名内部类示例</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 实现接口</span><br><span class="line">Runnable r = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;匿名内部类实现&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 继承抽象类</span><br><span class="line">Thread t = new Thread() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;继承Thread类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式示例"><a href="#Lambda表达式示例" class="headerlink" title="Lambda表达式示例"></a>Lambda表达式示例</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 无参数</span><br><span class="line">Runnable r = () -&gt; System.out.println(&quot;Lambda实现&quot;);</span><br><span class="line"></span><br><span class="line">// 有参数</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">list.forEach(item -&gt; System.out.println(item));</span><br><span class="line"></span><br><span class="line">// 多行代码</span><br><span class="line">list.forEach(item -&gt; &#123;</span><br><span class="line">    String upper = item.toUpperCase();</span><br><span class="line">    System.out.println(upper);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>Lambda表达式只能替代函数式接口的匿名内部类</li><li>当需要重写多个方法时，仍需使用匿名内部类</li><li>Lambda表达式中的变量必须是final或事实上final</li><li>在需要访问实例变量或方法时，匿名内部类可能更合适</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架概述</title>
      <link href="/2025/07/02/java%E5%9F%BA%E7%A1%80/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2025/07/02/java%E5%9F%BA%E7%A1%80/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、抽象类（Abstract-Class）"><a href="#一、抽象类（Abstract-Class）" class="headerlink" title="一、抽象类（Abstract Class）"></a>一、抽象类（Abstract Class）</h2><h3 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title="1. 基本特性"></a>1. 基本特性</h3><ul><li>使用<code>abstract</code>关键字声明</li><li>可以包含抽象方法和具体方法</li><li>不能直接实例化（不能new）</li><li>可以包含成员变量、构造方法、普通方法</li></ul><h3 id="2-语法结构"><a href="#2-语法结构" class="headerlink" title="2. 语法结构"></a>2. 语法结构</h3><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line">    // 成员变量</span><br><span class="line">    protected String name;</span><br><span class="line">    </span><br><span class="line">    // 构造方法</span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 抽象方法（无实现）</span><br><span class="line">    public abstract void makeSound();</span><br><span class="line">    </span><br><span class="line">    // 具体方法</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(name + &quot;正在吃东西&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用要点"><a href="#3-使用要点" class="headerlink" title="3. 使用要点"></a>3. 使用要点</h3><ul><li><strong>抽象方法</strong>：没有方法体，必须用<code>abstract</code>修饰</li><li><strong>子类要求</strong>：非抽象子类必须实现所有抽象方法</li><li><strong>构造方法</strong>：虽然不能实例化，但可以有构造方法供子类调用</li><li><strong>访问控制</strong>：抽象方法不能用private修饰（因为需要子类实现）</li></ul><h3 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h3><ul><li>多个相关类共享代码和关系</li><li>需要定义子类的共同行为规范</li><li>需要包含非public的成员和方法</li><li>需要定义非static、非final的成员变量</li></ul><h2 id="二、接口（Interface）"><a href="#二、接口（Interface）" class="headerlink" title="二、接口（Interface）"></a>二、接口（Interface）</h2><h3 id="1-基本特性-1"><a href="#1-基本特性-1" class="headerlink" title="1. 基本特性"></a>1. 基本特性</h3><ul><li>Java 7及以前：纯抽象（只有抽象方法）</li><li>Java 8开始：支持默认方法（default）和静态方法</li><li>Java 9开始：支持私有方法</li><li>不能包含实例字段（只能是static final常量）</li><li>不能有构造方法</li></ul><h3 id="2-语法演进"><a href="#2-语法演进" class="headerlink" title="2. 语法演进"></a>2. 语法演进</h3><h4 id="Java-7及以前"><a href="#Java-7及以前" class="headerlink" title="Java 7及以前"></a>Java 7及以前</h4><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Flyable &#123;</span><br><span class="line">    // 常量（默认public static final）</span><br><span class="line">    int MAX_HEIGHT = 10000;</span><br><span class="line">    </span><br><span class="line">    // 抽象方法（默认public abstract）</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8+"></a>Java 8+</h4><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface SmartDevice &#123;</span><br><span class="line">    // 抽象方法</span><br><span class="line">    void turnOn();</span><br><span class="line">    </span><br><span class="line">    // 默认方法</span><br><span class="line">    default void updateFirmware() &#123;</span><br><span class="line">        System.out.println(&quot;执行默认固件更新&quot;);</span><br><span class="line">        privateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 静态方法</span><br><span class="line">    static void showVersion() &#123;</span><br><span class="line">        System.out.println(&quot;智能设备接口v2.0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Java 9私有方法</span><br><span class="line">    private void privateMethod() &#123;</span><br><span class="line">        System.out.println(&quot;私有方法执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用要点-1"><a href="#3-使用要点-1" class="headerlink" title="3. 使用要点"></a>3. 使用要点</h3><ul><li><strong>实现要求</strong>：类实现接口必须实现所有抽象方法（默认方法可选）</li><li><strong>多继承</strong>：一个类可以实现多个接口</li><li><strong>接口继承</strong>：接口可以继承多个其他接口</li><li><strong>默认冲突</strong>：当多个接口有相同默认方法时，实现类必须重写</li></ul><h3 id="4-适用场景-1"><a href="#4-适用场景-1" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h3><ul><li>定义不相关类的共同行为</li><li>需要多重继承的场景</li><li>作为API的定义规范</li><li>需要定义回调函数（如EventListener）</li></ul><h2 id="三、抽象类与接口对比"><a href="#三、抽象类与接口对比" class="headerlink" title="三、抽象类与接口对比"></a>三、抽象类与接口对比</h2><table><thead><tr><th align="left">特性</th><th align="left">抽象类</th><th align="left">接口</th></tr></thead><tbody><tr><td align="left"><strong>关键字</strong></td><td align="left">abstract class</td><td align="left">interface</td></tr><tr><td align="left"><strong>方法类型</strong></td><td align="left">抽象方法+具体方法</td><td align="left">Java 8前只有抽象方法，之后有默认方法和静态方法</td></tr><tr><td align="left"><strong>变量</strong></td><td align="left">可以有各种成员变量</td><td align="left">只能是public static final常量</td></tr><tr><td align="left"><strong>构造方法</strong></td><td align="left">有</td><td align="left">没有</td></tr><tr><td align="left"><strong>继承&#x2F;实现</strong></td><td align="left">单继承（extends）</td><td align="left">多实现（implements）</td></tr><tr><td align="left"><strong>设计目的</strong></td><td align="left">代码复用和层次化设计</td><td align="left">定义行为规范和能力</td></tr><tr><td align="left"><strong>访问控制</strong></td><td align="left">可以是任意访问修饰符</td><td align="left">默认public（不能是protected&#x2F;private）</td></tr><tr><td align="left"><strong>多态支持</strong></td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left"><strong>JDK版本影响</strong></td><td align="left">不受影响</td><td align="left">功能随版本增强</td></tr></tbody></table><h2 id="四、选择原则"><a href="#四、选择原则" class="headerlink" title="四、选择原则"></a>四、选择原则</h2><ol><li><p><strong>使用抽象类当</strong>：</p><ul><li>多个相关类需要共享代码</li><li>需要定义非public的成员</li><li>需要定义非static、非final的字段</li><li>需要定义构造方法逻辑</li></ul></li><li><p><strong>使用接口当</strong>：</p><ul><li>不相关的类需要实现相同的行为</li><li>需要多重继承</li><li>只关注行为规范而非实现</li><li>作为API定义供他人实现</li></ul></li><li><p><strong>组合使用</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 抽象类提供基础实现</span><br><span class="line">abstract class Bird extends Animal implements Flyable &#123;</span><br><span class="line">    // 既继承Animal的特性，又实现Flyable的能力</span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;用翅膀飞行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="五、最新发展（Java-8-17）"><a href="#五、最新发展（Java-8-17）" class="headerlink" title="五、最新发展（Java 8-17）"></a>五、最新发展（Java 8-17）</h2><ol><li><strong>接口的增强</strong>：<ul><li>默认方法（解决接口演化问题）</li><li>静态方法（工具方法）</li><li>私有方法（Java 9，代码复用）</li></ul></li><li><strong>接口与抽象类的界限模糊</strong>：<ul><li>接口现在也可以有方法实现</li><li>但接口仍然不能有实例状态（成员变量）</li></ul></li><li><strong>record类与sealed类</strong>：<ul><li>Java 14引入record（数据载体）</li><li>Java 15引入sealed类（受限继承）</li><li>这些新特性与抽象类&#x2F;接口形成互补</li></ul></li></ol><h2 id="六、设计模式中的应用"><a href="#六、设计模式中的应用" class="headerlink" title="六、设计模式中的应用"></a>六、设计模式中的应用</h2><ol><li><p><strong>模板方法模式</strong>（抽象类典型应用）：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract class Game &#123;</span><br><span class="line">    abstract void initialize();</span><br><span class="line">    abstract void startPlay();</span><br><span class="line">    </span><br><span class="line">    // 模板方法</span><br><span class="line">    public final void play() &#123;</span><br><span class="line">        initialize();</span><br><span class="line">        startPlay();</span><br><span class="line">        endPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>策略模式</strong>（接口典型应用）：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface PaymentStrategy &#123;</span><br><span class="line">    void pay(int amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CreditCardPayment implements PaymentStrategy &#123;</span><br><span class="line">    public void pay(int amount) &#123; /*...*/ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>适配器模式</strong>（结合使用）：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Target &#123;</span><br><span class="line">    void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Adapter implements Target &#123;</span><br><span class="line">    public void request() &#123; /* 默认实现 */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>掌握抽象类和接口的区别与适用场景，是Java面向对象设计的重要基础。随着Java版本的更新，两者的功能都在不断增强，但核心设计理念保持不变：抽象类侧重于”是什么”，接口侧重于”能做什么”。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承与多态核心知识点总结</title>
      <link href="/2025/07/02/java%E5%9F%BA%E7%A1%80/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E6%80%BB%E7%BB%93/"/>
      <url>/2025/07/02/java%E5%9F%BA%E7%A1%80/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="继承与多态核心知识点总结"><a href="#继承与多态核心知识点总结" class="headerlink" title="继承与多态核心知识点总结"></a>继承与多态核心知识点总结</h1><h2 id="1-继承-Inheritance"><a href="#1-继承-Inheritance" class="headerlink" title="1. 继承 (Inheritance)"></a>1. 继承 (Inheritance)</h2><p><strong>概念</strong>：</p><ul><li>允许一个类(子类)继承另一个类(父类)的特征和行为</li><li>子类可以获得父类的属性和方法，并可以添加新的属性和方法</li></ul><p><strong>语法</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">    // 子类特有的属性和方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ol><li>Java是单继承，一个类只能直接继承一个父类</li><li>子类继承父类非private的成员(属性和方法)</li><li>子类可以重写(override)父类的方法</li><li>构造方法不能被继承</li></ol><p><strong>关键字</strong>：</p><ul><li><code>extends</code>：表示继承关系</li><li><code>super</code>：引用父类的成员<ul><li><code>super()</code>：调用父类构造方法</li><li><code>super.方法名()</code>：调用父类方法</li></ul></li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(name + &quot;正在吃东西&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    String breed;</span><br><span class="line">    </span><br><span class="line">    public Dog(String name, String breed) &#123;</span><br><span class="line">        super(name); // 调用父类构造方法</span><br><span class="line">        this.breed = breed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        super.eat(); // 调用父类方法</span><br><span class="line">        System.out.println(name + &quot;正在吃狗粮&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void bark() &#123;</span><br><span class="line">        System.out.println(name + &quot;汪汪叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-多态-Polymorphism"><a href="#2-多态-Polymorphism" class="headerlink" title="2. 多态 (Polymorphism)"></a>2. 多态 (Polymorphism)</h2><p><strong>概念</strong>：</p><ul><li>同一操作作用于不同对象，可以有不同的解释，产生不同的执行结果</li><li>主要包括编译时多态(方法重载)和运行时多态(方法重写)</li></ul><p><strong>实现条件</strong>：</p><ol><li>继承关系</li><li>方法重写</li><li>父类引用指向子类对象</li></ol><p><strong>表现形式</strong>：</p><ol><li>方法重载(Overload) - 编译时多态<ul><li>同一个类中，方法名相同，参数列表不同</li></ul></li><li>方法重写(Override) - 运行时多态<ul><li>子类中定义与父类相同签名的方法</li></ul></li></ol><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 方法重载示例</span><br><span class="line">class Calculator &#123;</span><br><span class="line">    public int add(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public double add(double a, double b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法重写(多态)示例</span><br><span class="line">class Animal &#123;</span><br><span class="line">    public void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;动物发出声音&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;喵喵叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;汪汪叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal myAnimal = new Animal();  // Animal对象</span><br><span class="line">        Animal myCat = new Cat();       // Cat对象</span><br><span class="line">        Animal myDog = new Dog();        // Dog对象</span><br><span class="line">        </span><br><span class="line">        myAnimal.makeSound();  // 输出: 动物发出声音</span><br><span class="line">        myCat.makeSound();    // 输出: 喵喵叫</span><br><span class="line">        myDog.makeSound();     // 输出: 汪汪叫</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-继承与多态的重要特性"><a href="#3-继承与多态的重要特性" class="headerlink" title="3. 继承与多态的重要特性"></a>3. 继承与多态的重要特性</h2><h3 id="3-1-方法重写-Override-规则"><a href="#3-1-方法重写-Override-规则" class="headerlink" title="3.1 方法重写(Override)规则"></a>3.1 方法重写(Override)规则</h3><ol><li>方法名和参数列表必须完全相同</li><li>返回类型可以是父类方法返回类型的子类(协变返回类型)</li><li>访问权限不能比父类方法更严格</li><li>不能重写private、final和static方法</li><li>重写方法可以抛出与父类方法相同的异常或不抛出异常或抛出父类异常的子类异常</li></ol><h3 id="3-2-向上转型-Upcasting-和向下转型-Downcasting"><a href="#3-2-向上转型-Upcasting-和向下转型-Downcasting" class="headerlink" title="3.2 向上转型(Upcasting)和向下转型(Downcasting)"></a>3.2 向上转型(Upcasting)和向下转型(Downcasting)</h3><ul><li><p><strong>向上转型</strong>：子类对象赋值给父类引用(自动转换)</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = new Dog(); // 向上转型</span><br></pre></td></tr></table></figure></li><li><p><strong>向下转型</strong>：父类引用强制转换为子类引用(需要显式转换)</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = (Dog)animal; // 向下转型</span><br></pre></td></tr></table></figure></li></ul><p><strong>instanceof运算符</strong>：<br>用于检查对象是否是特定类的实例，常用于向下转型前的安全检查</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (animal instanceof Dog) &#123;</span><br><span class="line">    Dog dog = (Dog)animal;</span><br><span class="line">    dog.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-抽象类与多态"><a href="#3-3-抽象类与多态" class="headerlink" title="3.3 抽象类与多态"></a>3.3 抽象类与多态</h3><ul><li>抽象类不能实例化，只能被继承</li><li>抽象方法没有方法体，必须在子类中实现</li><li>抽象类可以包含普通方法和抽象方法</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">abstract class Shape &#123;</span><br><span class="line">    abstract double area(); // 抽象方法</span><br><span class="line">    </span><br><span class="line">    void display() &#123;        // 普通方法</span><br><span class="line">        System.out.println(&quot;这是一个形状&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle extends Shape &#123;</span><br><span class="line">    double radius;</span><br><span class="line">    </span><br><span class="line">    Circle(double r) &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    double area() &#123;</span><br><span class="line">        return Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle extends Shape &#123;</span><br><span class="line">    double length, width;</span><br><span class="line">    </span><br><span class="line">    Rectangle(double l, double w) &#123;</span><br><span class="line">        length = l;</span><br><span class="line">        width = w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    double area() &#123;</span><br><span class="line">        return length * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-接口与多态"><a href="#3-4-接口与多态" class="headerlink" title="3.4 接口与多态"></a>3.4 接口与多态</h3><ul><li>接口是完全抽象的类，所有方法默认是public abstract</li><li>类可以实现多个接口</li><li>接口可以多继承其他接口</li><li>Java 8后接口可以有默认方法和静态方法</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">interface Flyable &#123;</span><br><span class="line">    void fly(); // 抽象方法</span><br><span class="line">    </span><br><span class="line">    default void land() &#123; // 默认方法</span><br><span class="line">        System.out.println(&quot;正在着陆&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static int getMaxAltitude() &#123; // 静态方法</span><br><span class="line">        return 10000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Swimmable &#123;</span><br><span class="line">    void swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Duck implements Flyable, Swimmable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;鸭子飞起来了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line">        System.out.println(&quot;鸭子在游泳&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-继承与多态的应用场景"><a href="#4-继承与多态的应用场景" class="headerlink" title="4. 继承与多态的应用场景"></a>4. 继承与多态的应用场景</h2><ol><li><strong>代码复用</strong>：通过继承复用父类代码</li><li><strong>扩展功能</strong>：子类可以在继承的基础上添加新功能</li><li><strong>统一接口</strong>：多态允许不同类型的对象响应相同的消息</li><li><strong>框架设计</strong>：通过抽象类和接口定义框架，具体实现由子类完成</li><li><strong>插件架构</strong>：通过接口定义标准，具体实现可以动态加载</li></ol><h2 id="5-tips"><a href="#5-tips" class="headerlink" title="5.tips"></a>5.tips</h2><p>import lombok.AllArgsConstructor:<br>import lombok.Data;<br>import lombok.NoArgsConstructor;<br>&#x2F;&#x2F; lombok技术可以实现为类自动添加getter setter方法无参数构造器，toString方法等</p><p>@Data &#x2F;&#x2F; @Data注解可以自动生成getter setter方法无参构造器 toString方法等</p><p>@NoArgsConstructor</p><p>@AllArgsConstructor</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象编程基础语法</title>
      <link href="/2025/07/01/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/07/01/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面向对象编程基础语法"><a href="#Java面向对象编程基础语法" class="headerlink" title="Java面向对象编程基础语法"></a>Java面向对象编程基础语法</h1><h2 id="1-对象-Object"><a href="#1-对象-Object" class="headerlink" title="1. 对象 (Object)"></a>1. 对象 (Object)</h2><p><strong>概念</strong>：</p><ul><li>对象是类的实例，是面向对象编程的基本单位</li><li>对象具有状态(属性)和行为(方法)</li><li>对象在内存中占据独立的空间</li></ul><p><strong>特点</strong>：</p><ul><li>每个对象都有唯一的标识(内存地址)</li><li>对象之间通过消息传递进行交互</li><li>对象是类的具体实现</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = new Person(); // person1是一个Person类的对象</span><br></pre></td></tr></table></figure><h2 id="2-封装-Encapsulation"><a href="#2-封装-Encapsulation" class="headerlink" title="2. 封装 (Encapsulation)"></a>2. 封装 (Encapsulation)</h2><p><strong>概念</strong>：</p><ul><li>将数据(属性)和行为(方法)包装在一个单元(类)中</li><li>隐藏对象的内部实现细节，仅暴露必要的接口</li></ul><p><strong>实现方式</strong>：</p><ul><li>使用访问修饰符控制可见性：<ul><li><code>private</code>：仅本类可见</li><li><code>protected</code>：本包和子类可见</li><li><code>public</code>：所有类可见</li><li>(默认)：本包可见</li></ul></li></ul><p><strong>优点</strong>：</p><ul><li>提高代码安全性</li><li>降低耦合度</li><li>便于修改和维护</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BankAccount &#123;</span><br><span class="line">    private double balance; // 私有属性，外部不可直接访问</span><br><span class="line">    </span><br><span class="line">    // 公有方法，提供受控的访问方式</span><br><span class="line">    public void deposit(double amount) &#123;</span><br><span class="line">        if(amount &gt; 0) &#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public double getBalance() &#123;</span><br><span class="line">        return balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-构造器-Constructor"><a href="#3-构造器-Constructor" class="headerlink" title="3. 构造器 (Constructor)"></a>3. 构造器 (Constructor)</h2><p><strong>概念</strong>：</p><ul><li>一种特殊的方法，用于创建和初始化对象</li><li>方法名与类名相同，没有返回类型(连void也没有)</li></ul><p><strong>特点</strong>：</p><ul><li>在创建对象时自动调用(new时)</li><li>可以重载(多个不同参数的构造器)</li><li>如果没有显式定义构造器，编译器会提供默认无参构造器</li><li>一旦定义了构造器，默认构造器就不再自动提供</li></ul><p><strong>分类</strong>：</p><ol><li>无参构造器</li><li>带参构造器</li></ol><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    // 无参构造器</span><br><span class="line">    public Person() &#123;</span><br><span class="line">        this.name = &quot;未知&quot;;</span><br><span class="line">        this.age = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 带参构造器</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-this关键字"><a href="#4-this关键字" class="headerlink" title="4. this关键字"></a>4. this关键字</h2><p><strong>作用</strong>：</p><ol><li>指代当前对象</li><li>在构造器中调用其他构造器(必须放在第一行)</li><li>区分成员变量和局部变量</li></ol><p><strong>使用场景</strong>：</p><ul><li>当局部变量与成员变量同名时</li><li>在方法中需要返回当前对象时</li><li>在构造器中调用其他构造器时</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int score;</span><br><span class="line">    </span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this(name, 0); // 调用另一个构造器</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Student(String name, int score) &#123;</span><br><span class="line">        this.name = name; // 区分成员变量和参数</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Student getCurrentObject() &#123;</span><br><span class="line">        return this; // 返回当前对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-封装-Encapsulation-补充说明"><a href="#5-封装-Encapsulation-补充说明" class="headerlink" title="5. 封装 (Encapsulation) - 补充说明"></a>5. 封装 (Encapsulation) - 补充说明</h2><p><strong>封装的核心原则</strong>：</p><ul><li>将数据和对数据的操作绑定在一起</li><li>对外隐藏实现细节，只暴露必要的接口</li><li>通过访问控制实现信息隐藏</li></ul><p><strong>封装的具体实现</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    // 私有属性 - 实现封装</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private double score;</span><br><span class="line">    </span><br><span class="line">    // 公开的getter方法 - 提供受控的读访问</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 公开的setter方法 - 提供受控的写访问</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        if(name != null &amp;&amp; !name.isEmpty()) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他业务方法</span><br><span class="line">    public void printInfo() &#123;</span><br><span class="line">        System.out.println(&quot;姓名：&quot; + name + &quot;，年龄：&quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装的好处</strong>：</p><ol><li>防止外部代码随意修改对象内部状态</li><li>可以在setter方法中添加验证逻辑</li><li>修改内部实现不影响外部代码</li><li>提高代码的可维护性和安全性</li></ol><h2 id="6-实体类-Entity-Class"><a href="#6-实体类-Entity-Class" class="headerlink" title="6. 实体类 (Entity Class)"></a>6. 实体类 (Entity Class)</h2><p><strong>概念</strong>：</p><ul><li>用于表示现实世界中的实体或概念的类</li><li>通常对应数据库中的表或业务领域中的对象</li></ul><p><strong>实体类特点</strong>：</p><ol><li>主要包含属性和对应的getter&#x2F;setter方法</li><li>通常实现Serializable接口以支持序列化</li><li>可能包含简单的业务逻辑方法</li><li>一般会重写equals()、hashCode()和toString()方法</li></ol><p><strong>典型实体类示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    // 属性</span><br><span class="line">    private Long id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private Date createTime;</span><br><span class="line">    </span><br><span class="line">    // 构造方法</span><br><span class="line">    public User() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public User(String username, String password) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.createTime = new Date();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // getter和setter</span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他方法...</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, username=&#x27;&quot; + username + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, createTime=&quot; + createTime +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        // 实现equals方法...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        // 实现hashCode方法...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实体类的使用场景</strong>：</p><ul><li>数据传输对象(DTO)</li><li>持久化对象(对应数据库表)</li><li>业务模型对象</li></ul><h2 id="7-static-关键字"><a href="#7-static-关键字" class="headerlink" title="7. static 关键字"></a>7. static 关键字</h2><p><strong>static 的用途</strong>：</p><ol><li>静态变量（类变量）</li><li>静态方法（类方法）</li><li>静态代码块</li><li>静态内部类</li></ol><h3 id="7-1-静态变量（类变量）"><a href="#7-1-静态变量（类变量）" class="headerlink" title="7.1 静态变量（类变量）"></a>7.1 静态变量（类变量）</h3><p><strong>特点</strong>：</p><ul><li>属于类，不属于任何对象实例</li><li>所有对象共享同一份静态变量</li><li>在类加载时初始化</li><li>可以通过类名直接访问</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int id;</span><br><span class="line">    </span><br><span class="line">    // 静态变量 - 记录员工总数</span><br><span class="line">    private static int nextId = 1;</span><br><span class="line">    </span><br><span class="line">    public Employee(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.id = nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int getNextId() &#123;</span><br><span class="line">        return nextId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-静态方法（类方法）"><a href="#7-2-静态方法（类方法）" class="headerlink" title="7.2 静态方法（类方法）"></a>7.2 静态方法（类方法）</h3><p><strong>特点</strong>：</p><ul><li>属于类，不属于对象实例</li><li>不能直接访问实例变量和实例方法</li><li>可以通过类名直接调用</li><li>常用于工具类方法</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MathUtils &#123;</span><br><span class="line">    // 静态方法</span><br><span class="line">    public static double calculateCircleArea(double radius) &#123;</span><br><span class="line">        return Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int max(int a, int b) &#123;</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">double area = MathUtils.calculateCircleArea(5.0);</span><br><span class="line">int maxNum = MathUtils.max(10, 20);</span><br></pre></td></tr></table></figure><h3 id="7-3-静态代码块"><a href="#7-3-静态代码块" class="headerlink" title="7.3 静态代码块"></a>7.3 静态代码块</h3><p><strong>特点</strong>：</p><ul><li>在类加载时执行，且只执行一次</li><li>用于初始化静态变量或执行只需一次的初始化操作</li><li>可以有多个静态代码块，按顺序执行</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class DatabaseConfig &#123;</span><br><span class="line">    private static Properties props;</span><br><span class="line">    </span><br><span class="line">    // 静态代码块</span><br><span class="line">    static &#123;</span><br><span class="line">        props = new Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            props.load(DatabaseConfig.class.getResourceAsStream(&quot;/db.properties&quot;));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static String getConfig(String key) &#123;</span><br><span class="line">        return props.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-静态内部类"><a href="#7-4-静态内部类" class="headerlink" title="7.4 静态内部类"></a>7.4 静态内部类</h3><p><strong>特点</strong>：</p><ul><li>不依赖于外部类的实例</li><li>只能访问外部类的静态成员</li><li>常用于与外部类密切相关但又不需要访问外部类实例的情况</li></ul><p><strong>示例</strong>：</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private static String staticField = &quot;Static Field&quot;;</span><br><span class="line">    </span><br><span class="line">    // 静态内部类</span><br><span class="line">    public static class StaticNestedClass &#123;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(&quot;访问外部类的静态字段：&quot; + staticField);</span><br><span class="line">            // 不能访问非静态字段</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">OuterClass.StaticNestedClass nested = new OuterClass.StaticNestedClass();</span><br><span class="line">nested.print();</span><br></pre></td></tr></table></figure><h2 id="static-使用注意事项"><a href="#static-使用注意事项" class="headerlink" title="static 使用注意事项"></a>static 使用注意事项</h2><ol><li>静态方法中不能使用 this 和 super 关键字</li><li>静态方法只能直接调用其他静态方法</li><li>静态方法只能直接访问静态变量</li><li>静态方法不能被重写（但可以隐藏）</li><li>静态成员在类加载时初始化，早于实例成员的初始化</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BroadcastReceiver</title>
      <link href="/2025/04/20/android%E7%BB%84%E4%BB%B6/BroadcastReceiver/"/>
      <url>/2025/04/20/android%E7%BB%84%E4%BB%B6/BroadcastReceiver/</url>
      
        <content type="html"><![CDATA[<h2 id="🚨-什么是-BroadcastReceiver？"><a href="#🚨-什么是-BroadcastReceiver？" class="headerlink" title="🚨 什么是 BroadcastReceiver？"></a>🚨 什么是 BroadcastReceiver？</h2><p><code>BroadcastReceiver</code> 是 Android 提供的一个机制，用于<strong>在应用之间或系统与应用之间传递消息</strong>。比如：</p><ul><li>当手机接收到短信时；</li><li>电池电量变化；</li><li>网络连接变化；</li><li>你自己在 App 内发出一个自定义事件。</li></ul><p>这些“消息”叫做<strong>广播（Broadcast）</strong>，而负责“接收广播”的组件就是 <strong>BroadcastReceiver</strong>。</p><hr><h2 id="🧠-工作原理："><a href="#🧠-工作原理：" class="headerlink" title="🧠 工作原理："></a>🧠 工作原理：</h2><ol><li>某个组件（系统或 app）发送一个广播（用 <code>sendBroadcast()</code>）；</li><li>Android 系统会根据你注册的广播类型，找到匹配的 <code>BroadcastReceiver</code>；</li><li><code>BroadcastReceiver</code> 会执行你定义的逻辑（通常在 <code>onReceive()</code> 方法里写处理逻辑）；</li></ol><hr><h2 id="📦-BroadcastReceiver-分类"><a href="#📦-BroadcastReceiver-分类" class="headerlink" title="📦 BroadcastReceiver 分类"></a>📦 BroadcastReceiver 分类</h2><h3 id="1-静态注册"><a href="#1-静态注册" class="headerlink" title="1. 静态注册"></a>1. <strong>静态注册</strong></h3><ul><li>在 <code>AndroidManifest.xml</code> 中注册</li><li>会在 App 没启动的情况下也能接收到广播（某些系统广播）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.MyReceiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure><h3 id="2-动态注册"><a href="#2-动态注册" class="headerlink" title="2. 动态注册"></a>2. <strong>动态注册</strong></h3><ul><li>在 Java&#x2F;Kotlin 代码中注册</li><li>一般在 Activity 或 Service 的生命周期内注册和注销</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReceiver receiver = new MyReceiver();</span><br><span class="line">IntentFilter filter = new IntentFilter(&quot;com.example.MY_BROADCAST&quot;);</span><br><span class="line">registerReceiver(receiver, filter);  // 注册</span><br><span class="line">unregisterReceiver(receiver);        // 注销（避免内存泄漏）</span><br></pre></td></tr></table></figure><hr><h2 id="🧪-示例：自定义广播发送与接收"><a href="#🧪-示例：自定义广播发送与接收" class="headerlink" title="🧪 示例：自定义广播发送与接收"></a>🧪 示例：自定义广播发送与接收</h2><h3 id="1️⃣-创建一个自定义广播接收器："><a href="#1️⃣-创建一个自定义广播接收器：" class="headerlink" title="1️⃣ 创建一个自定义广播接收器："></a>1️⃣ 创建一个自定义广播接收器：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        // 当广播接收到时，这里会执行</span><br><span class="line">        String data = intent.getStringExtra(&quot;msg&quot;);</span><br><span class="line">        Toast.makeText(context, &quot;收到广播: &quot; + data, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2️⃣-动态注册（例如在-MainActivity-中）："><a href="#2️⃣-动态注册（例如在-MainActivity-中）：" class="headerlink" title="2️⃣ 动态注册（例如在 MainActivity 中）："></a>2️⃣ 动态注册（例如在 MainActivity 中）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyReceiver myReceiver = new MyReceiver();</span><br><span class="line">IntentFilter filter = new IntentFilter(&quot;com.example.MY_BROADCAST&quot;);</span><br><span class="line">registerReceiver(myReceiver, filter);</span><br></pre></td></tr></table></figure><h3 id="3️⃣-发送广播："><a href="#3️⃣-发送广播：" class="headerlink" title="3️⃣ 发送广播："></a>3️⃣ 发送广播：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(&quot;com.example.MY_BROADCAST&quot;);</span><br><span class="line">intent.putExtra(&quot;msg&quot;, &quot;你好，世界！&quot;);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure><hr><h2 id="🔐-权限和安全"><a href="#🔐-权限和安全" class="headerlink" title="🔐 权限和安全"></a>🔐 权限和安全</h2><ul><li><p>有些系统广播需要权限，例如监听开机广播：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xml</span><br><span class="line"></span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>Android 8.0（API 26）之后，对静态注册广播做了限制，一些隐式广播不能再静态注册，只能动态注册。</p></li></ul><hr><h2 id="✅-使用小贴士"><a href="#✅-使用小贴士" class="headerlink" title="✅ 使用小贴士"></a>✅ 使用小贴士</h2><table><thead><tr><th>内容</th><th>建议</th></tr></thead><tbody><tr><td>生命周期管理</td><td>动态注册时，记得在 <code>onDestroy()</code> 中注销广播</td></tr><tr><td>安全性</td><td>自定义广播建议使用 <code>LocalBroadcastManager</code>（已废弃，推荐使用 LiveData&#x2F;EventBus 替代）</td></tr><tr><td>不要做耗时操作</td><td><code>onReceive()</code> 中不能做耗时操作，默认运行在主线程</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> android主要组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android主要组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin中的内联函数</title>
      <link href="/2025/04/20/kotlin/Kotlin%20%E4%B8%AD%E7%9A%84%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>/2025/04/20/kotlin/Kotlin%20%E4%B8%AD%E7%9A%84%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="🌟-什么是内联函数？"><a href="#🌟-什么是内联函数？" class="headerlink" title="🌟 什么是内联函数？"></a>🌟 什么是内联函数？</h3><p>简单说：</p><blockquote><p><strong>内联函数就是在编译时将函数的调用代码“展开”为函数体本身，从而避免函数调用的开销。</strong></p></blockquote><p>通常高阶函数（比如 <code>map</code>, <code>filter</code>, <code>let</code>, <code>run</code> 等）都会带来额外的开销，因为它们需要创建函数对象、维护调用栈。而使用 <code>inline</code> 关键字修饰的函数在编译时会将其代码“拷贝”到调用处，避免这些额外开销。</p><hr><h3 id="🧪-基本语法"><a href="#🧪-基本语法" class="headerlink" title="🧪 基本语法"></a>🧪 基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun doSomething(action: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;Start&quot;)</span><br><span class="line">    action()</span><br><span class="line">    println(&quot;End&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething &#123;</span><br><span class="line">    println(&quot;Hello inline&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚡ 编译后，大致等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;Start&quot;)</span><br><span class="line">println(&quot;Hello inline&quot;)</span><br><span class="line">println(&quot;End&quot;)</span><br></pre></td></tr></table></figure><p>函数体直接“插入”到调用处。</p><hr><h3 id="✅-优势"><a href="#✅-优势" class="headerlink" title="✅ 优势"></a>✅ 优势</h3><ol><li><strong>性能提升</strong>：避免函数调用、lambda 对象创建的开销。</li><li><strong>允许非局部返回</strong>（下面详细说）</li><li><strong>适合频繁调用的小型函数或高阶函数</strong></li></ol><hr><h3 id="⚠️-注意：非局部返回（non-local-return）"><a href="#⚠️-注意：非局部返回（non-local-return）" class="headerlink" title="⚠️ 注意：非局部返回（non-local return）"></a>⚠️ 注意：<strong>非局部返回（non-local return）</strong></h3><p>Lambda 中用 <code>return</code>，默认是从<strong>外围函数</strong>返回的，这在内联函数中是允许的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">inline fun doSomething(block: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;Before&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;After&quot;)  // 不会执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun test() &#123;</span><br><span class="line">    doSomething &#123;</span><br><span class="line">        println(&quot;Inside&quot;)</span><br><span class="line">        return  // 非局部 return，直接从 test() 返回</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;This will not be printed&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你把 <code>doSomething</code> 的 <code>inline</code> 去掉，这段代码是<strong>无法通过编译</strong>的。</p><hr><h3 id="🔒-使用-noinline-禁止内联某个-lambda"><a href="#🔒-使用-noinline-禁止内联某个-lambda" class="headerlink" title="🔒 使用 noinline 禁止内联某个 lambda"></a>🔒 使用 <code>noinline</code> 禁止内联某个 lambda</h3><p>有时候你不希望某些 lambda 被内联，可以加 <code>noinline</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline fun process(a: () -&gt; Unit, noinline b: () -&gt; Unit) &#123;</span><br><span class="line">    a()     // 内联</span><br><span class="line">    b()     // 不内联</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用于 <strong>将 lambda 作为值传递或多次使用</strong> 的情况。</p><hr><h3 id="💥-crossinline：阻止-lambda-使用-return"><a href="#💥-crossinline：阻止-lambda-使用-return" class="headerlink" title="💥 crossinline：阻止 lambda 使用 return"></a>💥 <code>crossinline</code>：阻止 lambda 使用 return</h3><p>有时候你<strong>必须内联</strong>，但又<strong>不允许 lambda 使用非局部 return</strong>（比如 lambda 传给另一个线程或匿名类），你可以加 <code>crossinline</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun startJob(crossinline job: () -&gt; Unit) &#123;</span><br><span class="line">    Thread &#123;</span><br><span class="line">        job()  // 如果 job 用 return 会报错</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🚀-小总结"><a href="#🚀-小总结" class="headerlink" title="🚀 小总结"></a>🚀 小总结</h3><table><thead><tr><th>关键字</th><th>作用</th></tr></thead><tbody><tr><td><code>inline</code></td><td>编译时将函数体展开，提升性能，允许非局部 return</td></tr><tr><td><code>noinline</code></td><td>禁止某个 lambda 被内联（用于多次调用或当作对象传递）</td></tr><tr><td><code>crossinline</code></td><td>阻止某个 lambda 使用 <code>return</code>（防止非局部 return）</td></tr></tbody></table><hr><h3 id="✅-典型应用场景"><a href="#✅-典型应用场景" class="headerlink" title="✅ 典型应用场景"></a>✅ 典型应用场景</h3><ul><li><code>apply</code> &#x2F; <code>run</code> &#x2F; <code>let</code> 等标准库函数内部都是 <code>inline</code> 的</li><li>DSL 构建器，比如 <code>anko</code>, <code>Jetpack Compose</code>, <code>Ktor</code> 等大量用 <code>inline</code> 优化性能和语法结构</li><li>性能敏感的高阶函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin的高阶函数详解</title>
      <link href="/2025/04/20/kotlin/Kotlin%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/20/kotlin/Kotlin%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Kotlin的高阶函数详解</p><p>Kotlin 的高阶函数（Higher-Order Functions，简称 HOF）是函数式编程的一个重要特性，能够显著增强语言的表达力。高阶函数是指那些可以接受其他函数作为参数，或者返回函数的函数。</p><h3 id="1-高阶函数的定义"><a href="#1-高阶函数的定义" class="headerlink" title="1. 高阶函数的定义"></a>1. 高阶函数的定义</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>高阶函数指的是：</p><ul><li>接受函数作为参数</li><li>或者返回函数</li></ul><h4 id="示例：接受函数作为参数"><a href="#示例：接受函数作为参数" class="headerlink" title="示例：接受函数作为参数"></a>示例：接受函数作为参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; List&lt;T&gt;.customFilter(predicate: (T) -&gt; Boolean): List&lt;T&gt; &#123;</span><br><span class="line">    val result = mutableListOf&lt;T&gt;()</span><br><span class="line">    for (item in this) &#123;</span><br><span class="line">        if (predicate(item)) &#123;</span><br><span class="line">            result.add(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val numbers = listOf(1, 2, 3, 4, 5, 6)</span><br><span class="line">val evenNumbers = numbers.customFilter &#123; it % 2 == 0 &#125;</span><br><span class="line">println(evenNumbers)  // 输出: [2, 4, 6]</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>customFilter</code> 是一个高阶函数，它接受一个函数 <code>predicate</code> 作为参数，并根据该函数筛选列表中的元素。</p><h4 id="示例：返回函数"><a href="#示例：返回函数" class="headerlink" title="示例：返回函数"></a>示例：返回函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun multiplyBy(factor: Int): (Int) -&gt; Int &#123;</span><br><span class="line">    return &#123; number -&gt; number * factor &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val multiplyBy2 = multiplyBy(2)</span><br><span class="line">println(multiplyBy2(4))  // 输出: 8</span><br></pre></td></tr></table></figure><p>这里，<code>multiplyBy</code> 函数返回一个新的函数，它接受一个整数并将其乘以 <code>factor</code>。</p><h3 id="2-常见的高阶函数"><a href="#2-常见的高阶函数" class="headerlink" title="2. 常见的高阶函数"></a>2. 常见的高阶函数</h3><p>Kotlin 标准库包含了许多高阶函数，下面是一些常见的高阶函数。</p><h4 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a><code>map</code> 函数</h4><p><code>map</code> 是一个高阶函数，它接受一个变换函数，并返回一个新集合，其中包含应用该变换函数后的每个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val squared = numbers.map &#123; it * it &#125;</span><br><span class="line">println(squared)  // 输出: [1, 4, 9, 16]</span><br></pre></td></tr></table></figure><h4 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a><code>filter</code> 函数</h4><p><code>filter</code> 函数接受一个筛选条件，并返回一个新集合，只包含符合条件的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4, 5, 6)</span><br><span class="line">val evenNumbers = numbers.filter &#123; it % 2 == 0 &#125;</span><br><span class="line">println(evenNumbers)  // 输出: [2, 4, 6]</span><br></pre></td></tr></table></figure><h4 id="fold-函数"><a href="#fold-函数" class="headerlink" title="fold 函数"></a><code>fold</code> 函数</h4><p><code>fold</code> 是一个折叠函数，它将集合中的每个元素通过一个指定的操作组合起来，返回一个单一的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val sum = numbers.fold(0) &#123; accumulator, element -&gt; accumulator + element &#125;</span><br><span class="line">println(sum)  // 输出: 10</span><br></pre></td></tr></table></figure><p>这里，<code>fold</code> 从初始值 <code>0</code> 开始，依次将每个元素加到累加器上。</p><h4 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce 函数"></a><code>reduce</code> 函数</h4><p><code>reduce</code> 与 <code>fold</code> 类似，区别在于它没有初始值，直接使用集合的第一个元素作为初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4)</span><br><span class="line">val product = numbers.reduce &#123; accumulator, element -&gt; accumulator * element &#125;</span><br><span class="line">println(product)  // 输出: 24</span><br></pre></td></tr></table></figure><h4 id="forEach-函数"><a href="#forEach-函数" class="headerlink" title="forEach 函数"></a><code>forEach</code> 函数</h4><p><code>forEach</code> 是一个遍历集合的高阶函数，它接受一个操作函数，在集合的每个元素上执行该操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3)</span><br><span class="line">numbers.forEach &#123; println(it) &#125;</span><br><span class="line">// 输出:</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><h3 id="3-Lambda-表达式和高阶函数"><a href="#3-Lambda-表达式和高阶函数" class="headerlink" title="3. Lambda 表达式和高阶函数"></a>3. Lambda 表达式和高阶函数</h3><p>Kotlin 中，高阶函数通常与 Lambda 表达式一起使用，Lambda 表达式是一个匿名函数，它可以简洁地表示函数参数。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val sum = &#123; a: Int, b: Int -&gt; a + b &#125;</span><br><span class="line">println(sum(3, 4))  // 输出: 7</span><br></pre></td></tr></table></figure><h3 id="4-函数作为返回值"><a href="#4-函数作为返回值" class="headerlink" title="4. 函数作为返回值"></a>4. 函数作为返回值</h3><p>在 Kotlin 中，函数也可以作为返回值，且可以直接返回一个 Lambda 表达式。</p><h4 id="示例：返回一个高阶函数"><a href="#示例：返回一个高阶函数" class="headerlink" title="示例：返回一个高阶函数"></a>示例：返回一个高阶函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun operation(type: String): (Int, Int) -&gt; Int &#123;</span><br><span class="line">    return when (type) &#123;</span><br><span class="line">        &quot;sum&quot; -&gt; &#123; a, b -&gt; a + b &#125;</span><br><span class="line">        &quot;multiply&quot; -&gt; &#123; a, b -&gt; a * b &#125;</span><br><span class="line">        else -&gt; &#123; a, b -&gt; 0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val sumOperation = operation(&quot;sum&quot;)</span><br><span class="line">println(sumOperation(3, 4))  // 输出: 7</span><br><span class="line"></span><br><span class="line">val multiplyOperation = operation(&quot;multiply&quot;)</span><br><span class="line">println(multiplyOperation(3, 4))  // 输出: 12</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>operation</code> 函数根据不同的 <code>type</code> 返回不同的操作函数。</p><h3 id="5-高阶函数与集合操作结合"><a href="#5-高阶函数与集合操作结合" class="headerlink" title="5. 高阶函数与集合操作结合"></a>5. 高阶函数与集合操作结合</h3><p>Kotlin 高阶函数常常与集合操作结合使用，使得集合的处理更加简洁和高效。比如链式调用 <code>map</code>、<code>filter</code>、<code>reduce</code> 等操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4, 5)</span><br><span class="line">val result = numbers.filter &#123; it % 2 == 0 &#125;</span><br><span class="line">                     .map &#123; it * it &#125;</span><br><span class="line">                     .reduce &#123; acc, i -&gt; acc + i &#125;</span><br><span class="line">println(result)  // 输出: 20</span><br></pre></td></tr></table></figure><h3 id="6-高阶函数和匿名函数的结合"><a href="#6-高阶函数和匿名函数的结合" class="headerlink" title="6. 高阶函数和匿名函数的结合"></a>6. 高阶函数和匿名函数的结合</h3><p>Kotlin 还支持匿名函数，它们和 Lambda 表达式的使用方法类似，但可以显式声明参数类型和返回类型。</p><h4 id="示例：匿名函数"><a href="#示例：匿名函数" class="headerlink" title="示例：匿名函数"></a>示例：匿名函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val sum: (Int, Int) -&gt; Int = fun(a: Int, b: Int): Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(sum(2, 3))  // 输出: 5</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>高阶函数是 Kotlin 中非常强大的功能，它让函数式编程成为可能，能够简化代码并提高可读性。Kotlin 提供了一些内建的高阶函数，如 <code>map</code>、<code>filter</code>、<code>fold</code> 等，允许你对集合和数据进行更灵活的操作。</p><ul><li><strong>接受函数作为参数</strong>：<code>map</code>, <code>filter</code>, <code>fold</code>, 等。</li><li><strong>返回函数</strong>：可以返回一个 Lambda 函数或匿名函数。</li><li><strong>结合 Lambda 表达式使用</strong>：使得代码更加简洁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin的扩展函数和运算符重载</title>
      <link href="/2025/04/06/kotlin/Kotlin%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2025/04/06/kotlin/Kotlin%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 的扩展函数（Extension Functions）和运算符重载（Operator Overloading）是两个强大又常用的特性，用于让代码更简洁、表达力更强。</p><hr><h2 id="✅-扩展函数（Extension-Functions）"><a href="#✅-扩展函数（Extension-Functions）" class="headerlink" title="✅ 扩展函数（Extension Functions）"></a>✅ 扩展函数（Extension Functions）</h2><p><strong>定义</strong>：在不修改原类源码的情况下，为类添加新的函数。</p><h3 id="🌟-语法"><a href="#🌟-语法" class="headerlink" title="🌟 语法"></a>🌟 语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun ClassName.functionName(params): ReturnType &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🧪-示例"><a href="#🧪-示例" class="headerlink" title="🧪 示例"></a>🧪 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun String.lastChar(): Char &#123;</span><br><span class="line">    return this[this.length - 1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val s = &quot;Hello&quot;</span><br><span class="line">    println(s.lastChar())  // 输出：&#x27;o&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="📌-注意"><a href="#📌-注意" class="headerlink" title="📌 注意"></a>📌 注意</h3><ul><li><code>this</code> 代表接收者对象（上例中是 <code>String</code>）</li><li>扩展函数<strong>不会真正修改原类</strong>，只是通过静态方式实现“扩展”</li><li>若类有成员函数与扩展函数同名，<strong>成员函数优先</strong></li></ul><hr><h2 id="➕-运算符重载（Operator-Overloading）"><a href="#➕-运算符重载（Operator-Overloading）" class="headerlink" title="➕ 运算符重载（Operator Overloading）"></a>➕ 运算符重载（Operator Overloading）</h2><p><strong>定义</strong>：通过定义带有 <code>operator</code> 关键字的函数，自定义类的运算符行为（如 <code>+</code>, <code>-</code>, <code>[]</code>, <code>==</code> 等）。</p><h3 id="🌟-支持的运算符（部分）"><a href="#🌟-支持的运算符（部分）" class="headerlink" title="🌟 支持的运算符（部分）"></a>🌟 支持的运算符（部分）</h3><table><thead><tr><th>运算符</th><th>对应函数名</th></tr></thead><tbody><tr><td><code>+</code></td><td><code>plus</code></td></tr><tr><td><code>-</code></td><td><code>minus</code></td></tr><tr><td><code>*</code></td><td><code>times</code></td></tr><tr><td><code>/</code></td><td><code>div</code></td></tr><tr><td><code>%</code></td><td><code>rem</code></td></tr><tr><td><code>==</code></td><td><code>equals</code></td></tr><tr><td><code>[]</code></td><td><code>get</code>, <code>set</code></td></tr><tr><td><code>..</code></td><td><code>rangeTo</code></td></tr><tr><td><code>in</code></td><td><code>contains</code></td></tr></tbody></table><h3 id="🧪-示例-1"><a href="#🧪-示例-1" class="headerlink" title="🧪 示例"></a>🧪 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data class Point(val x: Int, val y: Int) &#123;</span><br><span class="line">    operator fun plus(other: Point): Point &#123;</span><br><span class="line">        return Point(x + other.x, y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val p1 = Point(1, 2)</span><br><span class="line">    val p2 = Point(3, 4)</span><br><span class="line">    println(p1 + p2) // 输出：Point(x=4, y=6)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⚠️-注意"><a href="#⚠️-注意" class="headerlink" title="⚠️ 注意"></a>⚠️ 注意</h3><ul><li>需加 <code>operator</code> 关键字</li><li>Kotlin 会根据运算符自动映射到相应的函数</li></ul><hr><h2 id="✨-拓展-运算符重载的组合示例"><a href="#✨-拓展-运算符重载的组合示例" class="headerlink" title="✨ 拓展+运算符重载的组合示例"></a>✨ 拓展+运算符重载的组合示例</h2><p>你甚至可以为已有类<strong>扩展运算符函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">operator fun String.times(n: Int): String &#123;</span><br><span class="line">    return this.repeat(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;Hi! &quot; * 3) // 输出：Hi! Hi! Hi! </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延迟初始化与封装类</title>
      <link href="/2025/04/06/kotlin/%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%B0%81%E8%A3%85%E7%B1%BB/"/>
      <url>/2025/04/06/kotlin/%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%B0%81%E8%A3%85%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="🔹-1-延迟初始化-lateinit"><a href="#🔹-1-延迟初始化-lateinit" class="headerlink" title="🔹 1. 延迟初始化 (lateinit)"></a>🔹 1. 延迟初始化 (<code>lateinit</code>)</h2><h3 id="✅-用途："><a href="#✅-用途：" class="headerlink" title="✅ 用途："></a>✅ 用途：</h3><p>当你不想在定义变量时立刻初始化它，但又确定在使用前一定会初始化（比如依赖注入、测试、Android View 绑定等）。</p><h3 id="✅-语法："><a href="#✅-语法：" class="headerlink" title="✅ 语法："></a>✅ 语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lateinit var name: String</span><br></pre></td></tr></table></figure><h3 id="✅-注意事项："><a href="#✅-注意事项：" class="headerlink" title="✅ 注意事项："></a>✅ 注意事项：</h3><ul><li>只能用于 **<code>var</code>**，不能用于 <code>val</code>。</li><li>只能用于 <strong>非空类型的引用类型</strong>（不能是原始类型如 <code>Int</code>、<code>Double</code>）。</li><li>使用前如果没初始化，会抛出 **<code>UninitializedPropertyAccessException</code>**。</li></ul><h3 id="✅-示例："><a href="#✅-示例：" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    lateinit var nickname: String</span><br><span class="line"></span><br><span class="line">    fun initNickname() &#123;</span><br><span class="line">        nickname = &quot;KotlinFan&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun printNickname() &#123;</span><br><span class="line">        if (::nickname.isInitialized) &#123;</span><br><span class="line">            println(nickname)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println(&quot;nickname 尚未初始化&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-2-密封类（sealed-class）"><a href="#🔹-2-密封类（sealed-class）" class="headerlink" title="🔹 2. 密封类（sealed class）"></a>🔹 2. 密封类（<code>sealed class</code>）</h2><h3 id="✅-用途：-1"><a href="#✅-用途：-1" class="headerlink" title="✅ 用途："></a>✅ 用途：</h3><p>用于表示<strong>受限的类继承结构</strong>，所有子类都必须声明在同一个文件中。常用于表示状态、结果、事件等。</p><p>类似于 Java 的 <code>enum</code>，但可以携带数据。常配合 <code>when</code> 表达式使用，可以 <strong>无需 else</strong> 分支。</p><h3 id="✅-示例：-1"><a href="#✅-示例：-1" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sealed class Result</span><br><span class="line"></span><br><span class="line">data class Success(val data: String) : Result()</span><br><span class="line">data class Error(val message: String) : Result()</span><br><span class="line">object Loading : Result()</span><br><span class="line"></span><br><span class="line">fun handleResult(result: Result) &#123;</span><br><span class="line">    when (result) &#123;</span><br><span class="line">        is Success -&gt; println(&quot;成功: $&#123;result.data&#125;&quot;)</span><br><span class="line">        is Error -&gt; println(&quot;失败: $&#123;result.message&#125;&quot;)</span><br><span class="line">        Loading -&gt; println(&quot;加载中...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔸-总结对比"><a href="#🔸-总结对比" class="headerlink" title="🔸 总结对比"></a>🔸 总结对比</h2><table><thead><tr><th>特性</th><th><code>lateinit</code></th><th><code>sealed class</code></th></tr></thead><tbody><tr><td>用途</td><td>延迟初始化引用变量</td><td>表示受限的继承结构，常用于状态建模</td></tr><tr><td>限制</td><td>不能用于 <code>val</code> 或基本类型</td><td>所有子类必须在同一文件中定义</td></tr><tr><td>常用场景</td><td>Android View、依赖注入等</td><td>网络请求结果、UI状态、表达式分支等</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intent</title>
      <link href="/2025/03/28/android%E7%BB%84%E4%BB%B6/%E6%98%BE%E5%BC%8FIntent%E4%B8%8E%E9%9A%90%E5%BC%8FIntent/"/>
      <url>/2025/03/28/android%E7%BB%84%E4%BB%B6/%E6%98%BE%E5%BC%8FIntent%E4%B8%8E%E9%9A%90%E5%BC%8FIntent/</url>
      
        <content type="html"><![CDATA[<p>显式Intent与隐式Intent</p><h6 id="ChatGPT-说："><a href="#ChatGPT-说：" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>在 Android 中，<strong>Intent（意图）</strong> 是组件（Activity、Service、BroadcastReceiver）之间进行通信的机制。Intent 主要分为两种类型：</p><h3 id="1-显式-Intent（Explicit-Intent）"><a href="#1-显式-Intent（Explicit-Intent）" class="headerlink" title="1. 显式 Intent（Explicit Intent）"></a><strong>1. 显式 Intent（Explicit Intent）</strong></h3><p>显式 Intent 直接指定目标组件（Activity、Service）的 <strong>类名</strong>，用于在 <strong>应用内部</strong> 启动组件。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(this, SecondActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li><strong>适用于应用内部</strong> 组件间的交互，比如从 <code>MainActivity</code> 跳转到 <code>SecondActivity</code>。</li><li><strong>指定目标类名</strong>，不会让系统去匹配 <code>intent-filter</code>。</li><li><strong>性能更高</strong>，因为不需要系统查找匹配的组件。</li></ul><hr><h3 id="2-隐式-Intent（Implicit-Intent）"><a href="#2-隐式-Intent（Implicit-Intent）" class="headerlink" title="2. 隐式 Intent（Implicit Intent）"></a><strong>2. 隐式 Intent（Implicit Intent）</strong></h3><p>隐式 Intent <strong>不指定</strong> 目标组件的类名，而是使用 <strong>动作（Action）、类别（Category）、数据（Data）</strong> 让系统找到符合条件的组件。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><p>打开网页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(Uri.parse(&quot;https://www.example.com&quot;));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>拨打电话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(Intent.ACTION_DIAL);</span><br><span class="line">intent.setData(Uri.parse(&quot;tel:123456789&quot;));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li><p><strong>适用于调用其他应用的功能</strong>，例如打开浏览器、拨号、分享文本等。</p></li><li><p>需要在 <code>AndroidManifest.xml</code> 中声明 <code>intent-filter</code>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.ThirdActivity&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">        &lt;data android:scheme=&quot;https&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>系统会自动匹配</strong> 适合的应用来处理这个 Intent。</p></li></ul><hr><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a><strong>对比总结</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>显式 Intent</strong></th><th><strong>隐式 Intent</strong></th></tr></thead><tbody><tr><td><strong>目标组件</strong></td><td><strong>明确指定</strong> 类名，如 <code>SecondActivity.class</code></td><td><strong>不指定</strong> 类名，使用 <code>Action + Data</code> 让系统匹配</td></tr><tr><td><strong>适用场景</strong></td><td>应用内部跳转，如 <code>ActivityA → ActivityB</code></td><td>调用系统&#x2F;其他应用功能，如打开网页、拨打电话</td></tr><tr><td><strong>匹配方式</strong></td><td><strong>直接找到组件</strong> 并启动</td><td><strong>系统匹配 <code>intent-filter</code></strong> 找到合适的组件</td></tr><tr><td><strong>性能</strong></td><td><strong>更快</strong>，因为不需要匹配</td><td><strong>稍慢</strong>，需要查询可能的匹配组件</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> android主要组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android主要组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin lambda编程</title>
      <link href="/2025/03/28/kotlin/kotlin%20lambda/"/>
      <url>/2025/03/28/kotlin/kotlin%20lambda/</url>
      
        <content type="html"><![CDATA[<h1 id="kotlin-lambda编程"><a href="#kotlin-lambda编程" class="headerlink" title="kotlin lambda编程"></a>kotlin lambda编程</h1><p>Kotlin 的 Lambda（匿名函数）是函数式编程的核心特性之一，允许你以简洁的方式编写代码，尤其适用于集合操作、回调、DSL（领域特定语言）等场景。</p><h2 id="1-Lambda-表达式基础"><a href="#1-Lambda-表达式基础" class="headerlink" title="1. Lambda 表达式基础"></a>1. Lambda 表达式基础</h2><p>Lambda 表达式是一个匿名函数，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val sum: (Int, Int) -&gt; Int = &#123; a, b -&gt; a + b &#125;</span><br><span class="line">println(sum(2, 3)) // 输出 5</span><br></pre></td></tr></table></figure><p><strong>语法说明</strong>：</p><ul><li><code>&#123; 参数1, 参数2 -&gt; 函数体 &#125;</code></li><li><code>val sum: (Int, Int) -&gt; Int</code> 明确声明了函数类型，表示它接收两个 <code>Int</code> 并返回 <code>Int</code>。</li></ul><h2 id="2-使用-it-关键字"><a href="#2-使用-it-关键字" class="headerlink" title="2. 使用 it 关键字"></a>2. 使用 <code>it</code> 关键字</h2><p>当 Lambda 只有一个参数时，可以用 <code>it</code> 代替参数名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val square: (Int) -&gt; Int = &#123; it * it &#125;</span><br><span class="line">println(square(4)) // 输出 16</span><br></pre></td></tr></table></figure><h2 id="3-Lambda-作为函数参数"><a href="#3-Lambda-作为函数参数" class="headerlink" title="3. Lambda 作为函数参数"></a>3. Lambda 作为函数参数</h2><p>Lambda 可以作为参数传递给函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun operateOnNumbers(a: Int, b: Int, operation: (Int, Int) -&gt; Int): Int &#123;</span><br><span class="line">    return operation(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val result = operateOnNumbers(4, 5) &#123; x, y -&gt; x * y &#125;</span><br><span class="line">println(result) // 输出 20</span><br></pre></td></tr></table></figure><h2 id="4-高阶函数-结合-Lambda"><a href="#4-高阶函数-结合-Lambda" class="headerlink" title="4. 高阶函数 结合 Lambda"></a>4. <code>高阶函数</code> 结合 Lambda</h2><p>Kotlin 支持高阶函数（即参数或返回值是函数的函数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun higherOrderFunction(operation: () -&gt; Unit) &#123;</span><br><span class="line">    operation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">higherOrderFunction &#123; println(&quot;Hello, Lambda!&quot;) &#125;</span><br></pre></td></tr></table></figure><h2 id="5-在集合操作中的应用"><a href="#5-在集合操作中的应用" class="headerlink" title="5. 在集合操作中的应用"></a>5. 在集合操作中的应用</h2><p>Lambda 在 Kotlin 的集合 API 中应用广泛，如 <code>map</code>、<code>filter</code>、<code>reduce</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(1, 2, 3, 4, 5)</span><br><span class="line">val squaredNumbers = numbers.map &#123; it * it &#125;</span><br><span class="line">println(squaredNumbers) // 输出 [1, 4, 9, 16, 25]</span><br><span class="line"></span><br><span class="line">val evenNumbers = numbers.filter &#123; it % 2 == 0 &#125;</span><br><span class="line">println(evenNumbers) // 输出 [2, 4]</span><br></pre></td></tr></table></figure><h2 id="6-let、apply、run、with、also"><a href="#6-let、apply、run、with、also" class="headerlink" title="6. let、apply、run、with、also"></a>6. <code>let</code>、<code>apply</code>、<code>run</code>、<code>with</code>、<code>also</code></h2><p>Kotlin 提供了一系列作用域函数，结合 Lambda 使用非常强大：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val name: String? = &quot;Kotlin&quot;</span><br><span class="line">name?.let &#123; println(it.uppercase()) &#125; // 非空时执行</span><br><span class="line"></span><br><span class="line">val person = Person(&quot;John&quot;).apply &#123; age = 30 &#125; // apply 适用于修改对象属性</span><br><span class="line">println(person)</span><br></pre></td></tr></table></figure><h2 id="7-闭包（Closure）"><a href="#7-闭包（Closure）" class="headerlink" title="7. 闭包（Closure）"></a>7. 闭包（Closure）</h2><p>Lambda 表达式可以访问外部变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun counter(): () -&gt; Int &#123;</span><br><span class="line">    var count = 0</span><br><span class="line">    return &#123; count++ &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val next = counter()</span><br><span class="line">println(next()) // 0</span><br><span class="line">println(next()) // 1</span><br><span class="line">println(next()) // 2</span><br></pre></td></tr></table></figure><h2 id="8-带-return-的-Lambda"><a href="#8-带-return-的-Lambda" class="headerlink" title="8. 带 return 的 Lambda"></a>8. 带 <code>return</code> 的 Lambda</h2><p>Lambda 默认返回最后一行的值，如果需要提前返回，可以使用 <code>return@label</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listOf(1, 2, 3, 4, 5).forEach &#123; </span><br><span class="line">    if (it == 3) return@forEach </span><br><span class="line">    println(it) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空指针检查</title>
      <link href="/2025/03/28/kotlin/%E7%A9%BA%E6%8C%87%E9%92%88%E6%A3%80%E6%9F%A5/"/>
      <url>/2025/03/28/kotlin/%E7%A9%BA%E6%8C%87%E9%92%88%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 通过 <strong>空安全（Null Safety）</strong> 机制减少了空指针异常（NullPointerException，NPE）。以下是 Kotlin 中处理空指针的常见方式：</p><hr><h3 id="1-可空类型"><a href="#1-可空类型" class="headerlink" title="1. 可空类型 (?)"></a>1. <strong>可空类型 (<code>?</code>)</strong></h3><p><img src="https://raw.githubusercontent.com/BoardYoungC/imgRepo/main/imgs/20251126223421829.png" alt="image-20251126223421759"></p><p>Kotlin 默认所有变量都不能为空。如果需要允许 <code>null</code>，必须显式声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = &quot;Kotlin&quot;</span><br><span class="line">name = null  // 允许赋值 null</span><br></pre></td></tr></table></figure><hr><h3 id="2-安全调用"><a href="#2-安全调用" class="headerlink" title="2. 安全调用 (?.)"></a>2. <strong>安全调用 (<code>?.</code>)</strong></h3><p>当变量可能为 <code>null</code> 时，可以使用 <strong>安全调用</strong> 来避免 NPE：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val length: Int? = name?.length  // name 为 null 时，length 也为 null</span><br></pre></td></tr></table></figure><hr><h3 id="3-Elvis-运算符"><a href="#3-Elvis-运算符" class="headerlink" title="3. Elvis 运算符 (?:)"></a>3. <strong>Elvis 运算符 (<code>?:</code>)</strong></h3><p>提供默认值，避免 <code>null</code> 影响程序逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val length: Int = name?.length ?: 0  // name 为 null 时，length 取 0</span><br></pre></td></tr></table></figure><hr><h3 id="4-非空断言"><a href="#4-非空断言" class="headerlink" title="4. 非空断言 (!!)"></a>4. <strong>非空断言 (<code>!!</code>)</strong></h3><p>强制告诉编译器变量不为空，否则抛出 <code>NullPointerException</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val length: Int = name!!.length  // 如果 name 为空，则抛出 NPE</span><br></pre></td></tr></table></figure><p>⚠ <strong>慎用 <code>!!</code>，仅在明确不为空时使用！</strong></p><hr><h3 id="5-let-作用域函数"><a href="#5-let-作用域函数" class="headerlink" title="5. let 作用域函数"></a>5. <strong><code>let</code> 作用域函数</strong></h3><p><code>let</code> 结合安全调用 (<code>?.</code>)，可用于在非空时执行某些操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name?.let &#123;</span><br><span class="line">    println(&quot;Length: $&#123;it.length&#125;&quot;)  // 仅当 name 不为空时执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-lateinit-和-by-lazy"><a href="#6-lateinit-和-by-lazy" class="headerlink" title="6. lateinit 和 by lazy"></a>6. <strong><code>lateinit</code> 和 <code>by lazy</code></strong></h3><ul><li><p><code>lateinit</code> 适用于非 <code>null</code> 类型的延迟初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lateinit var text: String</span><br><span class="line">// text.length // 若未初始化，访问会抛出 UninitializedPropertyAccessException</span><br></pre></td></tr></table></figure></li><li><p><code>lazy</code> 适用于 <code>val</code> 类型的惰性初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val message: String by lazy &#123; &quot;Hello, Kotlin!&quot; &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-requireNotNull-和-checkNotNull"><a href="#7-requireNotNull-和-checkNotNull" class="headerlink" title="7. requireNotNull 和 checkNotNull"></a>7. <strong><code>requireNotNull</code> 和 <code>checkNotNull</code></strong></h3><p>手动检查 <code>null</code> 并抛出异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val nonNullName: String = requireNotNull(name) &#123; &quot;name 不能为空&quot; &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-数据类默认值"><a href="#8-数据类默认值" class="headerlink" title="8. 数据类默认值"></a>8. <strong>数据类默认值</strong></h3><p>如果某个字段可能为空，最好提供默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">data class User(val name: String = &quot;Unknown&quot;)</span><br></pre></td></tr></table></figure><hr><h3 id="9-平台类型-Java-互操作"><a href="#9-平台类型-Java-互操作" class="headerlink" title="9. 平台类型 (Java 互操作)"></a>9. <strong>平台类型 (<code>Java</code> 互操作)</strong></h3><p>从 Java 代码获取的变量可能为空，Kotlin 不能自动推断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val text: String? = javaMethodReturningNullable()  // Java 方法返回值可能为 null</span><br></pre></td></tr></table></figure><hr><h3 id="10-使用-Nullable-和-NotNull-注解"><a href="#10-使用-Nullable-和-NotNull-注解" class="headerlink" title="10. 使用 @Nullable 和 @NotNull 注解"></a>10. <strong>使用 <code>@Nullable</code> 和 <code>@NotNull</code> 注解</strong></h3><p>在 Kotlin 互操作 Java 时，可以使用这些注解来增强类型安全：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">public String getNullableString() &#123; return null; &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>方式</th><th>作用</th></tr></thead><tbody><tr><td><code>?</code></td><td>允许 <code>null</code></td></tr><tr><td><code>?.</code></td><td>安全调用</td></tr><tr><td><code>?:</code></td><td>默认值</td></tr><tr><td><code>!!</code></td><td>非空断言（可能抛 NPE）</td></tr><tr><td><code>let</code></td><td>仅在非空时执行</td></tr><tr><td><code>lateinit</code> &#x2F; <code>lazy</code></td><td>延迟初始化</td></tr><tr><td><code>requireNotNull</code></td><td>手动 <code>null</code> 检查</td></tr><tr><td><code>@Nullable</code></td><td>Java 互操作</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
